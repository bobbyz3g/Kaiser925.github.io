<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>泛型接口</title>
    <link href="/post/generic-interfaces.html"/>
    <url>/post/generic-interfaces.html</url>
    
    <content type="html"><![CDATA[<p>有一个概念，初次接触时可能不易察觉：接口本身也是一种类型，因此，它同样可以拥有类型参数。在为泛型函数和类型定义约束时，这一特性显得尤为强大。本文将通过几个常见场景，深入探讨如何运用带类型参数的接口，一展其威力。</p><h2 id="一个简单的二叉搜索树"><a href="#一个简单的二叉搜索树" class="headerlink" title="一个简单的二叉搜索树"></a>一个简单的二叉搜索树</h2><p>我们从一个经典的例子开始：实现一个泛型的二叉搜索树。存储在树中的元素必须是可排序的，因此我们需要为类型参数添加一个约束，来明确排序规则。一个直接的选择是使用 Go 1.21 中引入的 <code>cmp.Ordered</code> 约束。它将类型参数限制为内置的有序类型（如字符串和数字），并允许我们直接使用内置的比较运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The zero value of a Tree is a ready-to-use empty tree.</span><br><span class="hljs-keyword">type</span> Tree[E cmp.Ordered] <span class="hljs-keyword">struct</span> &#123;<br>    root *node[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Tree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(element)<br>&#125;<br><br><span class="hljs-keyword">type</span> node[E cmp.Ordered] <span class="hljs-keyword">struct</span> &#123;<br>    value E<br>    left  *node[E]<br>    right *node[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node[E])</span></span> insert(element E) *node[E] &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;node[E]&#123;value: element&#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> element &lt; n.value:<br>        n.left = n.left.insert(element)<br>    <span class="hljs-keyword">case</span> element &gt; n.value:<br>        n.right = n.right.insert(element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，该方案的局限在于，它只适用于 Go 内置支持 <code>&lt;</code> 运算符的基本类型；你无法用它来存储像 <code>time.Time</code> 这样的结构体类型。</p><p>为了解决这个问题，我们可以要求用户提供一个比较函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A FuncTree must be created with NewTreeFunc.</span><br><span class="hljs-keyword">type</span> FuncTree[E any] <span class="hljs-keyword">struct</span> &#123;<br>    root *funcNode[E]<br>    cmp  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(E, E)</span></span> <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFuncTree</span>[<span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(cmp <span class="hljs-keyword">func</span>(E, E)</span></span> <span class="hljs-type">int</span>) *FuncTree[E] &#123;<br>    <span class="hljs-keyword">return</span> &amp;FuncTree[E]&#123;cmp: cmp&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *FuncTree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(t.cmp, element)<br>&#125;<br><br><span class="hljs-keyword">type</span> funcNode[E any] <span class="hljs-keyword">struct</span> &#123;<br>    value E<br>    left  *funcNode[E]<br>    right *funcNode[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *funcNode[E])</span></span> insert(cmp <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(E, E)</span></span> <span class="hljs-type">int</span>, element E) *funcNode[E] &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;funcNode[E]&#123;value: element&#125;<br>    &#125;<br>    sign := cmp(element, n.value)<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> sign &lt; <span class="hljs-number">0</span>:<br>        n.left = n.left.insert(cmp, element)<br>    <span class="hljs-keyword">case</span> sign &gt; <span class="hljs-number">0</span>:<br>        n.right = n.right.insert(cmp, element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法虽然可行，但同样存在不足。首先，我们无法再使用容器类型的零值，因为它需要显式初始化比较函数。其次，将比较函数作为字段存储，使得编译器难以对其进行内联优化，可能引入显著的运行时开销。</p><p>更理想的方案是利用元素类型自身的方法来定义比较行为，因为方法与类型直接关联。这样一来，比较逻辑不必作为参数显式传递，编译器也能更好地洞察调用目标，从而可能进行内联优化。但问题是，我们如何通过约束来要求元素类型必须提供我们需要的方法呢？</p><h2 id="在约束中使用接收器"><a href="#在约束中使用接收器" class="headerlink" title="在约束中使用接收器"></a>在约束中使用接收器</h2><p>我们首先想到的，或许是定义一个传统的接口，其中包含 <code>Compare</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Comparer <span class="hljs-keyword">interface</span>&#123;<br>  Compare(Comparer) <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然而，我们很快会发现这行不通。因为要实现该接口，<code>Compare</code> 方法的参数必须是 <code>Comparer</code> 接口类型。这意味着实现方需要对参数进行类型断言，而且每个实现该接口的类型都必须显式地导入定义 <code>Comparer</code> 的包，这使得代码耦合过高，不够通用。</p><p>更好的方式是让 <code>Comparer</code> 接口本身变为泛型接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Comparer[T any] <span class="hljs-keyword">interface</span>&#123;<br>  Compare(T) <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>Comparer[T]</code> 定义了一个接口族，每种可实例化的类型 <code>T</code> 都会对应一个具体的接口。实现 <code>Comparer[T]</code> 的类型等于声明：“我可以将自己与 <code>T</code> 类型的实例进行比较”。例如，<code>time.Time</code> 类型因为定义了 <code>Compare(u Time) int</code> 方法，所以它自动实现了 <code>Comparer[time.Time]</code> 接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 实现了 Comparer[Time]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Time)</span></span> Compare(u Time) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>这比最初的定义要好，但还不够。我们真正需要的是一个能够表达“类型参数可以与自身比较”的约束，即一个自引用的约束。这里的关键点在于，这种“自比较”的特性不一定需要体现在接口定义的内部（即 <code>Comparer</code> 类型中 <code>T</code> 的约束仍然是 <code>any</code>），而应该体现在我们使用它作为约束的时候：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The zero value of a MethodTree is a ready-to-use empty tree.</span><br><span class="hljs-keyword">type</span> MethodTree[E Comparer[E]] <span class="hljs-keyword">struct</span> &#123;<br>    root *methodNode[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *MethodTree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(element)<br>&#125;<br><br><span class="hljs-keyword">type</span> methodNode[E Comparer[E]] <span class="hljs-keyword">struct</span> &#123;<br>    value E<br>    left  *methodNode[E]<br>    right *methodNode[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *methodNode[E])</span></span> insert(element E) *methodNode[E] &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;methodNode[E]&#123;value: element&#125;<br>    &#125;<br>    sign := element.Compare(n.value)<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> sign &lt; <span class="hljs-number">0</span>:<br>        n.left = n.left.insert(element)<br>    <span class="hljs-keyword">case</span> sign &gt; <span class="hljs-number">0</span>:<br>        n.right = n.right.insert(element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>time.Time</code> 实现了 <code>Comparer[time.Time]</code>，我们现在便可将其用于 ，并且依然可以方便地使用零值作为空容器。 <code>MethodTree</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t MethodTree[time.Time]<br>t.Insert(time.Now())<br></code></pre></td></tr></table></figure><p>为了提供最大的灵活性，我们的库可以同时提供上述所有三个版本的 API。如果想减少代码重复，所有版本都可以基于一个共享的内部实现来封装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> node[E any] <span class="hljs-keyword">struct</span> &#123;<br>    value E<br>    left  *node[E]<br>    right *node[E]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node[E])</span></span> insert(cmp <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(E, E)</span></span> <span class="hljs-type">int</span>, element E) *node[E] &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;node[E]&#123;value: element&#125;<br>    &#125;<br>    sign := cmp(element, n.value)<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> sign &lt; <span class="hljs-number">0</span>:<br>        n.left = n.left.insert(cmp, element)<br>    <span class="hljs-keyword">case</span> sign &gt; <span class="hljs-number">0</span>:<br>        n.right = n.right.insert(cmp, element)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-comment">// Insert inserts element into the tree, if E implements cmp.Ordered.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Tree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(cmp.Compare[E], element)<br>&#125;<br><br><span class="hljs-comment">// Insert inserts element into the tree, using the provided comparison function.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *FuncTree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(t.cmp, element)<br>&#125;<br><br><span class="hljs-comment">// Insert inserts element into the tree, if E implements Comparer[E].</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *MethodTree[E])</span></span> Insert(element E) &#123;<br>    t.root = t.root.insert(E.Compare, element)<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，这个共享的内部实现（基于函数的版本）本身不受任何约束，以保持最大的灵活性。我们也没有将比较函数存储在结构体字段中，而是将其作为参数传递，因为函数参数通常比结构体字段更容易被编译器分析和优化。</p><p>当然，这种封装仍然需要一些模板代码，因为每个导出的实现都需要复制完整的 API 并适配不同的调用模式。但好在这些封装代码通常逻辑简单，易于编写和阅读。</p><h2 id="组合方法和类型集"><a href="#组合方法和类型集" class="headerlink" title="组合方法和类型集"></a>组合方法和类型集</h2><p>我们可以利用这棵树来实现一个有序集合（ordered set），它能以对数时间复杂度查找元素。现在，设想我们需要将元素查找的效率提升至近乎常数时间（O(1)）。一个自然的想法是在树结构之外，额外维护一个 map 来存储元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> OrderedSet[E Comparer[E]] <span class="hljs-keyword">struct</span> &#123;<br>    tree     MethodTree[E] <span class="hljs-comment">// for efficient iteration in order</span><br>    elements <span class="hljs-keyword">map</span>[E]<span class="hljs-type">bool</span>    <span class="hljs-comment">// for (near) constant time lookup</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *OrderedSet[E])</span></span> Has(e E) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> s.elements[e]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *OrderedSet[E])</span></span> Insert(e E) &#123;<br>    <span class="hljs-keyword">if</span> s.elements == <span class="hljs-literal">nil</span> &#123;<br>        s.elements = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[E]<span class="hljs-type">bool</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> s.elements[e] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    s.elements[e] = <span class="hljs-literal">true</span><br>    s.tree.Insert(e)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *OrderedSet[E])</span></span> All() iter.Seq[E] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(yield <span class="hljs-keyword">func</span>(E)</span></span> <span class="hljs-type">bool</span>) &#123;<br>        s.tree.root.all(yield)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node[E])</span></span> all(yield <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(E)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-literal">nil</span> || (n.left.all(yield) &amp;&amp; yield(n.value) &amp;&amp; n.right.all(yield))<br>&#125;<br></code></pre></td></tr></table></figure><p>然而, 这个代码无法编译:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">invalid</span> map key <span class="hljs-keyword">type</span> <span class="hljs-type">E</span> (missing comparable constraint)<br></code></pre></td></tr></table></figure><p>错误信息提示我们，为了将类型参数 <code>E</code> 作为 map 的键，我们需要为其添加额外的约束。<code>comparable</code> 是一个预声明的特殊约束，所有支持 <code>==</code> 和 <code>!=</code> 运算符的类型都满足它，这些类型也正是可以用作 map 键的类型</p><p>我们有三种方式来为类型参数添加这个额外的约束，它们各有取舍:</p><ol><li><p>我们可以将 comparable 嵌入到原始的 Comparer 定义中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Comparer[E any] <span class="hljs-keyword">interface</span> &#123;<br>    comparable<br>    Compare(E) <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是这会限制我们所有的树类型都只能与可比较（comparable）的类型一起使用。通常，我们不希望在没有必要的情况下过度约束泛型类型</p></li><li><p>定义一个新的组合约束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Comparer[E any] <span class="hljs-keyword">interface</span> &#123;<br>    Compare(E) <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ComparableComparer[E any] <span class="hljs-keyword">interface</span> &#123;<br>    comparable<br>    Comparer[E]<br>&#125;<br></code></pre></td></tr></table></figure><p>这很简洁, 但它会在我们的 API 中引入一个新的标识符（<code>ComparableComparer</code>），而且这类名称往往很难起得优雅</p></li><li><p>在使用处内联约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> OrderedSet[E <span class="hljs-keyword">interface</span> &#123;<br>    comparable<br>    Comparer[E]<br>&#125;] <span class="hljs-keyword">struct</span> &#123;<br>    tree     Tree[E]<br>    elements <span class="hljs-keyword">map</span>[E]<span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种内联方式会降低代码的可读性，尤其是在需要频繁使用该约束的场景下。同时，这也使得在其他地方重用此约束变得困难。</p></li></ol><p>具体选择哪一种，很大程度上取决于个人偏好和项目约定 .</p><h2 id="不-约束泛型接口"><a href="#不-约束泛型接口" class="headerlink" title="(不) 约束泛型接口"></a>(不) 约束泛型接口</h2><p>对泛型接口的约束是一个值得深入探讨的话题。假设你想为通用的“集合”类型定义一个接口。考虑到现实世界中存在多种多样的集合实现，它们在性能和特性上各有权衡，定义一个通用接口可以增加代码的灵活性，将具体实现的选择权交给用户:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set[E any] <span class="hljs-keyword">interface</span> &#123;<br>    Insert(E)<br>    Delete(E)<br>    Has(E) <span class="hljs-type">bool</span><br>    All() iter.Seq[E]<br>&#125;<br></code></pre></td></tr></table></figure><p>一个很自然的问题是：这个泛型接口的类型参数 <code>E</code> 应该接受什么样的约束？如果可能，**泛型接口上的类型参数约束应尽量保持为 <code>any</code>**，以允许任何类型。</p><p>答案，其实已在我们此前的讨论中初见端倪：不同的具体实现可能需要不同的约束。我们上面实现的所有 <code>Tree</code> 类型以及 <code>OrderedSet</code> 类型，尽管它们各自有着不同的约束，但都可以实现这个 <code>Set[E]</code> 接口。</p><p>定义接口的核心目的，正是为了将具体实现的选择权交给用户。既然我们无法预知用户会为其实现施加何种约束，那么就应该将比 <code>any</code> 更强的约束下放到具体的实现中，而不是限制在接口定义上。</p><h2 id="指针接收器"><a href="#指针接收器" class="headerlink" title="指针接收器"></a>指针接收器</h2><p>让我们尝试在实践中使用 <code>Set</code> 接口。考虑一个从序列中移除重复元素的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Unique removes duplicate elements from the input sequence, yielding only</span><br><span class="hljs-comment">// the first instance of any element.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unique</span>[<span class="hljs-title">E</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(input iter.Seq[E])</span></span> iter.Seq[E] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(yield <span class="hljs-keyword">func</span>(E)</span></span> <span class="hljs-type">bool</span>) &#123;<br>        seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[E]<span class="hljs-type">bool</span>)<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> input &#123;<br>            <span class="hljs-keyword">if</span> seen[v] &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !yield(v) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            seen[v] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 <code>map</code> 作为 <code>Set[E]</code> 的一个简单实现，它只适用于可比较的类型。如果我们想让它支持任意类型，就需要将 <code>map</code> 替换为一个 <code>Set[E]</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Unique removes duplicate elements from the input sequence, yielding only</span><br><span class="hljs-comment">// the first instance of any element.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unique</span>[<span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(input iter.Seq[E])</span></span> iter.Seq[E] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(yield <span class="hljs-keyword">func</span>(E)</span></span> <span class="hljs-type">bool</span>) &#123;<br>        <span class="hljs-keyword">var</span> seen Set[E]<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> input &#123;<br>            <span class="hljs-keyword">if</span> seen.Has(v) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !yield(v) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            seen.Insert(v)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但这并不可行。因为 <code>Set[E]</code> 是一个接口类型，变量 <code>seen</code> 的零值是 <code>nil</code> 。直接在 <code>nil</code> 接口值上调用方法会引发运行时 panic。我们需要 <code>Set[E]</code> 接口的一个具体实现。然而，正如我们所见，并不存在一个适用于所有元素类型的通用 <code>Set[E]</code> 实现。 </p><p>因此，我们必须要求用户提供一个我们可以使用的具体实现，将其作为额外的类型参数传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Unique removes duplicate elements from the input sequence, yielding only</span><br><span class="hljs-comment">// the first instance of any element.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unique</span>[<span class="hljs-title">E</span> <span class="hljs-title">any</span>, <span class="hljs-title">S</span> <span class="hljs-title">Set</span>[<span class="hljs-title">E</span>]]<span class="hljs-params">(input iter.Seq[E])</span></span> iter.Seq[E] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(yield <span class="hljs-keyword">func</span>(E)</span></span> <span class="hljs-type">bool</span>) &#123;<br>        <span class="hljs-keyword">var</span> seen S<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> input &#123;<br>            <span class="hljs-keyword">if</span> seen.Has(v) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !yield(v) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            seen.Insert(v)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/kjkGy5cNz8T">playground</a></p><p>当我们尝试传入一个我们之前定义的 <code>OrderedSet[E]</code> 作为 <code>S</code> 时，会遇到另一个问题：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">//</span> <span class="hljs-variable">OrderedSet</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">does</span> <span class="hljs-variable">not</span> <span class="hljs-variable">satisfy</span> <span class="hljs-built_in">Set</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">method</span> <span class="hljs-built_in">All</span> <span class="hljs-variable">has</span> <span class="hljs-variable">pointer</span> <span class="hljs-variable">receiver</span><span class="hljs-punctuation">)</span><br><span class="hljs-built_in">Unique</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-operator">,</span> <span class="hljs-variable">OrderedSet</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">slices</span><span class="hljs-operator">.</span><span class="hljs-built_in">Values</span><span class="hljs-punctuation">(</span><span class="hljs-variable">s</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><span class="hljs-operator">//</span> <span class="hljs-variable">panic</span><span class="hljs-operator">:</span> <span class="hljs-variable">invalid</span> <span class="hljs-variable">memory</span> <span class="hljs-variable">address</span> <span class="hljs-variable">or</span> <span class="hljs-variable">nil</span> <span class="hljs-variable">pointer</span> <span class="hljs-variable">dereference</span><br><span class="hljs-built_in">Unique</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-operator">,</span> <span class="hljs-operator">*</span><span class="hljs-variable">OrderedSet</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">slices</span><span class="hljs-operator">.</span><span class="hljs-built_in">Values</span><span class="hljs-punctuation">(</span><span class="hljs-variable">s</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>第一个问题从错误信息中一目了然：我们的 <code>OrderedSet</code> 的方法（如 <code>Insert</code>）使用了指针接收器，因此满足 <code>Set[E]</code> 接口的是 <code>*OrderedSet[E]</code> 类型，而不是 <code>OrderedSet[E]</code> 类型。</p><p>然而，当我们修正这一点，传入 <code>*OrderedSet[E]</code> 后，又会遇到第二个问题。这源于我们声明变量的方式 <code>var seen S</code>。如果 <code>S</code> 是 <code>*OrderedSet[E]</code>，那么 <code>seen</code> 会被初始化为 <code>nil</code> ，后续调用其方法依然会导致 <code>panic</code></p><p>我们陷入了一个两难境地：如果类型参数是值类型，我们无法调用指针方法；如果是指针类型，我们得到的却是一个 <code>nil</code> 指针。我们需要的是一个非 <code>nil</code> 的指针。</p><p>结果是，我们需要同时处理值类型和指针类型。为此，我们必须引入一个带有新约束 <code>PtrToSet</code> 的附加类型参数 ： <code>PS</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PtrToSet is implemented by a pointer type implementing the Set[E] interface.</span><br><span class="hljs-keyword">type</span> PtrToSet[S, E any] <span class="hljs-keyword">interface</span> &#123;<br>    *S<br>    Set[E]<br>&#125;<br><br><span class="hljs-comment">// Unique removes duplicate elements from the input sequence, yielding only</span><br><span class="hljs-comment">// the first instance of any element.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unique</span>[<span class="hljs-title">E</span>, <span class="hljs-title">S</span> <span class="hljs-title">any</span>, <span class="hljs-title">PS</span> <span class="hljs-title">PtrToSet</span>[<span class="hljs-title">S</span>, <span class="hljs-title">E</span>]]<span class="hljs-params">(input iter.Seq[E])</span></span> iter.Seq[E] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(yield <span class="hljs-keyword">func</span>(E)</span></span> <span class="hljs-type">bool</span>) &#123;<br>        <span class="hljs-comment">// We convert to PS, as only that is constrained to have the methods.</span><br>        <span class="hljs-comment">// The conversion is allowed, because the type set of PS only contains *S.</span><br>        seen := PS(<span class="hljs-built_in">new</span>(S))<br>        <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> input &#123;<br>            <span class="hljs-keyword">if</span> seen.Has(v) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !yield(v) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            seen.Insert(v)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/Kp1jJRVjmYa">playground</a></p><p>这里的诀窍在于，我们通过 <code>PtrToSet</code> 接口上的额外类型参数，巧妙地将函数签名中的 <code>S</code> 和 <code>PS</code> 两个类型参数关联起来。<code>S</code> 本身不受约束，但 <code>PS</code> 必须是 <code>*S</code> 类型，并且必须实现 <code>Set[E]</code> 接口。通过这种方式，我们有效地约束了 <code>S</code> 必须拥有一组方法，且这些方法必须定义在指针接收器上。</p><p>虽然定义这样的函数需要一个额外的类型参数，但幸运的是，这并不会让调用代码变得复杂：只要这个额外的类型参数位于列表末尾，Go 的类型推断就能处理它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The third type argument is inferred to be *OrderedSet[int]</span><br>Unique[<span class="hljs-type">int</span>, OrderedSet[<span class="hljs-type">int</span>]](slices.Values(s))<br></code></pre></td></tr></table></figure><p>这是一个值得记住的通用模式，无论是在阅读他人的代码，还是在编写自己的库时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeFunction</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">PT</span> <span class="hljs-title">interface</span></span>&#123; *T; SomeMethods &#125;]()<br></code></pre></td></tr></table></figure><p>如果你有两个类型参数，其中一个被限制为指向另一个的指针，则约束将确保相关方法使用指针接收器。</p><h2 id="需要指针类型接收器约束吗"><a href="#需要指针类型接收器约束吗" class="headerlink" title="需要指针类型接收器约束吗"></a>需要指针类型接收器约束吗</h2><p>读到这里，你或许会感到有些困惑。上述模式确实相当复杂，期望每个 Go 程序员都能透彻理解其背后的机制似乎不太现实。而且，我们还不得不在 API 中引入了新的名称。这正是当初人们对 Go 添加泛型所担忧的问题之一</p><p>因此，当你发现自己陷入这类问题时，非常值得<strong>后退一步</strong>。我们通常可以通过换个角度思考问题来避免这种复杂性。在上面的例子中，我们构建了一个接受迭代器 <code>Seq[E]</code> 并返回一个去重后迭代器 <code>Seq[E]</code> 的函数。但要去重，我们必然需要将元素存入一个集合。既然无论如何都需要为结果分配存储空间，那么将结果表示为流（iterator）可能并没有带来真正的益处</p><p>如果我们重新审视这个问题，可以通过将 <code>Set[E]</code> 作为一个普通的接口值参数来传递，从而完全避免额外的类型参数和复杂的约束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InsertAll adds all unique elements from seq into set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertAll</span>[<span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(set Set[E], seq iter.Seq[E])</span></span> &#123;<br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> seq &#123;<br>        set.Insert(v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过将 <code>Set</code> 作为一个普通的接口类型参数，调用方就必须提供一个有效的、非  <code>nil</code> 的具体实现实例。这是一种非常常见且清晰的模式。如果调用方后续需要一个迭代器 <code>Seq[E]</code>，他们只需调用 <code>set.All()</code> 即可</p><p>这个方案虽然给调用者增加了一点点负担（需要预先创建 <code>set</code> 实例），但与复杂的指针接收器约束相比，它还有一个显著的优势：回想一下，我们最初的简单集合实现是 <code>map[E]bool</code>。基于它来实现 <code>Set[E]</code> 接口非常容易：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HashSet[E comparable] <span class="hljs-keyword">map</span>[E]<span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s HashSet[E])</span></span> Insert(v E)       &#123; s[v] = <span class="hljs-literal">true</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s HashSet[E])</span></span> Delete(v E)       &#123; <span class="hljs-built_in">delete</span>(s, v) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s HashSet[E])</span></span> Has(v E) <span class="hljs-type">bool</span>     &#123; <span class="hljs-keyword">return</span> s[v] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s HashSet[E])</span></span> All() iter.Seq[E] &#123; <span class="hljs-keyword">return</span> maps.Keys(s) &#125;<br></code></pre></td></tr></table></figure><p>这个 <code>HashSet</code> 的实现方法使用的都是<strong>值接收器</strong>，而非指针接收器。因此，尽管它是一个完全有效的 <code>Set[E]</code> 实现，但它并不能满足我们之前那个复杂的、要求指针接收器的 <code>Unique</code> 函数的约束。然而，它却能与我们这个更简单的 <code>InsertAll</code> 函数完美配合 </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望本文阐明了在接口类型上使用类型参数的一些模式和权衡。泛型接口是一个强大的工具，但能力越大，也意味着复杂性越高。以下是几个关键的 takeaway：</p><ol><li><strong>自我引用约束</strong>：利用泛型接口 <code>Constraint[T]</code> 约束类型 <code>T</code> 本身，实现如 <code>MethodTree[E Comparer[E]]</code> 这样的自引用约束，要求类型拥有处理同类型实例的方法。</li><li><strong>关联约束</strong>：通过泛型接口为不同的类型参数建立关联，例如约束一个类型参数必须是另一个类型参数的指针类型，并实现特定接口。</li><li><strong>抽象不同实现</strong>：使用泛型接口（如 <code>Set[E]</code>）来统一代表多种具有不同约束的具体实现（如基于 <code>cmp.Ordered</code>、比较函数或 <code>Compare</code> 方法的树）。</li><li><strong>警惕过度复杂</strong>：当你发现需要编写复杂的指针接收器约束时，不妨后退一步，思考能否通过重构 API（例如，将对象作为参数传入而非在函数内创建）来简化设计。</li></ol><p>最后，请牢记：切勿过度设计。一个灵活性稍逊但更简单、可读性更强的方案，往往是更明智的选择。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 运行时镜像时区问题</title>
    <link href="/post/go-runtime-image-timezone.html"/>
    <url>/post/go-runtime-image-timezone.html</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍 Go 程序设置时间戳计算时间时需要注意的问题，以及如何在产出的 Go 服务镜像中设置正确的文件。</p><p>在修复一个时间相关的 bug 后，部署新服务时出现了如下的错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">could not load time location: unknown time zone Asia/Shanghai<br></code></pre></td></tr></table></figure><p>系统报错显示无法加载 time zone，但是这段程序在本地运行是正常的。于是开始了排查之旅。</p><p>为了方便说明，下面是一个简单的程序，获取当前的时间，并且转化为指定时区的时间并输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br><br>loc, err := time.LoadLocation(<span class="hljs-string">&quot;UTC&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err.Error())<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Println(t.String())<br>fmt.Println(t.In(loc).String())<br>  <br>  <span class="hljs-comment">// Output:</span><br>  <span class="hljs-comment">// 2021-09-27 14:00:42.181169 +0800 CST m=+0.000100571</span><br>  <span class="hljs-comment">// 2021-09-27 06:00:42.181169 +0000 UTC</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在没有设置时区的时候，输出了当前系统时区的时间，而在设置 Location 之后，就将时间转化为了对应时区的时间。</p><p>但是在这段程序在打包成镜像后，出现了相同的错误。</p><p>原因在于 <code>time.LoadLocation</code> 这个函数。在用户传入合法的时区后， 函数会从下列文件中查找 timezone 信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Many systems use /usr/share/zoneinfo, Solaris 2 has</span><br><span class="hljs-comment">// /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ.</span><br><span class="hljs-keyword">var</span> zoneSources = []<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;/usr/share/zoneinfo/&quot;</span>,<br><span class="hljs-string">&quot;/usr/share/lib/zoneinfo/&quot;</span>,<br><span class="hljs-string">&quot;/usr/lib/locale/TZ/&quot;</span>,<br>runtime.GOROOT() + <span class="hljs-string">&quot;/lib/time/zoneinfo.zip&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/54079dfd7fff6c61d41c4832c074e8231f235fc3/src/time/zoneinfo_unix.go#L20">源文件</a></p><p>正常情况下，在本地的开发机上运行是没有问题的，但是如果最终的镜像的基础镜像是 alpine 或者是 busybox，那么就会出现问题，因为在这两个镜像为了体积原因是不会包含这些文件的。</p><p>在明确问题产生的原因后就可以修复了，对于多步构建的镜像来说，只需从上游镜像中拷贝一份时区文件即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Builder</span><br><span class="hljs-string">FROM</span> <span class="hljs-string">golang:latest</span> <span class="hljs-string">AS</span> <span class="hljs-string">builder</span><br><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/server</span><br><br><span class="hljs-string">COPY</span> <span class="hljs-string">.</span> <span class="hljs-string">.</span><br><br><span class="hljs-string">ENV</span> <span class="hljs-string">GOPROXY=&quot;https://goproxy.cn&quot;</span><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">go</span> <span class="hljs-string">build</span><br><br><span class="hljs-comment"># Runtime</span><br><span class="hljs-string">FROM</span> <span class="hljs-string">busybox:glibc</span><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/server</span><br><br><span class="hljs-string">COPY</span> <span class="hljs-string">--from=builder</span> <span class="hljs-string">server</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># Copy zoneinfo from builder</span><br><span class="hljs-string">COPY</span> <span class="hljs-string">--from=builder</span> <span class="hljs-string">/usr/share/zoneinfo/</span> <span class="hljs-string">/usr/share/zoneinfo/</span> <br><br><span class="hljs-string">ENTRYPOINT</span> [<span class="hljs-string">&quot;server&quot;</span>]<br><br></code></pre></td></tr></table></figure><p>这样修改之后就可以正常部署了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 字符集和比较规则</title>
    <link href="/post/mysql-character-set.html"/>
    <url>/post/mysql-character-set.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于 MySQL 8.0.42，默认字符集为 utf8mb4</p></blockquote><h2 id="字符集和比较规则是什么"><a href="#字符集和比较规则是什么" class="headerlink" title="字符集和比较规则是什么"></a>字符集和比较规则是什么</h2><p>字符集是用于定义字符如何存储和展示的编码规则集合。它规定了数据库中可以使用哪些字符以及这些字符在计算机中如何表示。我们可以通过一个简单的例子来理解字符集：假设有一个包含<br>A、B、a、b 四个字符的字母表,我们为每个字母分配一个编码值:A=0、B=1、a=2、b=3。这里 A 是符号,0 是编码,所有字母与编码的对应关系共同构成了一个字符集。</p><p>常见的字符集包括:</p><ul><li>ASCII：一种基础字符集,仅包含128个字符,主要是英文字母、数字和常用符号</li><li>utf8mb4：支持完整的Unicode字符集(包含emoji表情),是MySQL 8.0的默认字符集</li><li>latin1：支持西欧语言的字符集</li></ul><p>字符集对数据库系统有着重要影响,主要体现在以下方面:</p><ol><li>数据存储空间的使用</li><li>数据传输时的编码转换</li><li>数据的可读性和跨系统兼容性</li></ol><p>假设我们需要比较两个字符串 A 和 B。一种方法是按照它们在字符集中的编码值进行比较，如果 A 的编码是 0，B 的编码是 1，那么因为 0<br>小于 1，所以 A 小于 B。这种字符编码的比较规则就是比较规则。</p><p>比较规则定义了如何比较字符集中的字符。最基础的比较规则是二进制比较，即直接比较字符的编码值大小。</p><p>但是如果我们想说小写字母和大写字符是等价的呢，那么就需要两条规则：a)大写字母和小写字母是相等的；b）然后比较它们的编码。这被称之为大小写不敏感的比较规则， 他比二进制比较要稍微复杂点。</p><h2 id="MySQL-中的字符集和比较规则"><a href="#MySQL-中的字符集和比较规则" class="headerlink" title="MySQL 中的字符集和比较规则"></a>MySQL 中的字符集和比较规则</h2><p>mysql 支持多种的字符集和比较规则，可以分别使用 <code>SHOW CHARACTER SET [LIKE 匹配模式]</code> 以及 <code>SHOW COLLATION [LIKE 匹配模式]</code> 语句来查看。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW CHARACTER SET LIKE &#x27;utf%&#x27;;<br>+---------+------------------+--------------------+--------+<br>|<span class="hljs-string"> Charset </span>|<span class="hljs-string"> Description      </span>|<span class="hljs-string"> Default collation  </span>|<span class="hljs-string"> Maxlen </span>|<br>+---------+------------------+--------------------+--------+<br>|<span class="hljs-string"> utf16   </span>|<span class="hljs-string"> UTF-16 Unicode   </span>|<span class="hljs-string"> utf16_general_ci   </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf16le </span>|<span class="hljs-string"> UTF-16LE Unicode </span>|<span class="hljs-string"> utf16le_general_ci </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf32   </span>|<span class="hljs-string"> UTF-32 Unicode   </span>|<span class="hljs-string"> utf32_general_ci   </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf8mb3 </span>|<span class="hljs-string"> UTF-8 Unicode    </span>|<span class="hljs-string"> utf8mb3_general_ci </span>|<span class="hljs-string">      3 </span>|<br>|<span class="hljs-string"> utf8mb4 </span>|<span class="hljs-string"> UTF-8 Unicode    </span>|<span class="hljs-string"> utf8mb4_0900_ai_ci </span>|<span class="hljs-string">      4 </span>|<br>+---------+------------------+--------------------+--------+<br></code></pre></td></tr></table></figure><p>每个字符集都至少包含一个比较规则，大多数字符集都拥有多个比较规则。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW COLLATION LIKE &#x27;utf8mb4_0900%&#x27;;<br>+--------------------+---------+-----+---------+----------+---------+---------------+<br>|<span class="hljs-string"> Collation          </span>|<span class="hljs-string"> Charset </span>|<span class="hljs-string"> Id  </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Compiled </span>|<span class="hljs-string"> Sortlen </span>|<span class="hljs-string"> Pad_attribute </span>|<br>+--------------------+---------+-----+---------+----------+---------+---------------+<br>|<span class="hljs-string"> utf8mb4_0900_ai_ci </span>|<span class="hljs-string"> utf8mb4 </span>|<span class="hljs-string"> 255 </span>|<span class="hljs-string"> Yes     </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       0 </span>|<span class="hljs-string"> NO PAD        </span>|<br>|<span class="hljs-string"> utf8mb4_0900_as_ci </span>|<span class="hljs-string"> utf8mb4 </span>|<span class="hljs-string"> 305 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       0 </span>|<span class="hljs-string"> NO PAD        </span>|<br>|<span class="hljs-string"> utf8mb4_0900_as_cs </span>|<span class="hljs-string"> utf8mb4 </span>|<span class="hljs-string"> 278 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       0 </span>|<span class="hljs-string"> NO PAD        </span>|<br>|<span class="hljs-string"> utf8mb4_0900_bin   </span>|<span class="hljs-string"> utf8mb4 </span>|<span class="hljs-string"> 309 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<span class="hljs-string"> NO PAD        </span>|<br>+--------------------+---------+-----+---------+----------+---------+---------------+<br></code></pre></td></tr></table></figure><p>比较规则通常具备以下的特征：</p><ul><li>两个不同的字符集不会拥有相同的比较规则</li><li>每个字符集都有着默认的比较规则</li><li>比较规则的名称以字符集名称开头，后面跟着一个或多个的表示排序特征的后缀</li></ul><p>比较规则命名规则：</p><ul><li>以字符集名称开头，例如 utf8mb4_</li><li>后面跟着版本号（可选），如 0900_</li><li>接着是一个或多个后缀来表示特定的排序行为：<ul><li>_ai：accent insensitive，不区分重音</li><li>_as：accent sensitive，区分重音</li><li>_ci：case insensitive，不区分大小写</li><li>_cs：case sensitive，区分大小写</li><li>_bin：binary，二进制比较</li></ul></li><li>例如：utf8mb4_0900_ai_ci 表示：<ul><li>utf8mb4 字符集</li><li>0900 版本</li><li>ai 不区分重音</li><li>ci 不区分大小写</li></ul></li></ul><h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><ul><li>如果创建或者修改列时没有显式指定字符集和比较规则，则默认使用表的字符集和比较规则</li><li>如果创建表时没有显式指定字符集和比较规则，则默认使用数据库的字符集和比较规则</li><li>如果创建数据库时没有显示指定字符集和比较规则，则默认使用服务器的字符集和比较规则</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 数据复制</title>
    <link href="/post/mysql-replication.html"/>
    <url>/post/mysql-replication.html</url>
    
    <content type="html"><![CDATA[<p>MySQL数据复制（Replication）是一个将数据从一个MySQL数据库服务器（称为主服务器或源服务器）复制到一个或多个MySQL数据库服务器（称为从服务器或副本服务器）的过程。</p><h2 id="复制的优势"><a href="#复制的优势" class="headerlink" title="复制的优势"></a>复制的优势</h2><ol><li>可扩展性：通过将读操作分散到多个从服务器，提高系统性能</li><li>数据安全：通过复制提供数据备份</li><li>分析：可在从服务器上执行数据分析，不影响主服务器性能</li><li>长距离数据分发：可将数据复制到远程站点</li></ol><h2 id="复制方法与类型"><a href="#复制方法与类型" class="headerlink" title="复制方法与类型"></a>复制方法与类型</h2><p>MySQL 8.0 支持多种的复制方法</p><ul><li>传统方法：基于二进制日志(binlog)的复制，主服务器记录所有数据变更事件，副本服务器通过追踪日志文件位置来同步这些事件</li><li>基于 GTID（全局事务标识符）：每个事务都有全局唯一的标识符，使复制配置更简单可靠，无需手动管理日志文件位置</li></ul><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><ul><li>默认的复制类型</li><li>主服务器执行事务而不等待从服务器响应</li><li>从服务器可能落后于主服务器</li></ul><h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><ul><li>主服务器等待至少一个从服务器确认接收事务</li><li>提供更好的数据一致性保证</li><li>可能影响性能</li></ul><h3 id="延迟复制"><a href="#延迟复制" class="headerlink" title="延迟复制"></a>延迟复制</h3><ul><li>从服务器有意延迟复制主服务器的更改</li><li>可配置延迟时间（如一小时或更长）</li><li>用途：<ul><li>防止人为操作错误（如误删数据）</li><li>在灾难恢复时回滚到特定时间点</li><li>测试环境中验证更改影响</li></ul></li><li>通过 CHANGE MASTER TO MASTER_DELAY 命令配置延迟时间</li></ul><h2 id="复制格式"><a href="#复制格式" class="headerlink" title="复制格式"></a>复制格式</h2><p>被写入二进制日志的事件，会从主服务器读取，然后在副本服务器进行处理。根据事件的类型，事件会以不同的格式记录在 binlog 中。</p><ul><li>SBR（Statement Based Replication）：基于SQL语句的二进制记录,主服务器将 SQL 语句写入到 binlog 中</li><li>RBR（Row Based Replication）：基于行的复制,主服务器将事件写入到 binlog 中，用以指示各个表的行如何更改数据</li><li>MBR (Mixed Based Replication)：混合复制模式,默认情况下使用 SBR，基于某些特定的语句以及正在使用的存储引擎，使用 RBR。</li></ul><p><code>binlog_format</code> 系统变量控制着 MySQL 服务器的二进制日志记录格式。你可以在会话(session)或全局(global)范围内设置此变量，以决定使用<br>SBR、RBR 或 MBR 复制模式。</p><p>变量设置规则与其他MySQL服务器系统变量相同:</p><ul><li><p>会话级别设置:</p><ul><li>仅对当前会话有效</li><li>会话结束后失效</li><li>不影响其他会话</li></ul></li><li><p>全局级别设置:</p><ul><li>对所有新连接的客户端生效</li><li>不影响当前已连接的会话</li><li>需要在配置文件中修改才能永久生效</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更强力的 Go 运行时 trace</title>
    <link href="/post/go-execution-traces.html"/>
    <url>/post/go-execution-traces.html</url>
    
    <content type="html"><![CDATA[<p>本文是对 Go 官方博客 <a href="https://go.dev/blog/execution-traces-2024">More powerful Go execution traces</a> 的翻译。</p><p><a href="https://go.dev/pkg/runtime/trace">runtime/trace </a> 包包含了一个强大的工具, 用于理解和排查Go程序的问题。该功能允许生成在某段时间内每个goroutine 执行的 trace 记录。通过 <code>go tool trace</code> 命令(或优秀的开源工具 <a href="https://gotraceui.dev/">gotraceui</a> ), 就可以可视化并探索这些 trace 记录中的数据。</p><p>trace 记录的神奇之处在于, 它可以轻松地揭示在其他情况下很难发现的程序行为。例如, 并发瓶颈导致许多goroutine 在同一个通道上阻塞, 这在CPU性能分析中可能很难看出来, 因为没有可执行代码被采样。但在执行追踪中, 执行的缺失将非常清晰地显示出来, 而且被阻塞的 goroutine 的堆栈跟踪也会快速指出问题的原因。</p><p><img src="https://go.dev/blog/execution-traces-2024/gotooltrace.png"></p><p>Go开发者甚至可以在自己的程序中植入<a href="https://go.dev/pkg/runtime/trace#Task">tasks</a>、<a href="https://go.dev/pkg/runtime/trace#WithRegion">regions</a> 和 <a href="https://go.dev/pkg/runtime/trace#Log">logs</a>, 用于将他们关注的高级问题与低级执行细节相关联。</p><h2 id="问题是"><a href="#问题是" class="headerlink" title="问题是:"></a>问题是:</h2><p>不幸的是, 执行追踪中丰富的信息往往难以获取。以下四大问题一直阻碍了 trace 的使用:</p><ul><li> trace 开销很高。</li><li> trace 记录缩放能力差,可能会变得太大无法分析。</li><li>通常不清楚应该在何时开始 trace 以捕获特定的异常行为。</li><li>由于缺乏解析和解释执行 trace 的公共包,只有最勇敢的Go程序员才能以编程方式分析追踪。</li></ul><p>如果你在过去几年使用过 trace ,可能会对其中一个或多个问题感到沮丧。但我们很高兴地告诉大家,在最近两个Go版本中,我们在上述四个领域都取得了重大进展。</p><h2 id="低开销追踪"><a href="#低开销追踪" class="headerlink" title="低开销追踪"></a>低开销追踪</h2><p>在 Go 1.21之前, 对许多应用程序而言, trace 的运行时开销在 10-20% 的CPU之间, 这限制了 trace 只能在特定情况下使用, 而无法像CPU profiling那样持续使用。事实证明, trace 的大部分成本归结于堆栈回溯。运行时产生的许多事件都附带了堆栈跟踪,这对于实际识别 goroutine 在关键执行时刻的操作是非常有价值的。</p><p>得益于Felix Geisendörfer 和 Nick Ripley 对优化堆栈回溯效率所做的工作, 执行 trace 的运行时CPU开销大幅降低,对许多应用程序而言下降到 1-2%。你可以在 <a href="https://blog.felixge.de/reducing-gos-execution-tracer-overhead-with-frame-pointer-unwinding/">Felix 关于这个主题的精彩博文</a>中阅读更多相关工作的内容。</p><h2 id="可扩展的追踪记录"><a href="#可扩展的追踪记录" class="headerlink" title="可扩展的追踪记录"></a>可扩展的追踪记录</h2><p>trace 格式及其事件的设计旨在提高产生效率, 但需要工具来解析和维护整个 trace 记录的状态。分析数百MB的追踪记录可能需要数GB的内存!</p><p>不幸的是, 这个问题是 trace 生成方式的基本问题。为了保持运行时开销低,所有事件都被写入类似线程本地缓冲区。但这意味着事件出现的顺序与真实顺序不一致,分析 trace 的工具必须弄清楚实际发生的情况。</p><p>在保持低开销的同时使 trace 记录可扩展的关键是, 偶尔分割正在生成的 trace 记录。每个分割点的行为有点像同时禁用和重新启用 trace 。到目前为止的所有 trace 数据将代表一个完整和自包含的 trace ,而新的 trace 数据将无缝地从中断处继续。</p><p>你可能已经想到, 解决这个问题需要<a href="https://go.dev/issue/60773">重新思考和重写运行时中 trace 实现</a>的很多基础部分。我们很高兴地说,这项工作已在 Go 1.22 中落地, 现在可以普遍使用了。重写带来了许多<a href="https://go.dev/doc/go1.22#runtime/trace">优秀的改进</a>, 包括对<code>go tool trace</code>命令的一些改进。如果你有兴趣,所有细节都在<a href="https://github.com/golang/proposal/blob/master/design/60773-execution-tracer-overhaul.md">设计文档</a>中。</p><p>(注: <code>go tool trace</code> 仍会将整个 trace 记录加载到内存中, 但现在可以为 Go 1.22+ 程序生成的 trace 记录移除此限制。)</p><h2 id="飞行记录"><a href="#飞行记录" class="headerlink" title="飞行记录"></a>飞行记录</h2><p>假设你在开发一个Web 服务, 某个RPC调用花费了很长时间。你无法在意识到 RPC 已经运行一段时间时开始 trace,因为导致请求变慢的根本原因已经发生,并且没有被记录下来。</p><p>有一种称为飞行记录(flight recording)的技术可以帮助解决这个问题, 你可能已经在其他编程环境中熟悉它了。飞行记录的思路是持续进行 trace, 并始终保留最近的 trace 数据, 以防万一。然后, 一旦发生有趣的事情,程序只需将它所拥有的数据写出即可!</p><p>在追踪记录可以分割之前, 这几乎是行不通的。但由于低开销使持续 trace变得可行,并且运行时现在可以在任何需要时分割 trace,因此实现飞行记录是直接了当的。</p><p>因此,我们很高兴地宣布, <a href="https://go.dev/pkg/golang.org/x/exp/trace#FlightRecorder">golang.org/x/exp/trace</a> 包中提供了一个飞行记录器实验。</p><p>请尝试一下! 下面是一个示例,它设置飞行记录器来捕获一个耗时很长的HTTP请求,可以让你入门。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Set up the flight recorder.</span><br>fr := trace.NewFlightRecorder()<br>fr.Start()<br><br><span class="hljs-comment">// Set up and run an HTTP server.</span><br><span class="hljs-keyword">var</span> once sync.Once<br>http.HandleFunc(<span class="hljs-string">&quot;/my-endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    start := time.Now()<br><br>    <span class="hljs-comment">// Do the work...</span><br>    doWork(w, r)<br><br>    <span class="hljs-comment">// We saw a long request. Take a snapshot!</span><br>    <span class="hljs-keyword">if</span> time.Since(start) &gt; <span class="hljs-number">300</span>*time.Millisecond &#123;<br>        <span class="hljs-comment">// Do it only once for simplicity, but you can take more than one.</span><br>        once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">// Grab the snapshot.</span><br>            <span class="hljs-keyword">var</span> b bytes.Buffer<br>            _, err = fr.WriteTo(&amp;b)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Print(err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// Write it to a file.</span><br>            <span class="hljs-keyword">if</span> err := os.WriteFile(<span class="hljs-string">&quot;trace.out&quot;</span>, b.Bytes(), <span class="hljs-number">0</span>o755); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Print(err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;)<br><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br></code></pre></td></tr></table></figure><p>如果你有任何正面或负面的反馈, 请在建议的 <a href="https://go.dev/issue/62627">issue</a> 中分享!</p><h2 id="追踪读取器API"><a href="#追踪读取器API" class="headerlink" title="追踪读取器API"></a>追踪读取器API</h2><p>伴随着重写 trace 实现的工作, 我们努力清理了其他 trace 内部机制,比如 <code>go tool trace</code>。这催生了一次尝试,旨在创建一个足够好的 trace 读取器API,可以共享并使 trace 更易访问。</p><p>就像飞行记录器一样,我们很高兴地宣布,我们也有一个实验性的trace  读取器API, 我们希望能够分享。它与飞行记录器位于同一个包中,即 <a href="https://go.dev/pkg/golang.org/x/exp/trace#FlightRecorder">golang.org/x/exp/trace</a> 。</p><p>我们认为它足够好,可以在其基础上构建东西,所以请尝试一下! 下面是一个示例,它测量了goroutine阻塞事件中由于等待网络而阻塞的比例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Start reading from STDIN.</span><br>r, err := trace.NewReader(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> blocked <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> blockedOnNetwork <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// Read the event.</span><br>    ev, err := r.ReadEvent()<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// Process it.</span><br>    <span class="hljs-keyword">if</span> ev.Kind() == trace.EventStateTransition &#123;<br>        st := ev.StateTransition()<br>        <span class="hljs-keyword">if</span> st.Resource.Kind == trace.ResourceGoroutine &#123;<br>            id := st.Resource.Goroutine()<br>            from, to := st.GoroutineTransition()<br><br>            <span class="hljs-comment">// Look for goroutines blocking, and count them.</span><br>            <span class="hljs-keyword">if</span> from.Executing() &amp;&amp; to == trace.GoWaiting &#123;<br>                blocked++<br>                <span class="hljs-keyword">if</span> strings.Contains(st.Reason, <span class="hljs-string">&quot;network&quot;</span>) &#123;<br>                    blockedOnNetwork++<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Print what we found.</span><br>p := <span class="hljs-number">100</span> * <span class="hljs-type">float64</span>(blockedOnNetwork) / <span class="hljs-type">float64</span>(blocked)<br>fmt.Printf(<span class="hljs-string">&quot;%2.3f%% instances of goroutines blocking were to block on the network\n&quot;</span>, p)<br></code></pre></td></tr></table></figure><h2 id="非常感谢"><a href="#非常感谢" class="headerlink" title="非常感谢!"></a>非常感谢!</h2><p>这项工作能够完成,在很大程度上要归功于一年多前成立的<a href="https://go.dev/issue/57175">诊断工作组</a>的帮助,该工作组是 Go 社区各利益相关方之间的合作,并向公众开放。</p><p>我们想借此机会感谢过去一年里定期参加诊断会议的社区成员:Felix Geisendörfer、Nick Ripley、Rhys Hiltner、Dominik Honnef、Bryan Boreham和thepudds。</p><p>你们进行的讨论、提供的反馈和付出的努力,是我们能够取得今天成就的关键。再次感谢!</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go JSON patch</title>
    <link href="/post/go-json-patch.html"/>
    <url>/post/go-json-patch.html</url>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我会向你介绍 json patch，并展示如何在 Go 中使用 json patch 来完成资源的更新操作。</p><h2 id="什么是-JSON-Patches"><a href="#什么是-JSON-Patches" class="headerlink" title="什么是 JSON Patches?"></a>什么是 JSON Patches?</h2><p>JSON Patch 是一种格式化的方式,用于对 JSON 文件进行部分修改。它定义了一组操作符,可以用来描述如何修改一个 JSON 值。这种方式非常适合在客户端和服务器之间传递部分修改,而不需要传输整个 JSON 文档,从而节省了带宽。</p><p>JSON Patch 的规范由 RFC6902 定义,它描述了如下几种操作符:</p><ul><li><strong>add</strong>: 在指定位置添加一个值</li><li><strong>remove</strong>: 移除指定位置的值</li><li><strong>replace</strong>: 用新值替换指定位置的值</li><li><strong>move</strong>: 将指定位置的值移动到另一个位置</li><li><strong>copy</strong>: 将指定位置的值复制到另一个位置</li><li><strong>test</strong>: 测试指定位置的值是否与给定值相等</li></ul><p>每个操作符都包含一个路径字符串,用于定位要修改的 JSON 值。路径语法类似于 XPath,使用 <code>/</code> 来分隔各个层级,并使用 0、1、2 等数字来指定数组元素的位置。</p><h2 id="为什么需要-JSON-Patch"><a href="#为什么需要-JSON-Patch" class="headerlink" title="为什么需要 JSON Patch?"></a>为什么需要 JSON Patch?</h2><p>在现代 Web 应用中,客户端和服务器之间通常需要频繁地交换 JSON 数据。如果每次都需要传输整个 JSON 对象,会造成不必要的带宽浪费,降低应用的响应速度。</p><p>JSON Patch 的出现就是为了解决这个问题。它允许我们只传输 JSON 对象的变化部分,而不是整个对象。这不仅可以减少网络传输的数据量,还可以降低服务器的计算负载,因为服务器只需要对变化的部分进行处理,而不需要重新构建整个 JSON 对象。</p><p>下面是一些 JSON Patch 的典型应用场景:</p><ol><li><strong>实时协作编辑</strong></li></ol><p>在协作编辑应用中,多个用户同时编辑同一份文档。每次有用户进行修改时,服务器只需要将该修改以 JSON Patch 的形式广播给其他用户,而不需要传输整个文档。这可以大大减少网络流量,提高实时协作的响应速度。</p><ol start="2"><li><strong>数据同步</strong></li></ol><p>在分布式系统中,不同节点之间需要频繁地同步数据。使用 JSON Patch,节点之间只需要交换数据的变化部分,而不是整个数据快照,这可以减少大量的网络开销。</p><ol start="3"><li><strong>局部 UI 更新</strong></li></ol><p>在现代 Web 应用中,UI 通常由 JSON 数据驱动。当数据发生变化时,我们只需要用 JSON Patch 描述变化部分,然后在客户端应用这些变化,就可以高效地更新 UI,而不需要重新渲染整个视图。</p><ol start="4"><li><strong>版本控制</strong></li></ol><p>JSON Patch 可以用于记录 JSON 数据的变更历史,从而实现类似于文件版本控制系统的功能。每次变更都可以用一个 JSON Patch 表示,应用所有的 Patch 就可以重建数据的任何历史版本。</p><p>除了之前提到的场景之外,JSON Patch 还有一个非常重要的使用场景,那就是作为 HTTP PATCH 方法的请求体,用于对指定的资源进行部分修改。</p><p>HTTP 协议中定义了多种方法,例如 GET、POST、PUT、DELETE 等。其中 PATCH 方法是用于对已存在的资源进行部分修改。与 PUT 方法不同,PUT 是完整替换资源,而 PATCH 只更新资源的一部分字段。</p><p>PATCH 方法的请求体可以使用多种格式, JSON Patch 就是其中一种流行的格式。它提供了一种标准的、结构化的方式来表示对 JSON 资源的修改操作, 非常适合作为 PATCH 请求的载体。</p><h2 id="在-Go-中实现-JSON-Patches"><a href="#在-Go-中实现-JSON-Patches" class="headerlink" title="在 Go 中实现 JSON Patches"></a>在 Go 中实现 JSON Patches</h2><p>Go 标准库中没有直接实现 JSON Patch 的功能,但是我们可以使用第三方库来实现。一个流行的 JSON Patch 库是 <code>evanphx/json-patch</code>。</p><p>首先,我们需要添加依赖，并导入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get -u github.com/evanphx/json-patch/v5<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> jsonpatch <span class="hljs-string">&quot;github.com/evanphx/json-patch/v5&quot;</span><br><br></code></pre></td></tr></table></figure><p>然后,我们可以定义一个 JSON 文档:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">originalJSON := []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;</span><br><span class="hljs-string">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="hljs-string">  &quot;age&quot;: 30,</span><br><span class="hljs-string">  &quot;skills&quot;: [&quot;Go&quot;, &quot;Java&quot;]</span><br><span class="hljs-string">&#125;`</span>)<br><br></code></pre></td></tr></table></figure><p>接下来,我们创建一个 JSON Patch 文档,描述要对原始 JSON 文档进行的修改操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">patchJSON := []<span class="hljs-type">byte</span>(<span class="hljs-string">`[</span><br><span class="hljs-string">  &#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/name&quot;, &quot;value&quot;: &quot;Jane&quot;&#125;,</span><br><span class="hljs-string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/age&quot;&#125;,</span><br><span class="hljs-string">  &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/skills/2&quot;, &quot;value&quot;: &quot;Python&quot;&#125;</span><br><span class="hljs-string">]`</span>)<br><br></code></pre></td></tr></table></figure><p>这个 Patch 将会执行以下操作:</p><ol><li>将 <code>name</code> 字段的值替换为 “Jane”</li><li>删除 <code>age</code> 字段</li><li>在 <code>skills</code> 数组中添加一个新的元素 “Python”</li></ol><p>最后,我们应用这个 Patch 并打印修改后的 JSON 文档:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">patch, err := jsonpatch.DecodePatch(patchJSON)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>modified, err := patch.Apply(original)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Modified document: %s\n&quot;</span>, modified)<br><br></code></pre></td></tr></table></figure><p>输出结果将是:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;skills&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;Go&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;Java&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;Python&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>就是这样!通过使用 <code>evanphx/json-patch</code> 库,我们可以在 Go 中方便地实现 RFC6902 JSON Patches 功能。这个库还提供了其他一些高级特性,如应用多个 Patch、从文件中读取 Patch 等。有了这个功能,我们就可以在客户端和服务器之间高效地传递部分 JSON 修改,而不需要传输整个文档。</p><p>希望这篇博客对你有所帮助!如果你有任何疑问或反馈,欢迎随时告诉我。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 切片的使用和内部实现</title>
    <link href="/post/go-slice-usage-and-internal.html"/>
    <url>/post/go-slice-usage-and-internal.html</url>
    
    <content type="html"><![CDATA[<p>本文是翻译自 Go 官方的博客 <a href="https://go.dev/blog/slices-intro#">Go Slices: usage and internals</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 的切片类型提供了一种方便高效的方法来处理类型化数据序列。切片类似于其他语言中的数组，但具有一些不寻常的属性。本文将介绍什么是切片以及它们的使用方式</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>切片类型是建立在 Go 的数组类型之上的抽象类型，因此要理解切片，我们必须首先了解数组。</p><p>数组类型定义指定长度和元素类型。例如，该类型 <code>[4]int</code> 表示一个由四个整数组成的数组。数组的大小是固定的; 它的长度是其类型的一部分（ <code>[4]int</code> 和 <code>[5]int</code> 是两个不同的、不兼容的类型）。数组可以按通常的方式进行索引，因此表达式 <code>s[n]</code> 从零开始访问第 n 个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>i := a[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// i == 1</span><br></code></pre></td></tr></table></figure><p>数组不需要显式初始化; 数组的零值是一个现成的, 可以直接使用的数组，其中元素的值为元素类型本身的零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a[2] == 0, int 类型的零值</span><br></code></pre></td></tr></table></figure><p><code>[4]int</code> 在内存中的表现形式为, 按照顺序排列的四个 int 值</p><p><img src="https://go.dev/blog/slices-intro/slice-array.png"></p><p>Go 语言中的数组是值类型。这意味着数组变量本身代表整个数组，而不是指向数组第一个元素的指针 (就像 C 语言中的数组一样)。因此，当你赋值或传递数组的值时，会复制它的所有内容。(如果你想避免复制，可以传递数组的指针，但这样一来你传递的不是数组本身，而是指向数组的指针。) 我们也可以将数组理解为一种特殊的结构体，只不过它的成员不是通过名称访问，而是通过索引访问。它本质上是一个固定大小的复合值。</p><p>数组字面量可以使用以下方式指定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := [<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Penn&quot;</span>, <span class="hljs-string">&quot;Teller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>或者, 你可以让编译器为你计算数组元素的数量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Penn&quot;</span>, <span class="hljs-string">&quot;Teller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面两个例子中, b 的类型都是 <code>[2]string</code></p><p>Go 语言中的数组是值类型。这意味着数组变量本身代表整个数组，而不是指向数组第一个元素的指针 (就像 C 语言中的数组一样)。因此，当你赋值或传递数组的值时，会复制它的所有内容。(如果你想避免复制，可以传递数组的指针，但这样一来你传递的不是数组本身，而是指向数组的指针。) 我们也可以将数组理解为一种特殊的结构体，只不过它的成员不是通过名称访问，而是通过索引访问。它本质上是一个固定大小的复合值。</p><p>数组字面量可以使用以下方式指定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := [<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Penn&quot;</span>, <span class="hljs-string">&quot;Teller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>或者, 你可以让编译器为你计算数组元素的数量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Penn&quot;</span>, <span class="hljs-string">&quot;Teller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面两个例子中, b 的类型都是 [2]string</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>数组在 Go 语言中占有一席之地，但它们有点缺乏灵活性，因此在 Go 代码中并不常见。而切片则无处不在，它们以数组为基础，提供了强大的功能和便利性。</p><p>切片的类型指定为 <code>[]T</code>，其中 <code>T</code> 表示切片元素的类型。与数组类型不同，切片类型没有指定长度。</p><p>声明切片字面量的方式与声明数组字面量的方式类似，只是省略了元素个数的指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">letters := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>切片可以通过调用内置的 make 函数来创建, 函数签名是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)</span></span> []T<br></code></pre></td></tr></table></figure><p>T 表示被创建切片的元素类型.</p><p>函数 <code>make</code> 接受类型、长度和可选容量。调用时，<code>make</code> 会分配一个数组并返回指向该数组的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">byte</span><br>s = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">// s == []byte&#123;0, 0, 0, 0, 0&#125;</span><br></code></pre></td></tr></table></figure><p>如果省略 capacity 参数，则默认为指定的长度。下面是相同代码的更简洁版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>可以使用内置的 <code>len</code> 和 <code>cap</code> 函数检查切片的长度和容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">len</span>(s) == <span class="hljs-number">5</span><br><span class="hljs-built_in">cap</span>(s) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>接下来两节, 我们将讨论长度和容量之间的关系。</p><p>空切片的零值为 nil。len 和 cap 函数对空切片都将返回 0。</p><p>还可以通过“切片”现有切片或数组来形成切片。切片通过指定一个由冒号分隔的两个索引的左闭右开区间来完成。例如，表达式 b[1:4] 创建了一个包含 b 中 1 到 3 的元素的切片（结果切片的索引将是 0 到 2）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">b := []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;<br><span class="hljs-comment">// b[1:4] == []byte&#123;&#x27;o&#x27;, &#x27;l&#x27;, &#x27;a&#x27;&#125;, 和 b 共享低层存储</span><br></code></pre></td></tr></table></figure><p>这也是在给定数组的情况下创建切片的语法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x := [<span class="hljs-number">3</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Лайка&quot;</span>, <span class="hljs-string">&quot;Белка&quot;</span>, <span class="hljs-string">&quot;Стрелка&quot;</span>&#125;<br>s := x[:] <span class="hljs-comment">// 一个指向 x 的存储空间的切片</span><br></code></pre></td></tr></table></figure><h2 id="切片内部"><a href="#切片内部" class="headerlink" title="切片内部"></a>切片内部</h2><p>切片是数组段的描述符. 它由指向数组的指针, 段的长度和容量(段的最大长度) 组成.</p><p>!<a href="https://go.dev/blog/slices-intro/slice-struct.png">https://go.dev/blog/slices-intro/slice-struct.png</a></p><p>我们通过 make([]byte, 5) 创建的变量 s, 它的结构像下面这样:</p><p>!<a href="https://go.dev/blog/slices-intro/slice-1.png">https://go.dev/blog/slices-intro/slice-1.png</a></p><p>长度是切片引用的元素数。容量是基础数组中的元素数（从切片指针引用的元素开始）。长度和容量之间的区别将在我们接下来的几个示例中明确。</p><p>当我们对 s 做切片操作时, 观察切片数据结构的变化以及和低层数组的关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s = s[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><img src="https://go.dev/blog/slices-intro/slice-2.png"></p><p>切片操作不会拷贝原有切片的数据. 它会创建一个指向原始数组的新切片值。这使得切片操作与操作数组索引一样高效。因此，修改重新切片的元素（而不是切片本身）会修改原始切片的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">d := []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br>e := d[<span class="hljs-number">2</span>:]<br><span class="hljs-comment">// e == []byte&#123;&#x27;a&#x27;, &#x27;d&#x27;&#125;</span><br>e[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;m&#x27;</span><br><span class="hljs-comment">// e == []byte&#123;&#x27;a&#x27;, &#x27;m&#x27;&#125;</span><br><span class="hljs-comment">// d == []byte&#123;&#x27;r&#x27;, &#x27;o&#x27;, &#x27;a&#x27;, &#x27;m&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>早些时候， <code>s</code> 我们切成比其容量短的长度。我们可以通过再次切片来增加它的容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s = s[:<span class="hljs-built_in">cap</span>(s)]<br></code></pre></td></tr></table></figure><p><img src="https://go.dev/blog/slices-intro/slice-3.png"></p><p>切片无法超出其容量进行扩容。尝试这样做会引发运行时错误，就像访问超出切片或数组边界时的错误一样。 类似地，切片也不能向下重新切片到负索引来访问数组中更早的元素。</p><h2 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h2><p>为了增加切片的容量，需要创建一个新的更大容量的切片，然后将原始切片的内容复制到新切片中。这种技术与其他语言中动态数组的实现方式类似。以下示例通过创建一个新切片 t，将 s 的内容复制到 t 中，然后将切片值 t 赋值给 s，从而将 s 的容量翻倍：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(s), (<span class="hljs-built_in">cap</span>(s)+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>) <span class="hljs-comment">// +1 in case cap(s) == 0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>        t[i] = s[i]<br>&#125;<br>s = t<br></code></pre></td></tr></table></figure><p>这个常见操作的循环部分通过内置的 copy 函数变得更加容易。顾名思义，copy 将数据从源切片复制到目标切片。它返回复制的元素数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []T)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>copy 函数支持不同长度切片之间的复制（仅复制较少元素的数量）。此外，copy 可以处理共享相同底层数组的源和目标切片，并正确处理重叠切片。</p><p>使用 copy，我们可以简化上面的代码片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(s), (<span class="hljs-built_in">cap</span>(s)+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>)<br><span class="hljs-built_in">copy</span>(t, s)<br>s = t<br></code></pre></td></tr></table></figure><p>一种常见操作是向切片末尾追加数据。该函数将字节元素追加到字节切片，并在必要时扩容切片，并返回更新后的切片值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AppendByte</span><span class="hljs-params">(slice []<span class="hljs-type">byte</span>, data ...<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(slice)<br>    n := m + <span class="hljs-built_in">len</span>(data)<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-built_in">cap</span>(slice) &#123; <span class="hljs-comment">// if necessary, reallocate</span><br>        <span class="hljs-comment">// allocate double what&#x27;s needed, for future growth.</span><br>        newSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, (n+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">copy</span>(newSlice, slice)<br>        slice = newSlice<br>    &#125;<br>    slice = slice[<span class="hljs-number">0</span>:n]<br>    <span class="hljs-built_in">copy</span>(slice[m:n], data)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以像下面这样使用 AppendByte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;<br>p = AppendByte(p, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>)<br><span class="hljs-comment">// p == []byte&#123;2, 3, 5, 7, 11, 13&#125;</span><br></code></pre></td></tr></table></figure><p>像 <code>AppendByte</code> 这样的函数之所以有用，是因为它们可以完全控制切片增长的方式。根据程序的特性，可能需要以更小或更大的块分配空间，或者对重新分配的大小设置上限。</p><p>但是大多数程序不需要完全控制，因此 Go 提供了内置的 <code>append</code> 函数，适用于大多数情况；它的签名为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(s []T, x ...T)</span></span> []T<br></code></pre></td></tr></table></figure><p><code>append</code> 函数将元素 <code>x</code> 追加到切片 <code>s</code> 的末尾，并在必要时对切片扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// a == []int&#123;0&#125;</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// a == []int&#123;0, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure><p>要将一个切片追加到另一个切片，请使用 <strong>…</strong> 将第二个参数展开为参数列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Paul&quot;</span>&#125;<br>b := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-string">&quot;Ringo&quot;</span>, <span class="hljs-string">&quot;Pete&quot;</span>&#125;<br>a = <span class="hljs-built_in">append</span>(a, b...) <span class="hljs-comment">// equivalent to &quot;append(a, b[0], b[1], b[2])&quot;</span><br><span class="hljs-comment">// a == []string&#123;&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>由于切片的零值 (nil) 的行为类似于零长度的切片，因此你可以先声明一个切片变量，然后在循环中追加元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Filter returns a new slice holding only</span><br><span class="hljs-comment">// the elements of s that satisfy fn()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Filter</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, fn <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> p []<span class="hljs-type">int</span> <span class="hljs-comment">// == nil</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> fn(v) &#123;<br>            p = <span class="hljs-built_in">append</span>(p, v)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个潜在的“陷阱”"><a href="#一个潜在的“陷阱”" class="headerlink" title="一个潜在的“陷阱”"></a>一个潜在的“陷阱”</h2><p>正如之前提到的，重新切片不会复制底层数组。整个数组将一直保存在内存中，直到不再被引用。有时这会导致程序在只需要一小部分数据时，却将所有数据保存在内存中。</p><p>例如，这个 <code>FindDigits</code> 函数将一个文件加载到内存中，并搜索其中第一组连续的数字字符，然后将它们作为新的切片返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> digitRegexp = regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">return</span> digitRegexp.Find(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码确实按照预期工作，但返回的 <code>[]byte</code> 指向包含整个文件的数组。由于切片引用原始数组，只要切片存在，垃圾回收器就无法释放数组；文件中少量有用的字节会将整个内容保留在内存中。</p><p>为了解决这个问题，可以在返回数据之前将其复制到一个新的切片中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    b = digitRegexp.Find(b)<br>    c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<br>    <span class="hljs-built_in">copy</span>(c, b)<br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用 <code>append</code> 可以构建一个更简洁的版本。这部分可以留给读者作为练习。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd 集群运维</title>
    <link href="/post/etcd-cluster-operation-guide.html"/>
    <url>/post/etcd-cluster-operation-guide.html</url>
    
    <content type="html"><![CDATA[<h2 id="etcd-简介"><a href="#etcd-简介" class="headerlink" title="etcd 简介"></a>etcd 简介</h2><p>etcd 是一个开源的、分布式的键值存储数据库，用于存储配置数据、服务注册和发现等。etcd 具有高可用性、强一致性和简单易用的特点，被广泛应用于各种分布式系统中。</p><p>etcd 基于 Raft 协议，通过复制日志文件的方式来保证数据的强一致性。</p><h3 id="历史和发展"><a href="#历史和发展" class="headerlink" title="历史和发展"></a>历史和发展</h3><p>“etcd” 源于两个方面，unix 的“/etc”文件夹和分布式系统 (“D”istribute system) 的 D，组合在一起表示 etcd 是用于存储分布式配置的信息存储服务。</p><p>etcd 由 CoreOS 团队于 2013 年发起，最初是为了解决 Kubernetes 集群中配置数据存储和管理的问题。</p><p>etcd 的发展历程如下：</p><ul><li>2013 年 8  月:  v0.1 版本实现了简单的 HTTP Get/Set/Delete/Watch API，但读数据一致性无法保证</li><li>2013 年 12月: v0.2 版本，支持通过指定 consistent 模式，从 Leader 读取数据，并将 Test And Set 机制修正为 CAS(Compare And Swap)，解决原子更新的问题，同时发布了新的 API 版本 v2</li><li>2014 年 2 月: v0.3 版本，支持 Discovery API，Compare And Delete</li><li>2014 年 6 月: Kubernetes v0.4 版本发布，使用 etcd v0.2</li><li>2015 年 1 月: v2.0稳定版本,  Raft 网络模块、存储抽象、插件化，支持 Quorum Read</li><li>2015 年 7 月: Kubernetes v1.0.1 版本发布，第一个生产可用版本，使用 etcd v2.0。发布 v2.1，实现授权和鉴权 API</li><li>2015 年 9 月: 改进client库，提升错误处理等能力</li><li>2017 年 1 月: 发布 3.1版本，提供了一套全新的API，同时提供了gRPC接口，通过gRPC的proxy扩展并极大地提高ETCD的读取性能，支持每秒超过10000次的写入</li><li>2018 年 11月: 项目进入CNCF的孵化项目</li><li>2019 年 8  月: 发布 v3.4版本，该版本由Google、Alibaba等公司联合打造，进一步改进etcd的性能及稳定性</li><li>2021 年 7  月: 发布 v3.5版本，支持Go Module版本号语义及模块化，提升了性能及稳定性，增强了集群运维能力</li></ul><h2 id="搭建-etcd-集群"><a href="#搭建-etcd-集群" class="headerlink" title="搭建 etcd 集群"></a>搭建 etcd 集群</h2><p>这部分的手册是对官方文档的翻译，基于 v3.5 版本，更多内容可以参考官方的<a href="https://etcd.io/docs/v3.5">文档</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>静态启动 etcd 集群需要每个成员都知道彼此的地址。然而，在很多情况下，成员的 IP 地址可能无法提前确定。这时，我们可以借助发现服务来引导 etcd 集群启动。</p><p>etcd 集群启动并运行后，可以通过运行时重新配置来添加或删除成员。</p><p>在接下的操作中，我们将创建一个三成员的集群</p><table><thead><tr><th>Name</th><th>Address</th><th>Hostname</th></tr></thead><tbody><tr><td>infra0</td><td>10.0.1.10</td><td>infra0.example.com</td></tr><tr><td>infra1</td><td>10.0.1.11</td><td>infra1.example.com</td></tr><tr><td>infra2</td><td>10.0.1.12</td><td>infra2.example.com</td></tr></tbody></table><h3 id="静态启动"><a href="#静态启动" class="headerlink" title="静态启动"></a>静态启动</h3><p>由于我们事先知道集群成员、它们的地址和集群大小，所以可以使用离线引导配置，通过设置 <code>initial-cluster</code> 标志来实现。每台机器将获得以下环境变量或命令行参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ETCD_INITIAL_CLUSTER=&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380&quot;<br>ETCD_INITIAL_CLUSTER_STATE=new<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>--initial-cluster-state new<br></code></pre></td></tr></table></figure><p>请注意，<code>initial-cluster</code> 中指定的 URL 是用于通告的对等 URL，它们必须与相应节点上的 <code>initial-advertise-peer-urls</code> 值匹配。</p><p><strong>如果出于测试目的使用相同配置启动多个集群（或创建和销毁单个集群），强烈建议为每个集群指定一个唯一的 <code>initial-cluster-token</code>。</strong> 这样做可以使 etcd 为集群生成唯一的集群 ID 和成员 ID，即使它们具有完全相同的配置。这可以保护 etcd 免受跨集群交互的影响，而跨集群交互可能会损坏集群。</p><p>etcd 监听 <code>listen-client-urls</code> 以接受客户端流量。etcd 成员会将 <code>advertise-client-urls</code> 中指定的 URL 通告给其他成员、代理和客户端。请确保目标客户端可以访问 <code>advertise-client-urls</code>。<strong>一个常见的错误是将 <code>advertise-client-urls</code> 设置为 <code>localhost</code> 或者将其保留为默认值，而这会导致远程客户端无法访问 etcd</strong></p><p>在每一台机器上，通过下面的命令行参数来启动 etcd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="language-bash">  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \</span><br><span class="language-bash">  --advertise-client-urls http://10.0.1.10:2379 \</span><br><span class="language-bash">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="language-bash">  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="language-bash">  --initial-cluster-state new</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.11:2380 \</span><br><span class="language-bash">  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \</span><br><span class="language-bash">  --advertise-client-urls http://10.0.1.11:2379 \</span><br><span class="language-bash">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="language-bash">  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="language-bash">  --initial-cluster-state new</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \</span><br><span class="language-bash">  --listen-peer-urls http://10.0.1.12:2380 \</span><br><span class="language-bash">  --listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \</span><br><span class="language-bash">  --advertise-client-urls http://10.0.1.12:2379 \</span><br><span class="language-bash">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="language-bash">  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="language-bash">  --initial-cluster-state new</span><br></code></pre></td></tr></table></figure><p>对于 etcd 后续运行，以 <code>--initial-cluster</code> 开头的命令行参数将被忽略。完成初始引导过程后，可以随时移除相关环境变量或命令行标志。如果之后需要变更配置（例如添加或移除集群成员），请参考运行时配置指南。</p>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
      <tag>operations</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 使用管道连接 Command</title>
    <link href="/post/go-command-pipe.html"/>
    <url>/post/go-command-pipe.html</url>
    
    <content type="html"><![CDATA[<p>在 posix 系统中，我们可以使用 <code>|</code> 来连接两个命令，从而将前一个命令的标准输出作为后一个命令的标准输入，就像下面这个例子一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | grep go<br></code></pre></td></tr></table></figure><p>我们首先使用 <code>ls</code> 命令获取到当前目录的文件，然后将输出传递给 <code>grep</code> 命令，从文件列表中过滤带有 go 的文件。</p><p>那么我们可以在 Go 实现类似管道的操作吗，将多个 Cmd 连接起来。答案是可以的，并且十分的简单，只需使用标准库的能力就可以做到。</p><p>首先，我们需要定义两个 <code>exec.Cmd</code> 对象，分别代表 ls 和 grep 命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ls := exec.Command(<span class="hljs-string">&quot;ls&quot;</span>)<br>grep := exec.Command(<span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后就是定义一个方法，将这两个命令连接到一起，并将结果输出到标准输出中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipeCommand</span><span class="hljs-params">(cmdA *exec.Cmd, cmdB *exec.Cmd)</span></span> &#123;<br>stdout, err := cmdA.StdoutPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> err := cmdA.Start(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cmdB.Stdin = stdout<br>cmdB.Stdout = os.Stdout<br>cmdB.Stderr = os.Stderr<br><span class="hljs-keyword">if</span> err := cmdB.Start(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := cmdA.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := cmdB.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们先调用 StdoutPipe 方法获取到 cmdA 的标准输出流，然后开始执行 cmdA。</p><p>接下来我们将 A 的标准输出流设置为 B 的标准输入，并设置 B 的输出流以及错误流，完成后，同样开始启动 B。此时 B 会从 stdin 中读取数据，如果没有数据，则会等待，但 Start() 方法不会阻塞。因此程序可以正常往下走。</p><p>在这之后，我们等待 A 命令执行完成，并关闭输出流，从而通知 B 以及没有更多的输入了。</p><p>最后我们再等待 B 命令完成，就可以在控制台看到相关的输出了。</p><p>需要注意的是，我们要在等待 A 完成前启动 B，否则在启动时就会返回错误，提示</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">(standard <span class="hljs-keyword">input</span>): Bad <span class="hljs-keyword">file</span> descriptor<br></code></pre></td></tr></table></figure><p>这是因为，A 完成之后，就会关闭输出流了，此时 B 就无法获取到正确的输入流了，于是就返回了上面的错误。</p><p>到这里，我们就在 Go 中实现了 bash 中的 pipe 操作了。</p><p>完整代码为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipeCommand</span><span class="hljs-params">(cmdA *exec.Cmd, cmdB *exec.Cmd)</span></span> &#123;<br>stdout, err := cmdA.StdoutPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> err := cmdA.Start(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cmdB.Stdin = stdout<br>cmdB.Stdout = os.Stdout<br>cmdB.Stderr = os.Stderr<br><span class="hljs-keyword">if</span> err := cmdB.Start(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := cmdA.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := cmdB.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ls := exec.Command(<span class="hljs-string">&quot;ls&quot;</span>)<br>grep := exec.Command(<span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>)<br>pipeCommand(ls, grep)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个 Gemini 聊天网页</title>
    <link href="/post/build-own-gemini-chat.html"/>
    <url>/post/build-own-gemini-chat.html</url>
    
    <content type="html"><![CDATA[<p>Google 发布了新的 Gemini Pro 模型，一个对标 openAI 的产品。我们除了可以通过使用英文版的 Bard 来尝试这个新的模型，也可以通过 Google AI 实验室来构建自己的 AI 应用。</p><p>在这篇文章中，我记录了如何搭建一个属于自己的聊天机器人。</p><p><strong>事前准备：</strong></p><p><strong>1. 需要能够访问 Google，并且拥有 Google 账户。</strong></p><p><strong>2. docker 环境</strong></p><p>首先，登录 Google AI 实验室的<a href="https://makersuite.google.com/">首页</a>，进入后，使用自己的 Google 账户登录即可。</p><p>完成登录后，点击页面左侧的 <em>Get API key</em> 去创建一个新的 API Key。如果之前没有使用过，直接点击 <em>Create API key in new project</em> 生成新的 Key 即可。</p><p>稍等片刻，就能看到新生成的 Key 了。</p><p>接下来就是准备站点的页面了，我们这里使用开源的 <a href="https://github.com/babaohuang/GeminiProChat">GeminiProChat</a> 来做为前端页面。</p><p>根据项目的官方文档，我们直接选择使用 docker 来进行本地部署。只需要运行下面的命令即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name geminiprochat \<br>--restart always \<br>-p 3000:3000 \<br>-itd \<br>-e GEMINI_API_KEY=&lt;your_api_key_here&gt; \<br>-e SITE_PASSWORD=&lt;you_site_password&gt; \<br>babaohuang/geminiprochat:latest<br></code></pre></td></tr></table></figure><p>这里我们预设了一个站点密码，只有输入正确的密码才可以访问，防止别人恶意访问链接。</p><p>运行之后，在本地访问 localhost:3000 即可了。</p><p>如果你是在自己的服务器上部署，并且希望通过 nginx 代理服务，那么就需要在 nginx 的配置中加入下面的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-comment"># 将 80 替换成需要的地址</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;<br><span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;<br><span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&#x27;upgrade&#x27;</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_cache_bypass</span> <span class="hljs-variable">$http_upgrade</span>; <span class="hljs-comment"># 如果不需要流式响应，可以不加这项配置</span><br><span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">off</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新配置后，重新加载 nginx 就可以生效了。</p><p>到这里，你就完成了一个属于自身的 Gemini 聊天网页了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务隔离</title>
    <link href="/post/mysql-transaction-isolation.html"/>
    <url>/post/mysql-transaction-isolation.html</url>
    
    <content type="html"><![CDATA[<p>事务用来保证一组数据库操作，要么一起成功，要么一起失败。不存在一部分操作成功，另一部分操作失败的情况。</p><p>最常见的例子就是银行的转账。当小明需要给小红转 100 元时，首先需要检查小明的账户是否有足够的余额，然后将小红的余额增加 100，更新小明的余额。在这个例子中，整个操作必须同时成功或者失败，不能出现小红的余额增加了 100，小明的余额却没有减少 100 的情况。</p><p>MySQL 的事务支持是在引擎层实现的。MySQL 支持多引擎，可以根据需要选择不同的引擎，但是 MySQL 原生的引擎 MyISAM 是不支持事务操作的，因此在之后被 Innodb 所替代了。</p><p>在 MySQL 谈到事务相关的概念时，没有特殊说明的情况下，我们都是在以 InnoDB 引擎为例，这也是新版本 MySQL 的默认引擎。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务具有四个特性，分别是原子性(Atomicity )，一致性(Consistency)，隔离性(Isolation)以及持久性(Durability)</p><ul><li><strong>原子性（Atomicity）</strong>：在 MySQL 中，事务被视为单一的不可分割的单位，所有操作要么全做，要么全不做。MySQL 使用回滚（ROLLBACK）操作保证事务的原子性，在事务执行过程中如果发生错误，所做的全部更改将被撤销，数据库将返回到事务开始时的状态。</li><li><strong>一致性（Consistency）</strong>：在 MySQL 中，一致性意味着只有合法的数据能被写入数据库，否则，事务应当会被回滚。例如，定义了数据的整合性约束（如外键约束），在更新操作中不满足约束的数据将不被写入。</li><li><strong>隔离性（Isolation）</strong>：在 MySQL 中，多个事务可以并发执行，但每个事务都被视为在一个独立的“沙箱”中进行，保障了事务间不互相干扰。</li><li><strong>持久性（Durability）</strong>：在 MySQL 中，一旦事务完成（即，被提交了），对数据库的更改就是永久性的，下次数据库启动时，数据仍然存在，这就是持久性。这是通过将事务记录在磁盘上的重做日志（Redo Log）中实现的。即使在系统出现故障的情况下也可以通过重做操作（Redo）恢复数据</li></ul><p>由于事务执行是互不干扰的，因此在多个事务执行时，可能会出现下面的三种读取异常：</p><ul><li><strong>脏读（Dirty Read）</strong>：一个事务读取了其他事务未提交的修改。如果这些修改最后被回滚（即未被提交），那么读取这些数据的事务就会得到错误的数据。脏读可能导致数据不一致的问题。</li><li><strong>不可重复读（Non-Repeatable Read）</strong>：在同一事务中，某个数据被多次读取，但每次得到的结果都不同。这通常是因为在两次读操作之间，另一个具有写权限的事务更改或删除了这个数据并进行了提交，导致同一事务的两次读取返回的结果不一致。这种现象称为不可重复读。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，执行完相同的查询操作，第一次和后续的查询结果不一致，即后续的查询操作多了一些行或者少了一些行。这通常发生在另一个并发事务在两次查询期间插入或删除了一些行造成的。这种现象称为幻读。</li></ul><p>为了解决上面的这些问题，我们需要设置数据库的事务隔离级别。SQL 标准定义了四种隔离级别，从低到高分别为：</p><ul><li><p>**读未提交 (Read Uncommitted)**：一个事务还没提交时，它做的变更就能被别的事务看到</p></li><li><p>**读已提交 (Read Committed)**：一个事务提交之后，它做的变更才会被其他事务看到</p></li><li><p><strong>可重复读 (Repeatable Read)</strong> ：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的</p></li><li><p>**串行化 (Serializable)**：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</p></li></ul><p>这四个级别能够逐级避免脏读、不可重复读、幻读三种现象，但隔离级别越高，并发性能越低。在实际开发中需要根据业务需求来选择合适的隔离级别。</p><p>在 MySQL 的 InnoDB 存储引擎中，默认的隔离级别是 “可重复读”，这个级别下，能有效的防止脏读和不可重复读，但无法防止幻读。要避免幻读需要将隔离级别设置为 “串行化”。</p><p>在这四个等级中，读已提交与可重复读容易让人弄混。我们借助一个例子来说明它们的区别。</p><p>首先我们创建一张用于测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T(var <span class="hljs-type">int</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> T(var) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>然后我们按照时间顺序启动两个事务</p><table><thead><tr><th>事务 A</th><th>事务 B</th></tr></thead><tbody><tr><td>启动事务， 查询得到 1</td><td>启动事务</td></tr><tr><td></td><td>查询得到值 1</td></tr><tr><td></td><td>将 1 改为 2</td></tr><tr><td>查询得到值 V1</td><td></td></tr><tr><td></td><td>提交事务 B</td></tr><tr><td>查询得到值 V2</td><td></td></tr><tr><td>提交事务 B</td><td></td></tr><tr><td>查询得到值 V3</td><td></td></tr></tbody></table><p>在不同的隔离级别下，事务 A 查询到的值 V1，V2， V3 是不同的</p><ul><li>读未提交：V1，V2，V3 的值都是 2，此时虽然 B 还没有提交，但是 A 已经能看到 B 修改的值了</li><li>读提交：V1 = 1，V2 = 2，V3=2，事务 B 只有完成提交，才能被 A 看到</li><li>可重复读：V1=1， V2=1，V3=2，V2 还是 1 的原因是因为事务在执行期间看到的数据前后必须是一致的</li><li>串行化：B 在更新 数据时会被锁住，直到 A 的事务提交后 B 才可以继续执行。因此 V1=1， V2=1，V3=2</li></ul><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>在事务的实现上，数据库会创建一个数据的视图，在访问数据时以视图里的逻辑结果为准。</p><p>在可重复读的级别下，这个视图是在事务开始时创建，在整个事务期间都是使用这个视图。在读提交的隔离级别下，这个视图时是在每个 SQL 执行时创建的。在读未提交的级别下，会直接返回最新的数据记录，而没有视图的存在。在串行化的级别下，则是通过直接加锁来避免并发访问。</p><p>在 MySQL 中，每条记录在更新时都会记录一条回滚记录。记录上的最新值，通过回滚操作可以返回到上一个状态的值。</p><p>假设一个值 1 按顺序被改成了 2，3，4，那么就会在数据库中形成一条类似下面的记录：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br><br>       view C          view B                           view C<br>         │               │                                 │<br>         │               │                                 │<br>         │               │                                 │<br>┌────────┴───────────────┴─────────────────────────┐       │<br>│        ▼               ▼                         │       │<br>│  ┌──────────┐     ┌──────────┐     ┌──────────┐  │  ┌────▼─────┐<br>│  │          │     │          │     │          │  │  │          │<br>│  │ <span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span> │◄────┤ <span class="hljs-number"> 3 </span>-&gt;<span class="hljs-number"> 2 </span> │◄────┤ <span class="hljs-number"> 4 </span>-&gt;<span class="hljs-number"> 3 </span> │◄─┼──┤  cur-&gt;4  │<br>│  │          │     │          │     │          │  │  │          │<br>│  └──────────┘     └──────────┘     └──────────┘  │  └──────────┘<br>│                                                  │<br>│                                                  │<br>│                 rollback segment                 │<br>│                                                  │<br>│                                                  │<br>└──────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的视图。就像图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到，也就是执行 4 -&gt;3,  3-&gt;2,  2-&gt;1。</p><p>如果此时有另一个事务将 4 改成了 5，那么与当前的视图也不会产生冲突，只是会产生一个新的回滚记录。</p><p>回滚日志在系统判断没有事务使用时被删除。没有事务使用的判断依据是没有比回滚日志更早的事务存在了。</p><p>由于这个特性，如果我们在数据操作时开启了长事务，那么数据库中就会存在很老的事务视图。由于这个事务可能随时访问数据，因此数据库必须为它保留回滚日志，这就导致了大量的存储空间被占用。除此之外，长事务还会导致长时间的锁占用，从而拖累整个数据库。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>在 MySQL 数据库中，事务有以下的两种启动方式：</p><ol><li>使用 begin 或者 start transaction 来显示的启动事务，提交使用 commit，回滚则使用 rollback；</li><li>通过 <code>set autocommit=0</code> 命令关闭线程的自动提交。在这种情况下，如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li></ol><p>第二种启动方式处理不当就会导致长事务。因此最好使用 <code>set autocommit=1</code> 开启自动提交，并在需要使用事务时显示的开启事务。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 错误是值</title>
    <link href="/post/go-errors-are-value.html"/>
    <url>/post/go-errors-are-value.html</url>
    
    <content type="html"><![CDATA[<p>本文是对 Rob Pike 博客 <a href="https://go.dev/blog/errors-are-values">Errors are values </a> 的翻译。</p><p>在 Go 中，经常可以看到关于错误处理的讨论。在讨论的过程中，对话通常会演变成对语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>出现次数的哀叹。我们最近扫描了我们能找到的所有开源项目，发现这个代码段在每一页只出现过一两次，比一些人让你相信的要少。不过，如果人们仍然认为你必须一直输入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> <br></code></pre></td></tr></table></figure><p>这种事情发生一定是有原因的，一个显而易见的原因就是 Go 语言本身。</p><p>这是一个不幸的，具有误导性的结论，并且它很容易被纠正。一个可能发生的情况是，刚接触 Go 的程序员会问，“如何处理错误？“，在学会了上面的这种处理模式后，就止步不前了。在其他语言中，例如 java，人们可能会使用 try-catch 块或其他此类机制来处理错误。因此，程序员会认为，就像我以前用过的语言中使用 try-catch 一样，我只需在 Go 中输入 <code>if</code> <code>err</code> <code>!=</code> <code>nil</code> 。随着时间的推移，代码库中累积了许多这样的代码段，最终让人觉得笨拙。</p><p>无论这种解释是否合适，显然这些 Go 程序员都忽略了关于错误的一个基本要点：错误是值。</p><p>我们可以对值进行编程，并且由于错误是值，因此可以对错误进行编程。</p><p>当然，涉及错误值的一个常见语句是判断它是否为 nil，但还可以对错误值执行无数其他操作，并且应用其中一些操作可以使您的程序更好，从而消除如果使用死板的 if 语句检查每个错误时出现的许多样板代码。</p><p>下面是 <code>bufio</code> 包的 <code>Scanner</code> 类型的简单示例。它的 <code>Scan</code> 方法执行基础 I/O，这当然可能导致错误。然而， <code>Scan</code>方法根本不公开错误。相反，它返回一个布尔值，并在扫描结束时运行一个单独的方法来报告是否发生错误。客户端代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">scanner := bufio.NewScanner(input)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>    token := scanner.Text()<br>    <span class="hljs-comment">// process token</span><br>&#125;<br><span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// process the error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在代码中有一个错误的 nil 检查，但它只出现并执行一次。 <code>Scan</code> 方法本可以定义为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Scanner)</span></span> Scan() (token []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>然后示例用户代码可能是（取决于如何检索 Token ），</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">scanner := bufio.NewScanner(input)<br><span class="hljs-keyword">for</span> &#123;<br>    token, err := scanner.Scan()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// or maybe break</span><br>    &#125;<br>    <span class="hljs-comment">// process token</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这并没有什么不同，但有一个重要的区别。在此代码中，客户端必须在每次迭代时都检查一次错误，但在真正的 <code>Scanner</code>API 中，错误处理从关键的 API 元素（即遍历标记）中抽象出来。因此，使用真正的 API 时，客户端的代码感觉更自然：循环直到完成，然后处理错误。错误处理不会掩盖控制流。</p><p>当然，在底层发生的事情是，一旦 <code>Scan</code> 遇到 I/O 错误，它就会记录该错误并返回 <code>false</code> 。当客户端询问时，另一个方法 <code>Err</code> 会报告错误值。虽然这很微不足道，但它与在每个地方，都放置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>或要求客户端在每个 Token 后检查错误不同。这是使用错误值进行编程。简单的编程，是的，但仍然是编程。</p><p>值得强调的是，无论设计如何，程序都必须检查错误，无论它们如何暴露。这里的讨论不是关于如何避免检查错误，而是关于使用该语言优雅地处理错误。</p><p>我在 2014 年秋季参加东京举行的 GoCon 时，重复错误检查代码的话题出现了。一位热情的 gopher，他在 Twitter 上的昵称是 <code>@jxck_</code> ，对错误检查发出了熟悉的抱怨。他有一些代码，从形式上看类似这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = fd.Write(p0[a:b])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>_, err = fd.Write(p1[c:d])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>_, err = fd.Write(p2[e:f])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// and so on</span><br></code></pre></td></tr></table></figure><p>它非常重复。在更长的实际代码中，还有更多内容，因此不能简单地使用辅助函数重构它，但这种理想化的形式，一个封闭在错误变量上的函数字面量会有所帮助：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>write := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(buf []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, err = w.Write(buf)<br>&#125;<br>write(p0[a:b])<br>write(p1[c:d])<br>write(p2[e:f])<br><span class="hljs-comment">// and so on</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式运行良好，但需要在执行写入的每个函数中使用闭包；单独的辅助函数使用起来比较笨拙，因为 <code>err</code> 变量需要在调用之间保持（试试看）。</p><p>我们可以借用上面 <code>Scan</code> 方法中的思想，让它更简洁、更通用、更可重用。我在我们的讨论中提到了这种技术，但 <code>@jxck_</code> 没有看到如何应用它。经过一番冗长的交流，由于语言障碍而受到一些阻碍，我问他是否可以借用他的笔记本电脑，通过键入一些代码来向他展示。</p><p>我定义了一个名为 <code>errWriter</code> 的对象，类似这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> &#123;<br>    w   io.Writer<br>    err <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并给它一个方法 <code>write.</code> ，它不需要具有标准 <code>Write</code> 签名，并且部分采用小写以突出区别。 <code>write</code> 方法调用底层 <code>Writer</code> 的 <code>Write</code> 方法，并记录第一个错误以供将来参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span></span> write(buf []<span class="hljs-type">byte</span>) &#123;<br>    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, ew.err = ew.w.Write(buf)<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦发生错误， <code>write</code> 方法将变为无操作，但会保存错误值。</p><p>给定 <code>errWriter</code> 类型及其 <code>write</code> 方法，可以重构上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">ew := &amp;errWriter&#123;w: fd&#125;<br>ew.write(p0[a:b])<br>ew.write(p1[c:d])<br>ew.write(p2[e:f])<br><span class="hljs-comment">// and so on</span><br><span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> ew.err<br>&#125;<br></code></pre></td></tr></table></figure><p>这更简洁，即使与使用闭包相比也是如此，而且还使页面上实际执行的写入序列更容易查看。不再有混乱了。使用错误值（和接口）进行编程使代码更简洁。</p><p>很可能同一软件包中的其他一些代码片段可以基于此想法进行构建，甚至直接使用 <code>errWriter</code> 。</p><p>此外，一旦存在 <code>errWriter</code> ，它还可以做更多的事情来提供帮助，尤其是在不太人工的示例中。它可以累积字节计数。它可以将写入合并到一个可以原子传输的单个缓冲区中。还有更多。</p><p>事实上，这种模式经常出现在标准库中。 <code>archive/zip</code> 和 <code>net/http</code> 包使用它。更重要的是， <code>bufio</code> 包的 <code>Writer</code> 实际上是 <code>errWriter</code> 思想的实现。虽然 <code>bufio.Writer.Write</code> 返回错误，但这主要与遵守 <code>io.Writer</code>接口有关。 <code>bufio.Writer</code> 的 <code>Write</code> 方法的行为与我们上面的 <code>errWriter.write</code> 方法完全一样，其中 <code>Flush</code> 报告错误，因此我们的示例可以这样编写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">b := bufio.NewWriter(fd)<br>b.Write(p0[a:b])<br>b.Write(p1[c:d])<br>b.Write(p2[e:f])<br><span class="hljs-comment">// and so on</span><br><span class="hljs-keyword">if</span> b.Flush() != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> b.Flush()<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法有一个明显的缺点，至少对于某些应用程序而言：无法知道在错误发生之前已完成了多少处理。如果该信息很重要，则需要更细粒度的处理方法。不过，通常情况下，最后进行全有或全无的检查就足够了。</p><p>我们只研究了一种避免重复错误处理代码的技术。请记住，使用 <code>errWriter</code> 或 <code>bufio.Writer</code> 并不是简化错误处理的唯一方法，这种方法并不适用于所有情况。然而，关键的经验教训是，错误是值，Go 编程语言的全部功能都可以用来处理它们。</p><p>使用该语言来简化错误处理。</p><p>但是请记住：无论您做什么，务必检查您的错误！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 使用 deadcode 查找无法访问的函数</title>
    <link href="/post/finding-unreachable-functions-with-deadcode.html"/>
    <url>/post/finding-unreachable-functions-with-deadcode.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章是对 Go 官方博客 <a href="https://go.dev/blog/deadcode">Finding unreachable functions with deadcode</a> 的翻译</p><p>项目源代码中存在但在任何执行过程中都无法访问的函数被称为“死代码”，会对代码库维护工作造成负担。今天，我们很高兴与您分享一个名为 deadcode 的工具，帮助您识别这些死代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go install golang.org/x/tools/cmd/deadcode@latest<br>$ deadcode -<span class="hljs-built_in">help</span><br>The deadcode <span class="hljs-built_in">command</span> reports unreachable <span class="hljs-built_in">functions</span> <span class="hljs-keyword">in</span> Go programs.<br><br>Usage: deadcode [flags] package...<br></code></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>在过去一年左右的时间里，我们对 VS Code 和其他编辑器使用的 Go 语言服务器 gopls 的结构进行了大量更改。一个典型的更改可能是重写一些现有的函数，并确保其新行为满足所有现有调用者的需求。有时，在付出所有努力之后，我们会沮丧地发现其中一个调用者实际上从未在任何执行中被调用，因此可以安全地将其删除。如果我们事先知道这一点，我们的重构任务就会更容易。 </p><p>下面的简单 Go 程序说明了这个问题：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">module</span> example.com/greet<br><span class="hljs-attribute">go</span> <span class="hljs-number">1</span>.<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> g Greeter<br>    g = Helloer&#123;&#125;<br>    g.Greet()<br>&#125;<br><br><span class="hljs-keyword">type</span> Greeter <span class="hljs-keyword">interface</span>&#123; Greet() &#125;<br><br><span class="hljs-keyword">type</span> Helloer <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Goodbyer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> _ Greeter = Helloer&#123;&#125;  <span class="hljs-comment">// Helloer  implements Greeter</span><br><span class="hljs-keyword">var</span> _ Greeter = Goodbyer&#123;&#125; <span class="hljs-comment">// Goodbyer implements Greeter</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Helloer)</span></span> Greet()  &#123; hello() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Goodbyer)</span></span> Greet() &#123; goodbye() &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>   &#123; fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goodbye</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;goodbye&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><p>当我们执行它时，它会输出 hello</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ go <span class="hljs-built_in">run</span> .<br>hello<br></code></pre></td></tr></table></figure><p>从程序的输出可以清楚地看出，它执行了 hello 函数，但没有执行 goodbye 函数。不太明显的是，goodbye 函数永远不会被调用。然而，我们不能简单地删除 goodbye，因为它是 Goodbyer.Greet 方法所必需的，而 Goodbyer.Greet 方法又是实现 Greeter 接口所必需的，我们可以看到 Greeter 接口的 Greet 方法是从 main 调用的。但是如果我们从 main 开始往前分析，可以看到没有 Goodbyer 值被创建过，所以 main 中的 Greet 调用只能到达 Helloer.Greet。这就是 deadcode 工具所使用的算法背后的想法。</p><p>当我们使用 deadcode 来检查这个程序时，该工具会告诉我们 goodbye 函数和 Goodbyer.Greet 方法都是不可到达的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">$ deadcode .<br>greet.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span>: unreachable <span class="hljs-function"><span class="hljs-keyword">func</span>: <span class="hljs-title">goodbye</span></span><br>greet.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span>: unreachable <span class="hljs-function"><span class="hljs-keyword">func</span>: <span class="hljs-title">Goodbyer</span>.<span class="hljs-title">Greet</span></span><br></code></pre></td></tr></table></figure><p>有了这个信息之后，我们就可以安全的删除这两个函数，以及 Groodbyer 接口。</p><p>该工具还可以解释为什么 hello 函数是活跃的。它会从 main 开始，以函数调用链的形式显示到达 hello 函数的路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ deadcode <span class="hljs-operator">-</span>whylive<span class="hljs-operator">=</span>example.com<span class="hljs-operator">/</span>greet.hello .<br>                  example.com<span class="hljs-operator">/</span>greet.main<br><span class="hljs-keyword">dynamic</span><span class="hljs-variable">@L0008</span> <span class="hljs-comment">--&gt; example.com/greet.Helloer.Greet</span><br> <span class="hljs-keyword">static</span><span class="hljs-variable">@L0019</span> <span class="hljs-comment">--&gt; example.com/greet.hello</span><br></code></pre></td></tr></table></figure><p>它的输出被设计为容易从命令行读取，但是你也可以通过 <code>-json</code> 或者<code>-f=template</code> 标志来指定更加丰富的输出以供其他工具使用。</p><h2 id="deadecode-是如何工作的"><a href="#deadecode-是如何工作的" class="headerlink" title="deadecode 是如何工作的"></a>deadecode 是如何工作的</h2><p>deadcode 工具对指定的包进行 <a href="https://pkg.go.dev/golang.org/x/tools/go/packages">加载</a>, <a href="https://pkg.go.dev/go/parser">解析</a>, 以及<a href="https://pkg.go.dev/go/types">类型检查</a> ，然后将它们转换为类似于典型编译器的<a href="https://pkg.go.dev/golang.org/x/tools/go/ssa">中间表示</a>。</p><p>然后，它使用一种称为快速类型分析（Rapid Type Analysis，<a href="https://pkg.go.dev/golang.org/x/tools/go/callgraph/rta">RTA</a>）的算法来构建可访问函数的集合。该集合最初仅包含每个 main 包的入口点：main 函数和包初始化函数，用于分配全局变量并调用名为 init 的函数。</p><p>RTA 会查看每个可达函数体内的语句，以收集三种信息：它直接调用的函数集合；它通过接口方法进行的动态调用集合；以及它转换为接口的类型集合。</p><p>直接函数调用很简单：我们只需将被调用者添加到可达函数的集合中，如果是第一次遇到被调用者，我们会像对待 main 函数一样检查它的函数体。 </p><p>通过接口方法进行的动态调用则比较棘手，因为我们不知道实现该接口的类型集合。我们不想假设程序中所有类型匹配的方法都是调用的可能目标，因为其中一些类型可能只会从死代码中实例化！这就是我们收集转换为接口的类型集合的原因：这种转换使得这些类型中的每一个都可以从 main 访问，因此它们的方法现在可以成为动态调用的目标。 </p><p>这导致了一种鸡生蛋蛋生鸡的情况。当我们遇到每个新的可达函数时，我们会发现更多的接口方法调用和更多的具体类型到接口类型的转换。但是，随着这两个集合（接口方法调用 × 具体类型）的叉积越来越大，我们会发现新的可达函数。这类问题被称为“动态规划”，可以通过（概念上）在一个大的二维表格中打勾来解决，随着我们前进，添加行和列，直到没有更多的勾要添加。最终表格中的勾告诉我们什么是可达的；空白单元格是死代码。</p><p><img src="https://go.dev/blog/deadcode-rta.svg" alt="deadcode-rta"></p><p>对（非方法）函数的动态调用类似于单个方法的接口。使用反射进行的调用被认为可以访问接口转换中使用的任何类型的任何方法，或者使用 reflect 包从一个类型派生的任何类型。但原则在所有情况下都是一样的。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>RTA 是一种全程序分析方法。这意味着它始终从 main 函数开始并向前工作：你不能从像 encoding/json 这样的库包开始。 </p><p>然而，大多数库包都有测试，而测试有 main 函数。我们看不到这些函数，因为它们是在 go test 的幕后生成的，但我们可以使用 -test 标志将它们包含在分析中。 如果这报告库包中的函数是死的，这是一个迹象，表明你的测试覆盖率可以改进。例如，这个命令列出了 encoding/json 中所有没有被任何测试覆盖的函数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ deadcode -test -<span class="hljs-keyword">filter</span>=<span class="hljs-keyword">encoding</span>/<span class="hljs-type">json</span> <span class="hljs-keyword">encoding</span>/<span class="hljs-type">json</span><br><span class="hljs-keyword">encoding</span>/<span class="hljs-type">json</span>/decode.go:<span class="hljs-number">150</span>:<span class="hljs-number">31</span>: unreachable func: UnmarshalFieldError.Error<br><span class="hljs-keyword">encoding</span>/<span class="hljs-type">json</span>/encode.go:<span class="hljs-number">225</span>:<span class="hljs-number">28</span>: unreachable func: InvalidUTF8Error.Error<br></code></pre></td></tr></table></figure><p><code>-filter</code> 标志将输出限制为匹配正则表达式的包。默认情况下，该工具会报告初始模块中的所有包。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>所有静态分析工具都必然会产生对目标程序可能的动态行为的不完美近似。一个工具的假设和推断可能是“可靠的”，意味着保守但可能过于谨慎，也可能是“不可靠的”，意味着乐观但并不总是正确的。</p><p> deadcode 工具也不例外：它必须通过函数和接口值或使用反射来近似动态调用的目标集合。在这方面，该工具是可靠的。换句话说，如果它报告一个函数是死代码，这意味着该函数即使通过这些动态机制也不能被调用。但是，该工具可能无法报告一些实际上永远不能执行的函数。</p><p> deadcode 工具还必须近似从不是用 Go 编写的函数（它看不到）所进行的调用集合。在这方面，该工具是不可靠的。它的分析不知道专门从汇编代码调用的函数，也不知道由 go:linkname 指令引起的函数别名。幸运的是，这两个特性很少在 Go 运行时之外使用。</p><h2 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h2><p>我们会定期在我们的项目上运行 deadcode，尤其是在重构工作之后，以帮助识别程序中不再需要的部分。</p><p> 在清理死代码后，您可以专注于消除那些已经寿终正寝但却顽固地存在的代码，这些代码会继续消耗您的生命力。我们称这种不死的函数为“吸血鬼代码”！ 请试一试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ go install golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/</span>deadcode<span class="hljs-meta">@latest</span><br></code></pre></td></tr></table></figure><p>我们发现这是很有用的， 希望对你也是。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLA+ 算子和值</title>
    <link href="/post/tla-operator-and-values.html"/>
    <url>/post/tla-operator-and-values.html</url>
    
    <content type="html"><![CDATA[<h2 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h2><p>在 TLA+ 中, 算子 (operator) 就是编程语言中的函数。它们接受参数并求值为表达式。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">EXTENDS Integers<br><br>MinutesToSeconds(m) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> m * <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>算子可以接收任意数量的参数. 没有默认值, 重载或者是可选参数. 如果一个算子接收两个参数, 那么就必须传递两个参数. 如果一个算子不接受参数, 那么可以写成没有参数的形式. 在这种情况下, 它就像一个常量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SecondsPerMinute</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>算子的右半部分称之为表达式.</p><h2 id="IF-THEN-ELSE"><a href="#IF-THEN-ELSE" class="headerlink" title="IF-THEN-ELSE"></a>IF-THEN-ELSE</h2><p>在 TLA+ 中有三个结构化表达式的关键字, 分别是 <strong>let</strong> 语句, <strong>case</strong> 语句以及条件语句.</p><p>条件语句如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Abs(<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> IF <span class="hljs-keyword">x</span> &lt; <span class="hljs-number">0</span> THEN -<span class="hljs-keyword">x</span> ELSE <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><p>语句意义和常用编程语言中的三元表达式是相同的.</p><p>表达式总是会等于一个值, 因此 ELSE 是必须存在的.</p><h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p>TLA+ 是一个起源于数学的语言, 因此其中的值是无类型的. 在实际使用时, 模型检查器可以识别四种基本类型和四种复杂类型.</p><ul><li><p>基本类型: strings, booleans, integers 以及 models value.</p></li><li><p>复杂类型: sets, sequences, structures 以及 functions.</p></li></ul><p>在 TLA+ 中的每种类型都有着各自的算子, 不能被重载, 重写. 例外的算子是 “=” 和 “#”, 表示相等和不相等.</p><p>不同类型的值是不能进行比较的, 对不同类型的值进行比较会返回错误.</p><h2 id="显而易见"><a href="#显而易见" class="headerlink" title="显而易见"></a>显而易见</h2><p><strong>Integers</strong> 和 <strong>strings</strong> 要使用基本的加法运算符，需要 <code>EXTENDS Integers</code>。字符串必须使用 “双引号”，不能使用单引号。除了 = 和 # 之外，字符串没有运算符。实际上，字符串被用作不透明的标识符，类似于某些语言的 :symbol 类型。如果您的系统需要操作字符串，我们可以将其存储在序列中。</p><p>需要注意的是, 在 TLA+ 中没有 <strong>float</strong> 类型。浮点数具有复杂的语义，极难表示。通常情况下，可以将其抽象出来. 但如果您绝对需要浮点数，那么 TLA+ 就是一个错误的工具。</p><h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>布尔类型的值是 <code>TRUE</code> 和<code> FALSE</code></p><p>boolean 的算子在 TLA+ 中更像是数学中的符号, 而不是编程语言中的符号。</p><table><thead><tr><th>逻辑</th><th>TLA+ 符号</th><th>数学符号</th></tr></thead><tbody><tr><td>且(and)</td><td>/\</td><td>⋀</td></tr><tr><td>或(or)</td><td>/</td><td>⋁</td></tr><tr><td>非(not)</td><td>~</td><td>¬</td></tr></tbody></table><p>我们可以使用基础算子来构建新的算子, 如异或(xor)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Xor</span><span class="hljs-params">(A, B)</span></span> == A = ~B<br></code></pre></td></tr></table></figure><p>初次之外, boolean 还有一个算子 <code>=&gt;</code>, 表示蕴含. <code>A =&gt; B</code> 表示 “A 至少和 B 一样为真”。<code>A =&gt; B</code> = FALSE 当 A 为真且 B 为假时为假，否则为真。B 为真或 A 为假（或两者皆假）。这在编程中并不常见，因为它对控制流毫无用处。但它对任何规范工作都极为重要。</p><p>另外, 在 TLA+ 中, 布尔运算还有着 “bullet point notation” . 当有一个表达式像 <code>A /\ (B \/ C) /\ (D \/ (E /\ F))</code> 这样, 就会难以阅读, 因此可以将其改写为:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">/<span class="hljs-string">\</span> A<br>/<span class="hljs-string">\</span> <span class="hljs-string">\/</span> B<br>   <span class="hljs-string">\/</span> C<br>/<span class="hljs-string">\</span> <span class="hljs-string">\/</span> D<br>   <span class="hljs-string">\/</span> /<span class="hljs-string">\</span> E<br>      /<span class="hljs-string">\</span> F<br></code></pre></td></tr></table></figure><p>这样看起来就变得极为清晰了. 在 A 前面有一个额外的 <code>/\</code>, 这不是必须的, 但是它让整个结构看起来更为舒适. 这也是<strong>语言中唯一需要留白的地方</strong>。假设我写的是</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">/<span class="hljs-string">\</span> A<br>/<span class="hljs-string">\</span> <span class="hljs-string">\/</span> B<br>   <span class="hljs-string">\/</span> C<br>/<span class="hljs-string">\</span> <span class="hljs-string">\/</span> D<br>   <span class="hljs-string">\/</span> /<span class="hljs-string">\</span> E<br>/<span class="hljs-string">\</span> F<br></code></pre></td></tr></table></figure><p>那么所有的逻辑都将变化了, 现在表达式等于 <code>A /\ (B \/ C) /\ (D \/ E) /\ F</code>.</p><h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p>sequences 就像其它语言中的 list. 一个 sequence 可以被写成 &lt;&lt;a, b, c&gt;&gt;, 它的值可以是任何类型的(包括 sequence). 和其它大多数语言一样, 我们通过 <code>seq[n]</code> 的语句来获取指定位置的值, 只不过在 TLA+ 中, 列表的索引是从 1, (<code>1..Len(seq)</code> )开始的, 而不是从 0 开始.</p><p>在 TLA+ 中通用也有着 <code>Sequence</code> 模块, 如果使用了<code>EXTENDS Sequences</code>, 并且定义了 <code>S == &lt;&lt;&quot;a&quot;&gt;&gt;</code></p><table><thead><tr><th>表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>Append(S, &quot;b&quot;)</code></td><td><code>&lt;&lt;&quot;a&quot;, &quot;b&quot;&gt;&gt;</code></td></tr><tr><td><code>S \o &lt;&lt;&quot;b&quot;, &quot;c&quot;&gt;&gt;</code></td><td><code>&lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;</code></td></tr><tr><td><code>Head(S)</code></td><td><code>&quot;a&quot;</code></td></tr><tr><td><code>Tail(&lt;&lt;1, 2, 3&gt;&gt;)</code></td><td><code>&lt;&lt;2, 3&gt;&gt;</code></td></tr><tr><td><code>Len(S)</code></td><td><code>1</code></td></tr><tr><td><code>SubSeq(&lt;&lt;1, 3, 5&gt;&gt;, 1, 2)</code></td><td><code>&lt;&lt;1, 3&gt;&gt;</code></td></tr></tbody></table><p>在 TLA+ 中只支持一行 <code>EXTENDS</code>, 如果有多个模块需要导入, 那么就使用逗号分隔开.</p><p>通过 sequences, 我们可以使用 &lt;&lt;hour, minute, second&gt;&gt; 的形式来表达一个 24 小时制的时钟</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">EXTENDS Integers, Sequences<br><br><span class="hljs-function"><span class="hljs-title">ToSeconds</span><span class="hljs-params">(time)</span></span> == <span class="hljs-selector-tag">time</span><span class="hljs-selector-attr">[1]</span>*<span class="hljs-number">3600</span> + <span class="hljs-selector-tag">time</span><span class="hljs-selector-attr">[2]</span>*<span class="hljs-number">60</span> + <span class="hljs-selector-tag">time</span><span class="hljs-selector-attr">[3]</span><br><span class="hljs-function"><span class="hljs-title">Earlier</span><span class="hljs-params">(t1, t2)</span></span> == <span class="hljs-built_in">ToSeconds</span>(t1) &lt; <span class="hljs-built_in">ToSeconds</span>(t2)<br></code></pre></td></tr></table></figure><h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>一个 set 就是一个无序, 不同值的集合. 可以写成 <code>&#123;1, 2, 3&#125;</code>, 或者 <code>&#123;&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;, &quot;c&quot;&gt;&gt;&#125;</code>, 一个 set 甚至可以包含其它 set <code>&#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;&#125;</code>.</p><p>set 不可以包含不同类型的值, <code>&#123;1, &quot;a&quot;&#125;</code> 是无效的.</p><h3 id="set-算子"><a href="#set-算子" class="headerlink" title="set 算子"></a>set 算子</h3><p>为了检查 x 是 set 中的元素, 我们可以写 <code>x \in set</code>. \in 也可以在其它的一些场景使用, 而不仅做为一个算子. 当然也有反向的算子<code>\notin</code>. <code>set1 \subseteq set2</code> 测试 set1 中的每个元素是否都在 set2 中.</p><p>其它的一些算子</p><ul><li><code>set1 \union set2</code>: 表示 set1 和 set2 的并集</li><li><code>set1 \intersect set2</code>: 表示 set1 和 set2 的交集</li><li><code>set1 \ set</code> : 表示 set1 和 set2 的差集, 即仅存在与 set1 中的元素</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">&gt;&gt;&gt; </span><span class="hljs-template-variable">&#123;1, 3&#125;</span><span class="language-xml"> \union </span><span class="hljs-template-variable">&#123;1, 5&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1, 3, 5&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">&gt;&gt;&gt; </span><span class="hljs-template-variable">&#123;1, 3&#125;</span><span class="language-xml"> \intersect </span><span class="hljs-template-variable">&#123;1, 5&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">&gt;&gt;&gt; </span><span class="hljs-template-variable">&#123;1, 3&#125;</span><span class="language-xml"> \ </span><span class="hljs-template-variable">&#123;1, 5&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;3&#125;</span><br></code></pre></td></tr></table></figure><p>如果你导入了 FinitesSets 模块,  <code>EXTEND FiniteSets</code>, 那么就可以使用 <code>Cardinality(set)</code>算子来获取 set 中的元素数量.</p><h3 id="Sets-of-Values"><a href="#Sets-of-Values" class="headerlink" title="Sets of Values"></a>Sets of Values</h3><p>假设我们正在写一个 spec, 使用 clock 的值, 并且我们想要一个算子来快速计算并返回相加后的时间. 可能将它写为下面的形式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">AddTimes</span><span class="hljs-params">(t1, t2)</span></span> == &lt;&lt;t1<span class="hljs-selector-attr">[1]</span> + t2<span class="hljs-selector-attr">[1]</span>, t1<span class="hljs-selector-attr">[2]</span> + t2<span class="hljs-selector-attr">[2]</span>, t1<span class="hljs-selector-attr">[3]</span> + t2<span class="hljs-selector-attr">[3]</span>&gt;&gt;<br></code></pre></td></tr></table></figure><p>然后使用 <code>AddTimes(&lt;&lt;2, 0, 1&gt;&gt;, &lt;&lt;1, 2, 3&gt;&gt;) = &lt;&lt;3, 2, 4&gt;&gt;</code>, 和 <code>AddTimes(&lt;&lt;2, 0, 1&gt;&gt;,&lt;&lt;1, 2, 80&gt;&gt;) = &lt;&lt;3, 2, 81&gt;&gt;</code>.</p><p>这时我们发现不对了, 我们的时钟显示了 81 秒, 正确的答案应该是 &lt;&lt;3, 3, 21&gt;&gt;. 一个有效的时钟值集合应该是从 &lt;&lt;0, 0, 0&gt;&gt; 到 &lt;&lt;23, 23, 59&gt;&gt; 的, 并且 AddTime 返回的结果也是其中的值. </p><p>我们可以在 TLA+ 中强制这样, 但是首先我们需要一种从数值生成数值集的方法. 幸运的是, TLA+ 中的每种类型的值都是可以生成值的集合的.</p><p>首先从最简单的 boolean 类型的值开始, 需要获取所有布尔类型的值的集合, 直接写 <code>BOOLEAN</code> , 它代表 {TRUE, FALSE}. 对 Intergers 的来说, <code>a..b</code> 是集合 {a, a+1, a+2, …, b}. 需要 <code>EXTENDSIntegers</code> 来使它生效.</p><p>接下来是 Sequence, 两个集合 S 和 T 的笛卡儿乘积是所有序列的集合，其中第一个元素在 S 中，第二个元素在 T 中。例如，LoginAttempt 包含登录者、尝试登录的时间以及登录是否成功。我可以将所有可能值的集合表示为 <code>LoginAttempt == Person \X Time \X BOOLEAN</code>.</p><p>\X 不是相关联的.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">S == <span class="hljs-number">1.</span>.<span class="hljs-number">3</span><br><br>&gt;&gt; &lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt;&gt; <span class="hljs-string">\in</span> S <span class="hljs-string">\X</span> S <span class="hljs-string">\X</span> S<br>TRUE<br><br>&gt;&gt; &lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt;&gt; <span class="hljs-string">\in</span> (S <span class="hljs-string">\X</span> S) <span class="hljs-string">\X</span> S<br>FALSE<br><br>&gt;&gt; &lt;&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&gt;&gt;, <span class="hljs-number">3</span>&gt;&gt; <span class="hljs-string">\in</span> (S <span class="hljs-string">\X</span> S) <span class="hljs-string">\X</span> S<br>TRUE<br></code></pre></td></tr></table></figure><p>对于时钟类型来说, 我们可以使用 <code>\X</code> 和 <code>..</code> 来得到我们需要的类型.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ClockType</span> == (<span class="hljs-number">0</span>..<span class="hljs-number">23</span>) \X (<span class="hljs-number">0</span>..<span class="hljs-number">59</span>) \X (<span class="hljs-number">0</span>..<span class="hljs-number">59</span>)<br></code></pre></td></tr></table></figure><p>你会发现它有 86400 个元素。现在我们离 AddTimes 的属性又近了一步：我们希望 AddTimes 的结果总是返回 ClockType 的值。</p><h3 id="Map-Filter"><a href="#Map-Filter" class="headerlink" title="Map Filter"></a>Map Filter</h3><p>Set 可以被 map 以及 filter</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\*</span> <span class="hljs-built_in">Map</span><br>Squares == &#123;x*x: x <span class="hljs-string">\in</span> <span class="hljs-number">1.</span>.<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-string">\*</span> Filter<br>Evens == &#123;x <span class="hljs-string">\in</span> <span class="hljs-number">1.</span>.<span class="hljs-number">4</span>: x % <span class="hljs-number">2</span> = <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="CHOOSE"><a href="#CHOOSE" class="headerlink" title="CHOOSE"></a>CHOOSE</h3><p>从时钟值中获取午夜过后的秒数非常简单。但反过来呢？如果我们有一个以秒为单位的时间，我们可以通过以下方法得到时钟时间</p><ol><li><p>Floor 除以 3600，得到总小时数。</p></li><li><p>再用余数除以 60，得到总的分钟数。</p></li><li><p>将第二次除法的余数作为秒。</p></li></ol><p>这样就能从总秒数中构建出时钟值。这就是我们在编程语言中实现算法的方法。但这也容易出错。如果我输入 90,000 会怎样？这样就会得到 &lt;&lt;25, 0, 0&gt;&gt; - 一个不属于 ClockType 的值。</p><p>我们还可以这样做：</p><ol><li><p>获取所有可能的时钟值集合。</p></li><li><p>在集合中选择一个元素，将其转换为秒后，我们就得到了这个值。</p></li></ol><p>我们不会这样做，因为 “所有可能的时钟值集合 “长度超过 80,000 个元素，在 80,000 个元素的列表中进行查找会浪费资源。但这样做更符合转换的定义，使其对规范更有用。在 TLA+ 中，我们可以这样编写选择：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ToClock</span><span class="hljs-params">(seconds)</span></span> == CHOOSE x \<span class="hljs-keyword">in</span> ClockType: <span class="hljs-built_in">ToSeconds</span>(x) = seconds<br></code></pre></td></tr></table></figure><p><code>CHOOSE x \in set: P(x)</code> 是通用的 “选择 “语法.</p><p>当我们需要从一个集合中提取一个值时，CHOOSE 就会派上用场。</p><p>如果我们写 ToClock(86401) 会怎样？没有任何时钟时间有 86,401 秒。如果尝试这样做，TLC 将引发错误。这与实现方案截然不同，后者会给出一个无意义的值。99% 的情况下，如果找不到对应的集合元素，那就是规范中的错误，是你没有考虑到的边缘情况。最好是强化算子:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ToClock(seconds) == <span class="hljs-built_in">CHOOSE</span> x \i<span class="hljs-built_in">n</span> ClockTy<span class="hljs-symbol">pe:</span> ToSeconds(x) = seconds % <span class="hljs-number">86400</span><br></code></pre></td></tr></table></figure><h3 id="LET"><a href="#LET" class="headerlink" title="LET"></a>LET</h3><p>现在, 你可以想象到 TLA+ 的算子可以非常负责. 为了简化他们, 我们可以通过 LET 来将他们划分为不同的子算子</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">ToClock(seconds) ==<br>  LET seconds_per_day == <span class="hljs-number">86400</span><br>  IN <span class="hljs-built_in">CHOOSE</span> x \i<span class="hljs-built_in">n</span> ClockTy<span class="hljs-symbol">pe:</span> ToSeconds(x) = seconds % seconds_per_day<br></code></pre></td></tr></table></figure><p>LET 给我们提供了一个新定义，本地作用域为 ToClock。seconds_per_day 是一个操作符，只存在于这个定义中。</p><p>我们也可以在 LET 中添加参数化操作符！</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ThreeMax</span><span class="hljs-params">(a, b, c)</span></span> ==<br>   LET<br>     <span class="hljs-built_in">Max</span>(x, y) == IF x &gt; y THEN x ELSE y<br>   IN<br>     <span class="hljs-built_in">Max</span>(<span class="hljs-built_in">Max</span>(<span class="hljs-selector-tag">a</span>, b), c)<br></code></pre></td></tr></table></figure><p>你可以定义多个算子在一个 LET 中:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ThreeMax</span><span class="hljs-params">(a, b, c)</span></span> ==<br>   LET<br>     <span class="hljs-built_in">Max</span>(x, y) == IF x &gt; y THEN x ELSE y<br>     maxab == <span class="hljs-built_in">Max</span>(<span class="hljs-selector-tag">a</span>, b)<br>   IN<br>     <span class="hljs-built_in">Max</span>(maxab, c)<br></code></pre></td></tr></table></figure><p>LET 中的每个运算符都可以引用该范围内先前定义的运算符。这样，我们就可以逐步构建解决方案。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ToClock2(<span class="hljs-built_in">seconds</span>) ==<br>  LET<br>    h == <span class="hljs-built_in">seconds</span> \<span class="hljs-keyword">div</span> <span class="hljs-number">3600</span><br>    h_left == <span class="hljs-built_in">seconds</span> % <span class="hljs-number">3600</span><br>    m == h_left \<span class="hljs-keyword">div</span> <span class="hljs-number">60</span><br>    m_left == h_left % <span class="hljs-number">60</span><br>    s == m_left<br>  IN<br>    &lt;&lt;h, m, s&gt;&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TLA+</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 限制函数参数</title>
    <link href="/post/limit-param-range-in-go.html"/>
    <url>/post/limit-param-range-in-go.html</url>
    
    <content type="html"><![CDATA[<p>假设我们现在正在编写一个提供给外部使用的函数名 <code>Fn</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fn</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span>  &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Fn </code> 接受一个 int 型的值，要求 a 只能是 1, 3 ,5 其中的一个，该如何去限制呢。</p><p>最简单的方式就是增加一段判断，在不符合要求时返回错误，就像下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IPAddr</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">switch</span> a &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>:<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;a should be 1,3,5&quot;</span>)<br>  &#125;<br>  <span class="hljs-comment">// do some</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样的处理不仅只能在运行时检查，而且新增了错误返回，外部调用时需要检查 err。我们不喜欢 <code>if err != nil &#123;&#125;</code>, 也不想在新增一种情况时，就在 case 后面新增一个值，直到它变成一条贪吃蛇。</p><p>那有没有什么办法能够在编译时就能检查出给定的值是否符合要求。</p><p>答案是有的，就像下面这段代码这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> enum <span class="hljs-keyword">struct</span> &#123;<br>  i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>  One = enum&#123;<span class="hljs-number">1</span>&#125;<br>  Three = enum&#123;<span class="hljs-number">3</span>&#125;<br>  Five = enum&#123;<span class="hljs-number">5</span>&#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fn</span><span class="hljs-params">(a enum)</span></span>  &#123;<br><span class="hljs-comment">// do something</span><br>  <span class="hljs-comment">// a.i</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个私有的类型 <code>enum</code>, 将 Fn 的参数类型设置为它。同时定义了 <code>One</code>, <code>Three</code>, <code>Five</code> 三个变量来代表 1， 3，5 这三个值，在 Fn 中获取 enum.i 来获取对应的值。</p><p>由于 <code>enum</code> 是私有类型，在外部不可以使用，在调用 Fn 时只能使用我们定义好的  <code>One</code>, <code>Three</code>, <code>Five</code>  来传递参数。通过这种方式，我们将函数的参数的范围限制在了 我们想要的范围内，同时避免了增加额外的逻辑判断。在编译时就能确定调用的方式是否正确。</p><p>可能你想问，这里为什么将 <code>enum</code> 定义为 struct， 而不是 int 的衍生类型。这是因为，如果我们将 <code>enum</code> 定义为 int ，调用方是可以通过直接传递字面量来绕过我们的限制的。就像下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> enum2 <span class="hljs-type">int</span><br><br><span class="hljs-keyword">var</span> EOne enum2 = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fn2</span><span class="hljs-params">(a enum2)</span></span> &#123;<br>Fn2(EOne)<br>Fn2(<span class="hljs-number">7</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这段代码，会打印出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>7<br></code></pre></td></tr></table></figure><p> 这并不是我们想要的结果，因此我们将 enum 定义为 struct， 而不是 int，从而防止调用方通过传递字面量的方式来绕过我们的检查。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLA+，概念初识</title>
    <link href="/post/tla-conceptual-overview.html"/>
    <url>/post/tla-conceptual-overview.html</url>
    
    <content type="html"><![CDATA[<p>假设我们正在为银行构建一项电汇服务。用户可以向其他用户进行转账。作为要求，我们不允许任何可能使用户账户透支或余额降至零以下的转账。在高层次上，代码可能如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">def transfer(<span class="hljs-keyword">from</span>, <span class="hljs-keyword">to</span>, amount)<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.balance &gt;= amount) <span class="hljs-comment"># guard</span><br><span class="hljs-keyword">from</span>.balance -= amount;  <span class="hljs-comment"># withdraw</span><br>  <span class="hljs-keyword">to</span>.balance += amount;   <span class="hljs-comment"># deposit</span><br></code></pre></td></tr></table></figure><p>上面的代码可以满足要求：当你你试图转账超过你拥有的金额，该防护机制将阻止你。</p><p>现在考虑两个变化：</p><ol><li>用户可以同时发起多个转账。</li><li>转账步骤是不可中断的。一个转账可以开始并（可能）完成，而另一个转账仍在进行中。</li></ol><p>这两个改变单独来看都不会引起问题。但两者结合起来可能导致可能的竞争条件：</p><ol><li>Alice 的账户有 6 美元，并向 Bob 发起了两笔转账。转账 X 金额为 3 美元，转账 Y 金额为 4 美元。</li><li>Guard(X) 运行。因为 3 &lt; 6，我们继续执行 Withdraw(X)。</li><li>在 Withdraw(X) 发生之前，Guard(Y) 运行。因为 4 &lt; 6，我们继续执行 Withdraw(Y)。</li><li>两次提款都执行了，从 Alice 的账户中取走了 7 美元，使她的余额变成 -1。</li></ol><p>如果 Withdraw(X) 在 Guard(Y) 之前发生，那么就不会有问题；转账 Y 将会简单失败。这种竞争条件基本上很少出现：大多数情况下，程序会按预期行为并维护我们的属性。只有在特定事件顺序下才会出现 bug。这就是为什么并发错误很难发现。</p><p>这也是为什么它们难以修复。想象一下，如果我们添加了第三个功能，比如在正确的位置加锁来修复 bug。问题是否消失是因为我们解决了它，还是因为我们使它变得更少见了？如果不能探索设计的实际后果，我们就不能保证已经解决了任何问题。</p><p>因此，TLA+ 的目的是通过程序化探索这些设计问题。我们想要为工具提供一个系统和一个要求，它可以告诉我们是否违反了要求。如果可以，那么我们知道需要改变我们的设计。如果不能，我们就可以更有信心地认为我们是正确的。</p><p>TLA+ 的概念架构由三个部分组成.</p><p>首先, 我们需要去描述系统以及它可以做什么. 这被称之为规范(specification, spec).</p><p>我们的设计可能是这样的:</p><ol><li>我们有一组账户. 每个账户都有一个数字, 代码账户余额</li><li>任何账户都可以尝试向其它任何账户转账任意金额的资金</li><li>转账首先检查是否有足够的资金. 如果有, 金额将从第一个账户扣除, 并添加到第二个账户</li><li>转账是不可中断的, 可以同时发生多笔转账</li></ol><p>规范具有一组“行为”，或者说是可能的不同执行方式。对于规范的正确性，每个行为都必须满足我们系统的所有要求或<strong>属性</strong>。”没有账户可以透支” 就是一个属性示例，如果规范的某个行为在一个状态下存在账户余额为负数，就违反了这个属性。其他所有可能的行为没有透支是不重要的。我们正在寻找罕见的设计错误，所以只要有一个违反就足够了。</p><p>“任何账户都不能透支 “是一个不变的属性，是每个行为的每个状态都必须成立的属性。</p><p>一旦我们编写了规范和属性，就可以将它们输入 “模型检查器”(model checker)。模型检查器接收规范，生成每一种可能的行为，并查看它们是否都满足我们的所有属性。如果有一个不满足，它就会返回一个 “错误跟踪”，显示如何重现违规行为。TLA+ 有几种不同的模型检查器，但最常用的是 TLC，它与工具箱捆绑在一起。除非我另有说明，否则当我谈到模型检查器时，我指的就是 TLC。</p><p>现在，我们无法检查所有可能的行为。事实上，由于我们还可以在系统中添加更多账户和转账，因此这些行为的数量是无限的。因此，我们要检查某些限制条件下的所有行为，例如 “三个账户的所有行为，每个账户最多 10 美元，以及两次转账，每次转账最多 10 美元”。我们将这组运行时参数以及我们所做的所有其他模型检查配置称为模型。</p><p>这意味着通过模型并不能保证规格正确。也许只有在参数较大时才会出现错误。但根据经验，我们在规范中发现，大多数错误都出现在很小的范围内：如果一个系统能在 3 个 worker 的情况下工作，那么它也很可能能在 25 个worker的情况下工作。</p><p>那么，这一切在实践中是什么样的呢？让我们来介绍一下电汇的规范，首先是硬编码参数，然后是模型参数化参数。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs livescript">---- MODULE wire ----<br>EXTENDS TLC, Integers<br><br>People == &#123;<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;bob&quot;</span>&#125;<br>Money == <span class="hljs-number">1.</span>.<span class="hljs-number">10</span><br>NumTransfers == <span class="hljs-number">2</span><br><br>(* --algorithm wire<br>variables<br>  acct <span class="hljs-string">\in</span> [People -&gt; Money];<br><br>define<br>  NoOverdrafts ==<br>    <span class="hljs-string">\A</span> p <span class="hljs-string">\in</span> People:<br>      acct[p] &gt;= <span class="hljs-number">0</span><br>end define;<br><br>process wire <span class="hljs-string">\in</span> <span class="hljs-number">1.</span>.NumTransfers<br>variable<br>  amnt <span class="hljs-string">\in</span> <span class="hljs-number">1.</span>.<span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">from</span> <span class="hljs-string">\in</span> People;<br>  <span class="hljs-keyword">to</span> <span class="hljs-string">\in</span> People<br>begin<br>  Check:<br>    <span class="hljs-keyword">if</span> acct[<span class="hljs-keyword">from</span>] &gt;= amnt <span class="hljs-keyword">then</span><br>      Withdraw:<br>        acct[<span class="hljs-keyword">from</span>] := acct[<span class="hljs-keyword">from</span>] - amnt;<br>      Deposit:<br>        acct[<span class="hljs-keyword">to</span>] := acct[<span class="hljs-keyword">to</span>] + amnt;<br>    end <span class="hljs-keyword">if</span>;<br>end process;<br>end algorithm; *)<br><br>====<br></code></pre></td></tr></table></figure><p>解释下上面的代码：</p><ul><li>定义使用 <code>==</code></li><li><code>People</code> 和 <code>Money</code> 是集合，是唯一且无序值的集合。编程语言大多使用数组和 map（分别是序列和结构），而集合在规范中的基础性更强。</li><li><code>[People -&gt; Money]</code> 也是一个集合（这里是函数集合）。它代表了所有可能的人与钱的分配：Alice 有 5 美元，Bob 有 1 美元；Alice 有 10 美元，Bob 有 6 美元，等等。</li><li>变量 <code>acct</code> 并不是一个固定值，而是 100 个不同值中的一个，<code>[People -&gt; Money]</code> 的每个元素都有一个。当我们对此进行建模检查时，TLC 将从这 100 个可能的初始值中的每一个开始，探索每一种可能的行为。</li><li><code>NoOverdrafts</code> 是一个量词(<a href="https://learntla.com/core/invariants.html#a">quantifier</a>)。如果每个账户都 &gt;= 0，则为 true，否则为 false。在 Python 中，这可能等同于 <code>all([acct[p] &gt;= 0 for p in People])</code>。量词是 TLA+ 的一个非常强大的功能，可以轻松编写非常复杂的属性。</li><li>我们有多个转账进程同时运行。当 <code>NumTransfers == 2</code> 时，规格中有两个进程。但如果我们愿意，可以选择十个、一百个或一千个进程，限制因素只有我们的耐心和内存。</li><li>算法的每一步都属于一个单独的标签(label)。标签决定了哪些是原子发生的，哪些是可以被其他进程打断的。这样，我们就可以表示竞赛条件。</li></ul><p>设计完成后，我们可以根据一些要求对其进行模型检查。我们可以建立一个模型，然后说 “NoOverdrafts “是一个不变量。然后，运行模型将检查系统演化的每一种可能方式。如果其中任何一种方式导致 NoOverdrafts 为 false，那么模型检查程序就会引发错误。</p><p>我们用两次转账进行了检查。但如果我们想用四次转印来检查呢？TLA+ 可以让我们轻松改变设计。我们可以设置任何参数值，然后让不同的模型使用不同的值进行检查。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">---- MODULE wire ----</span><br> EXTENDS TLC, Integers<br><span class="hljs-deletion">-</span><br><span class="hljs-deletion">-People == &#123;&quot;alice&quot;, &quot;bob&quot;&#125;</span><br><span class="hljs-deletion">-Money == 1..10</span><br><span class="hljs-deletion">-NumTransfers == 2</span><br><span class="hljs-addition">+CONSTANTS People, Money, NumTransfers</span><br> <br> (* --algorithm wire<br> variables<br></code></pre></td></tr></table></figure><p>现在，我可以制作不同的模型，具有相同的不变量，但同时转账的次数不同。因此，我可以看到它在一次转账时工作正常，但在两次转账时就不正常了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TLA+</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解构类型参数</title>
    <link href="/post/deconstruction-type-parameters.html"/>
    <url>/post/deconstruction-type-parameters.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章是对 Go 官方博客 <a href="https://go.dev/blog/deconstructing-type-parameters">Deconstructing Type Parameters</a> 的翻译. 所使用的 Go 版本为 1.21.</p><h2 id="Slice-包的函数签名"><a href="#Slice-包的函数签名" class="headerlink" title="Slice 包的函数签名"></a>Slice 包的函数签名</h2><p><a href="https://pkg.go.dev/slices#Clone">slice.Clone</a> 函数非常的简单，它复制了任何类型的 slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone</span>[<span class="hljs-title">S</span> ~[]<span class="hljs-title">E</span>, <span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s S)</span></span> S &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(s[:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>], s...)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法是可行的, 因为向零容量的 slice 追加元素会分配一个新的底层数组。我们可以看到函数体的长度竟然比函数签名还要短,这不仅因为函数体本身很简短,也因为签名有点长。在这篇博文中,我们将解释为什么签名是这样写的。</p><h2 id="简单的复制"><a href="#简单的复制" class="headerlink" title="简单的复制"></a>简单的复制</h2><p>我们来先写一个简单的泛型 <code>Clone</code> 函数。这不是 <code>slices</code> 包中的那个。我们想要一个可以接受任意元素类型的 slice,并返回一个新的 slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone1</span>[<span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []E)</span></span> []E &#123;<br>    <span class="hljs-comment">// body omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>带有单个类型参数<code>E</code>的泛型函数<code>Clone1</code>有一个参数<code>s</code>,它是一个<code>E</code>类型的 slice,并返回同样类型的 slice。对于熟悉 Go 泛型的人来说,这个签名很简单明了。</p><p>然而,这里有一个问题。在 Go 中命名的 slice 类型不常见, 但确实有人在使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MySlice is a slice of strings with a special String method.</span><br><span class="hljs-keyword">type</span> MySlice []<span class="hljs-type">string</span><br><br><span class="hljs-comment">// String returns the printable version of a MySlice value.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s MySlice)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strings.Join(s, <span class="hljs-string">&quot;+&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们现在想要复制一个 <code>MySlice</code>, 然后获取其可打印版本, 但是字符串按排序顺序排列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintSorted</span><span class="hljs-params">(ms MySlice)</span></span> <span class="hljs-type">string</span> &#123;<br>    c := Clone1(ms)<br>    slices.Sort(c)<br>    <span class="hljs-keyword">return</span> c.String() <span class="hljs-comment">// FAILS TO COMPILE</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不幸的是这段代码无法正常工作，编译器会给出错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c.String undefined (<span class="hljs-keyword">type</span> []<span class="hljs-type">string</span> has no field or method String)<br></code></pre></td></tr></table></figure><p>如果我们手动实例化 <code>Clone1</code>,  用类型参数替换类型实参,就可以看到问题所在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InstantiatedClone1</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>Go 的<a href="https://go.dev/ref/spec#Assignability">赋值规则</a>允许我们将 <code>MySlice</code> 类型的值传递给 <code>[]string</code> 类型的参数,所以调用 <code>Clone1</code> 没问题。但是 <code>Clone1</code> 会返回一个 <code>[]string</code> 类型的值,而不是 <code>MySlice</code> 类型的值。<code>[]string</code> 类型没有 <code>String</code> 方法,所以编译器会报错。</p><h2 id="灵活的复制"><a href="#灵活的复制" class="headerlink" title="灵活的复制"></a>灵活的复制</h2><p>为了解决这个问题, 我们必须编写一个版本的<code>Clone</code>, 它返回与其参数相同类型的值。如果我们能做到这一点, 那么当我们使用 <code>MySlice</code> 类型的值调用 <code>Clone</code> 时, 它将返回 <code>MySlice</code> 类型的结果。</p><p>我们知道它的样子大致如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone2</span>[<span class="hljs-title">S</span> ?]<span class="hljs-params">(s S)</span></span> S <span class="hljs-comment">// INVALID</span><br></code></pre></td></tr></table></figure><p>这个 <code>Clone2</code> 函数返回与其参数相同类型的值。</p><p>这里我用 <code>?</code> 写了一个约束条件, 但是那只是一个占位符。为了使这个函数工作, 我们需要编写一个约束条件, 以便编写函数体。对于 <code>Clone1</code>,我们可以对元素类型使用 <code>any</code> 约束。但对于 <code>Clone2</code> 这行不通: 我们需要 <code>s</code> 是 slice 类型。</p><p>由于我们知道需要一个 slice,所以 <code>S</code> 的约束条件必须是一个 slice。我们不关心 slice 元素类型是什么,所以像在 <code>Clone1</code> 中一样,我们称它为 <code>E</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone3</span>[<span class="hljs-title">S</span> []<span class="hljs-title">E</span>]<span class="hljs-params">(s S)</span></span> S <span class="hljs-comment">// INVALID</span><br></code></pre></td></tr></table></figure><p>这仍然无效,因为我们还没有声明 <code>E</code>。<code>E</code> 的类型参数可以是任何类型, 这意味着它本身也必须是一个类型参数。由于它可以是任何类型,所以它的约束条件是 <code>any</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone4</span>[<span class="hljs-title">S</span> []<span class="hljs-title">E</span>, <span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s S)</span></span> S<br></code></pre></td></tr></table></figure><p>这已经很接近了,至少它可以编译通过, 但我们还没完全搞定。如果我们编译这个版本, 在调用 <code>Clone4(ms)</code> 时会产生错误。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MySlice <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> satisfy []<span class="hljs-built_in">string</span> (possibly missing ~ <span class="hljs-keyword">for</span> []<span class="hljs-built_in">string</span> <span class="hljs-keyword">in</span> []<span class="hljs-built_in">string</span>)<br></code></pre></td></tr></table></figure><p>编译器告诉我们,不能为类型参数 <code>S</code> 使用类型实参 <code>MySlice</code>,因为 <code>MySlice</code> 不满足约束条件 <code>[]E</code>。这是因为作为约束条件的 <code>[]E</code> 只允许字面量 slice 类型,如 <code>[]string</code>。它不允许命名类型如 <code>MySlice</code>。</p><h2 id="基础类型约束"><a href="#基础类型约束" class="headerlink" title="基础类型约束"></a>基础类型约束</h2><p>正如错误消息所暗示的,答案是添加一个 <code>~</code> 符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone5</span>[<span class="hljs-title">S</span> ~[]<span class="hljs-title">E</span>, <span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s S)</span></span> S<br></code></pre></td></tr></table></figure><p>再重复一遍,编写类型参数和约束条件 <code>[S []E, E any]</code> 意味着 <code>S</code> 的类型实参可以是任何未命名的 slice 类型, 但不能是定义为 slice 字面量的命名类型。</p><p>编写 <code>[S ~[]E, E any]</code>, 带有 <code>~</code> 符号,意味着 <code>S</code> 的类型实参可以是任何基础类型为 slice 类型的类型。</p><p>对于任何命名类型 <code>type T1 T2</code>,<code>T1</code> 的基础类型就是 <code>T2</code> 的基础类型。预声明类型如 <code>int</code> 或字面量类型如 <code>[]string</code> 的基础类型就是它们自己。详细信息请参阅语言规范。在我们的示例中, <code>MySlice</code> 的基础类型是 <code>[]string</code>。</p><p>由于 <code>MySlice</code> 的基础类型是一个 slice, 所以我们可以将 <code>MySlice</code> 类型的参数传递给 <code>Clone5</code>。你可能已经注意到, <code>Clone5</code> 的签名与 <code>slices.Clone</code> 的签名相同。我们终于得到了我们想要的结果。</p><p>在继续之前,让我们讨论一下为什么 Go 语法要求使用 <code>~</code>。可能看起来我们总是希望允许传递 <code>MySlice</code>,那么为什么不将其作为默认值呢?或者,如果我们需要支持精确匹配,为什么不把事情翻转过来,使得约束条件 <code>[]E</code> 允许命名类型,而约束条件 <code>=[]E</code> 仅允许 slice 类型字面量?</p><p>为了解释这一点, 我们先观察到像 <code>[T ~MySlice]</code> 这样的类型参数列表是没有意义的。这是因为 <code>MySlice</code> 不是任何其他类型的基础类型。</p><p>例如, 如果我们有这样的定义 <code>type MySlice2 MySlice</code>, 那么 <code>MySlice2</code> 的基础类型是 <code>[]string</code>, 而不是 <code>MySlice</code>。因此, <code>[T ~MySlice]</code> 要么根本不允许任何类型, 要么与 <code>[T MySlice]</code> 相同, 仅匹配 <code>MySlice</code>。无论哪种方式, <code>[T ~MySlice]</code> 都没有用。为了避免这种困惑, 语言禁止 <code>[T ~MySlice]</code>, 编译器会产生像下面这样的错误</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">invalid <span class="hljs-keyword">use</span> <span class="hljs-keyword">of</span> ~ (underlying <span class="hljs-keyword">type</span> <span class="hljs-type">of </span>MySlice <span class="hljs-keyword">is</span> []string)<br></code></pre></td></tr></table></figure><p>如果 Go 不要求波浪号, 所以 <code>[S []E]</code> 会匹配任何基础类型为 <code>[]E</code> 的类型, 然后我们就不得不定义 <code>[S MySlice]</code> 的含义。</p><p>我们可以禁止 <code>[S MySlice]</code>, 或者说 <code>[S MySlice]</code> 只匹配 <code>MySlice</code>,但这两种方法在预声明类型上都会遇到问题。预声明类型, 如 <code>int</code> 是它自己的基础类型。我们希望人们能够编写接受任何基础类型为 <code>int</code> 的类型参数的约束条件。在现有的语言中, 他们可以通过编写 <code>[T ~int]</code> 来实现这一点。如果我们不要求波浪号, 我们仍然需要一种方法来表示“任何基础类型为 <code>int</code> 的类型”。最自然的表达方式就是 <code>[T int]</code>。这意味着 <code>[T MySlice]</code> 和 <code>[T int]</code> 的行为会有所不同, 尽管它们看起来非常相似。</p><p>我们可能会说 <code>[S MySlice]</code> 匹配任何基础类型是 <code>MySlice</code> 的基础类型的类型,但这使得 <code>[S MySlice]</code> 变得不必要且令人困惑。</p><p>我们认为要求使用 <code>~</code> 并非常清楚地表示我们是在匹配基础类型而不是类型本身是更好的选择。</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>现在我们已经解释了 <code>slices.Clone</code> 的签名, 让我们看看如何通过类型推断简化实际使用 <code>slices.Clone</code>。请记住, <code>Clone</code> 的签名是:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone</span>[<span class="hljs-title">S</span> ~[]<span class="hljs-title">E</span>, <span class="hljs-title">E</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s S)</span></span> S<br></code></pre></td></tr></table></figure><p>调用 <code>slices.Clone</code> 会将一个 slice 传递给参数 <code>s</code>。简单的类型推断将允许编译器推断类型参数 <code>S</code> 的类型实参是传递给 <code>Clone</code> 的 slice 的类型。然后, 类型推断足够强大, 可以看出类型参数 <code>E</code> 的类型实参是传递给 <code>S</code> 的类型实参的元素类型。</p><p>这意味着我们可以写:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := Clone(ms)<br></code></pre></td></tr></table></figure><p>而不必写:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := Clone[MySlice, <span class="hljs-type">string</span>](ms)<br></code></pre></td></tr></table></figure><p>如果我们引用 <code>Clone</code> 而不调用它, 我们确实需要为 <code>S</code> 指定一个类型实参, 因为编译器没有任何可以用于推断的信息。幸运的是, 在这种情况下, 类型推断能够从 <code>S</code> 的实参中推断出 <code>E</code> 的类型实参, 所以我们不必单独指定它。</p><p>也就是说,我们可以写:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myClone := Clone[MySlice]<br></code></pre></td></tr></table></figure><p>而不必写:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myClone := Clone[MySlice, <span class="hljs-type">string</span>]<br></code></pre></td></tr></table></figure><p>我们在这里使用的通用技术是使用另一个类型参数 E 来定义一个类型参数 S，这是一种在泛型函数签名中解构类型的方法。通过解构类型，我们可以对类型的各个方面进行命名和约束。</p><p>例如，以下是 maps.Clone 的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clone</span>[<span class="hljs-title">M</span> ~<span class="hljs-title">map</span>[<span class="hljs-title">K</span>]<span class="hljs-title">V</span>, <span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(m M)</span></span> M<br></code></pre></td></tr></table></figure><p>与 slices.Clone 一样，我们使用类型参数来指定参数 m 的类型，然后使用另外两个类型参数 K 和 V 来解构类型。 在 maps.Clone 中，我们将 K 约束为可比较的，因为这是 map 键类型所必需的。我们可以根据需要以任何方式约束基础类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStrings</span>[<span class="hljs-title">S</span> ~[]<span class="hljs-title">E</span>, <span class="hljs-title">E</span> <span class="hljs-title">interface</span></span> &#123; String() <span class="hljs-type">string</span> &#125;](s S) (S, []<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>这意味着 <code>WithStrings</code> 的参数必须是一个元素类型具有 <code>String</code> 方法的切片类型。</p><p>由于所有 Go 类型都可以从基础类型构建，因此我们可以始终使用类型参数来解构这些类型并根据需要对其进行约束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commands out of sync. Did you run multiple statements at once?</title>
    <link href="/post/go-driver-conn-issue.html"/>
    <url>/post/go-driver-conn-issue.html</url>
    
    <content type="html"><![CDATA[<p>Go 的 mysql 驱动库 <a href="https://github.com/go-sql-driver/mysql.git">github.com/go-sql-driver/mysql</a> 在连接数据库时，有时会产生一个奇怪的错误</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-comment">&quot;commands out of sync. Did you run multiple statements at once?&quot;</span><br></code></pre></td></tr></table></figure><p>这个错误的字面意思是同一时刻执行了多个 SQL 语句。咋看上会让人感到很迷惑，特别是这个错误有可能发生在数据建立连接时。</p><p>例如下面这段代码也会遇到相同的错误信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br>_ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  db, err := sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user:password@/dbname&quot;</span>)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// panic，返回上面的错误</span><br>  &#125;<br>  <span class="hljs-keyword">defer</span> db.Close()<br>  db.Ping()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们只是建立连接，还没有执行语句就发生了错误。说明错误产生的原因并不是像错误本身信息描述的那样。</p><p>为了了解这个错误产生的原因，我们打开它的源码，查找错误出现的原因。首先使用 <code>rg </code>  命令从代码中搜索这段文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rg -t go &quot;commands out of sync. Did you run multiple statements at once?&quot;<br></code></pre></td></tr></table></figure><p>根据返回的结果，可以看到这是一个在 <a href="https://github.com/go-sql-driver/mysql/blob/a4c260b40eeb51bd823d8b04d0e0e8d072e56adf/errors.go#L29">errors.go</a> 中预定义好的错误。</p><p>找到这个错误之后，我们来看下这个错误是在哪被使用的。继续查找 <code> ErrPktSyncMul</code> 这个关键字，发现是在 <a href="https://github.com/go-sql-driver/mysql/blob/a4c260b40eeb51bd823d8b04d0e0e8d072e56adf/packets.go#L49">packets.go</a> 中使用的， 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mc *mysqlConn)</span></span> readPacket() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <br>  <span class="hljs-comment">// check packet sync [8 bit]</span><br>  <span class="hljs-keyword">if</span> data[<span class="hljs-number">3</span>] != mc.sequence &#123;<br>    mc.Close()<br>    <span class="hljs-keyword">if</span> data[<span class="hljs-number">3</span>] &gt; mc.sequence &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrPktSyncMul<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrPktSync<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中, 客户端从网络连接中读取了 mysql 服务返回的数据包，发现数据包头的 sync 信息与已经读取的 sequence 不相等，并且大于当前 sequence 的，于是认为产生了多语句执行。</p><p>但是，我们的情况并不是执行语句，而是在一开始建立连接就失败了，继续查看源码，发现在 Open 的时候，驱动会与数据库握手，同时调用 readPacket 从连接中读取数据包。</p><p>猜测是与服务端通信出现了问题，搜索相关的 issue，发现了和我们情况类似的问题 <a href="https://github.com/go-sql-driver/mysql/issues/1038">issue #1038</a>。根据 issue 所描述，<strong>当 mariadb  服务端拒绝与当前客户端通信时就会出现这个错误</strong>。而根据下面的评论，这个错误有可能会因为特定的 mariadb  版本引发，因为 mysql 的服务端实现有 bug。mariadb 的开发者，在<a href="https://github.com/go-sql-driver/mysql/issues/1038#issuecomment-1011499346">评论中</a>回答道问题已经修复了。</p><p>到这里，我们终于弄清了这个错误出现的原因，并不是由于我们执行了多行语句，而是因为我们与服务端的通信被拒绝了，错误信息迷惑了我们。</p><p>因此，当连接 mysql 时出现了这个错误，可以按照下面的方式去排查</p><ol><li>查看 mysql 的服务版本是不是存在 bug 的版本，如果是的，那么就需要升级服务版本</li><li>查看 mysql 是否达到了错误连接数的上限，如果是的，可以修改服务端配置，调大连接数，FLUSH HOSTS， 再尝试重新连接</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft 日志复制</title>
    <link href="/post/raft-log-replica.html"/>
    <url>/post/raft-log-replica.html</url>
    
    <content type="html"><![CDATA[<p>在上一篇的内容中，我们学习了 raft 的 Leader 选举。在这一篇中，我们将学习 raft 的日志复制。</p><p>在 raft 算法中，副本数据是以日志（Log）的形式存在的。在收到来自客户端的信息后，Leader 会复制日志到 Follower，并 Apply 到状态机。</p><h3 id="日志是什么"><a href="#日志是什么" class="headerlink" title="日志是什么"></a>日志是什么</h3><p>日志是由日志项组成的，每个日志项代表一条数据操作命令。</p><p>日志项的格式分为三个部分，分别是</p><ul><li><p>Index: 日志项的索引，标志日志项在所有日志中的位置。单调并且连续自增</p></li><li><p>Term:  提交日志项的 Leader 的任期</p></li><li><p>Command: 客户端请求的数据变更指令，会交由状态机执行。可以看作是客户端提交的数据</p></li></ul><h3 id="日志是如何复制的"><a href="#日志是如何复制的" class="headerlink" title="日志是如何复制的"></a>日志是如何复制的</h3><p>首先是客户端发起一个数据变更的请求，例如新增一条数据。Leader 收到请求后，追加日志项到日志中，发送 ApplyEntries 的 RPC 信息到 Follower。</p><p>然后，在收到大多数的 Follower 确认的响应后，并 Apply 到状态机。如果没有得到大多数 Follower 的成功响应，那么就会返回错误给客户端。</p><p>最后，对于 Follower 来说，当接受到来自 Leader 的 ApplyEntries 信息后，就会将日志项应用到状态机，而不需要 Leader 再次发送信息要求 Follower 应用日志。Follower 只需通过 ApplyEntries 和心跳消息就能知道当前 Leader 的最大 Index。</p><p>在理想情况下，集群的日志是一致的。但是在网络故障，节点宕机等特殊情况下，集群的节点日志可能出现不一致的情况。此时，raft 算法会通过其他的方式来保证日志的一致性。</p><h3 id="日志一致性的保证"><a href="#日志一致性的保证" class="headerlink" title="日志一致性的保证"></a>日志一致性的保证</h3><p>首先就是 raft 算法的核心，一切以 Leader 为主。Leader 会强制要求 Follower 复制自身的日志。</p><p>当出现日志不一致的情况时，Leader 会找到 Follower 节点上与自己日志相同的最大索引值 IndexA，然后从 IndexA+1 处开始发送日志给 Follower。Follower 在收到信息后，会强制更新覆盖日志。</p><p>Leader 在发送需要复制的日志时，会携带两个变量</p><ul><li>PrevLogEntry：表示当前要复制的日志项，前面一条日志项的索引值</li><li>PrevLogTerm：当前要复制的日志项，前面一条日志项的任期</li></ul><p>Follower 在收到 Leader 的信息后，会检查日志，查看是否有 <code>Index == PrevLogEntry &amp;&amp; Term == PreLogTerm</code> 的日志项。</p><p>如果不存在符合条件的日志项，那么 Follower 就会返回一个错误给 Leader。Leader 会递减需要复制的日志项，重新发送给 Follower。</p><p>一直重复上述过程，直到找到符合条件的 PrevLogEntry 和 PrevLogTerm 日志位点 P‘。</p><p>Leader 根据找到的位点，从 P‘ 后开始发送复制日志的信息，Follower 更新覆盖 P‘ 自身的日志。</p><p>通过这种方式，raft 实现了日志的一致性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft Leader 选举</title>
    <link href="/post/raft-leader-election.html"/>
    <url>/post/raft-leader-election.html</url>
    
    <content type="html"><![CDATA[<p>raft 协议是当前分布式系统开发的首选共识算法。raft 协议是一个一切以领导者为主，实现一系列值的共识和节点日志的一致性。</p><p>raft 协议将共识问题拆分成三个子问题</p><ol><li>Leader 选举，Leader 故障后集群能快速选出新 Leader；</li><li>日志复制， 集群只有 Leader 能写入日志， Leader 负责复制日志到 Follower 节点，并强制 Follower 节点与自己保持相同；</li><li>安全性，一个任期内集群只能产生一个 Leader、已提交的日志条目在发生 Leader 选举时，一定会存在更高任期的新 Leader 日志中、各个节点的状态机应用的任意位置的日志条目内容应一样等</li></ol><p>首先介绍下 Raft 的 Leader 选举流程</p><p>Leader 是集群中的独裁者，当 Leader 发布 <code>A=3</code> 的命令时，其余的节点都将会追加最新的 <code>A=3</code> 的指令到自身的日志中。</p><p>因此，一个集群中只能有一个 Leader，由唯一的 Leader 发出指令。这里我将会介绍 raft 是如何在一个多节点的集群中选出 Leader 的。</p><h3 id="成员身份"><a href="#成员身份" class="headerlink" title="成员身份"></a>成员身份</h3><p>在介绍选举算法前，先介绍下集群中节点的身份有哪几种。在 raft 集群中，节点的身份有三种，分别是 <strong>Leader</strong>，<strong>Candidate</strong> 和 <strong>Follower</strong>。</p><ul><li><p>Follower:  接收和处理来自 Leader 的信息，当 Leader 的心跳超时时，成为 Candidate</p></li><li><p>Candidate: 向其他节点发送 RequestVote 的 RPC 请求，通知其他节点投票，当得票数超过 2/3 时成为 Leader</p></li><li><p>Leader: 负责处理写请求，管理日志的复制（AppendEntries）和不断发送心跳消息，通知其他节点 Leader 还是存活的</p></li></ul><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>首先，在初始节点，集群的所有节点都是 Follower。每个节点都有一个随机的心跳超时时间。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>: <span class="hljs-number">150</span>ms, Term:<span class="hljs-number">0</span><br><span class="hljs-attribute">B</span>: <span class="hljs-number">200</span>ms, Term:<span class="hljs-number">0</span><br><span class="hljs-attribute">C</span>: <span class="hljs-number">250</span>ms, Term:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>A 会最先因为没有等到 Leader 心跳信息而发生超时，此时，A 会将自己的任期（Term）增加 1，成为 Candidate，为自己投一票，然后向其他的节点发送 RequestVote。</p><p>B，C 收到 A 的投票请求，并且它们在没有在 Term1 投过票，那么它们就会给 A 投票，同时将自己的任期加 1.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>: <span class="hljs-number">150</span>ms, Term:<span class="hljs-number">1</span><br><span class="hljs-attribute">B</span>: <span class="hljs-number">200</span>ms, Term:<span class="hljs-number">1</span><br><span class="hljs-attribute">C</span>: <span class="hljs-number">250</span>ms, Term:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在投票超时时间内（每次投票的超时时间也是随机的），A 获得了半数的投票，A 成为了本届任期的新 Leader。并向其他节点发送心跳消息。</p><h3 id="什么是任期"><a href="#什么是任期" class="headerlink" title="什么是任期"></a>什么是任期</h3><p>raft 将时间划分成一个个任期，任期用连续的整数表示，每个任期从一次选举开始，赢得选举的节点在该任期内充当 Leader 的职责，随着时间的消逝，集群可能会发生新的选举，任期号也会单调递增。</p><p>通过任期号，可以比较各个节点的数据新旧、识别过期的 Leader 等，它在 Raft 算法中充当逻辑时钟，发挥着重要作用。</p><p>Follower 在等待 Leader 心跳信息超时后，推举自己为 Candidate 时，会增加自己的任期号，比如节点 A 的当前任期编号为 0，那么在推举自己为候选人时，会将自己的任期编号增加为 1。</p><p>如果一个服务器节点，发现自己的任期编号比其他节点小，那么它会更新自己的编号到较大的编号值。</p><p>在 raft 中，如果 Candidate 或者 Leader 发现自己的任期小于其他节点（任期过期），那么就会立刻恢复成 Follower。</p><p>如果一个节点接受到了一个任期值较低的请求，那么就会直接拒绝这个请求。</p><h3 id="选举的规则"><a href="#选举的规则" class="headerlink" title="选举的规则"></a>选举的规则</h3><ol><li>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“先来先服务”的原则进行投票。</li><li>日志完整性高的 Follower（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的 Candidate</li></ol><p>raft 的日志格式如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">索引：  1   2   3   4<br>任期：|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3 </span>|<br>指令：|<span class="hljs-string">x=1</span>|<span class="hljs-string">y=2</span>|<span class="hljs-string">x=2</span>|<span class="hljs-string">z=4</span>|<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>声明式 API</title>
    <link href="/post/declarative-api.html"/>
    <url>/post/declarative-api.html</url>
    
    <content type="html"><![CDATA[<p>声明式 API 是一种软件设计理念和做法，它要求用户描述他们想要达到的目标状态，由服务自身去令系统达到目标状态。</p><p>在声明式 API 中，用户不需要关心系统内部的实现细节，只需要描述他们想要的结果即可。这使得声明式 API 更加易于理解和使用，也更容易维护和扩展。</p><p>声明式 API 与命令式 API 的区别在于，命令式 API 要求用户描述一系列的动作，这些动作如果被正确的顺利执行，最终结果是系统达到了用户期望的目标状态。</p><p>在一个声明式 API 系统中，服务通常分为三个组件，分别是负责处理数据请求的 APIServer，负责调度数据对象的 controller 以及负责持久化数据的数据库。</p><p>如果我们将系统看作一个餐厅，根据用户的需求来制作美食。服务员就是系统中的 APIServer 的角色，订单则是我们的数据库， 厨师则是 controller。</p><p>现在用户需要一份蛋炒饭，他向服务员说了自己的需求，于是服务员写下了下面的订单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">主食:</span> <span class="hljs-string">蛋炒饭</span><br><span class="hljs-string">备注:</span> <span class="hljs-string">加个火腿肠</span><br><span class="hljs-string">单号:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>写好的订单会传递到后厨，此时厨师就会根据订单的需求来做一碗加火腿肠的蛋炒饭。厨师根据预定好的制作炒饭的流程做出一碗蛋炒饭。再由服务员端给客户。</p><p>对于客户来说，他只需要向服务员说明自己想要的蛋炒饭是什么样的，之后等待蛋炒饭做好就可以了。而不需要一步步的告诉厨师怎么制作蛋炒饭。</p><p>因此使用声明式 API 对于用户来说，屏蔽了下层实现的细节，只需要用户提供期望的结果就可以了。所有的实现由系统自己完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无法比较的Go结构体</title>
    <link href="/post/go-no-compare-struct.html"/>
    <url>/post/go-no-compare-struct.html</url>
    
    <content type="html"><![CDATA[<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>在 Go 中比较运算符用于比较两个操作数的大小，并产生一个布尔值。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">==    等于</span><br>!=    不等于<br>&lt;     小于<br>&lt;=    小于等于<br>&gt;     大于<br>&gt;=    大于等于<br></code></pre></td></tr></table></figure><p>其中 <code>==</code> 和<code>!=</code> 操作符号用于两个 <em>comparable</em> 的类型， 而 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>  用于比较 <em>ordered</em> 的类型。类型的定义如下：</p><table><thead><tr><th>类型</th><th>comparable</th><th>ordered</th></tr></thead><tbody><tr><td>Bool</td><td>✅</td><td>❌</td></tr><tr><td>Integer</td><td>✅</td><td>✅</td></tr><tr><td>Float-point</td><td>✅</td><td>✅</td></tr><tr><td>Complex</td><td>✅</td><td>✅</td></tr><tr><td>String</td><td>✅</td><td>✅</td></tr><tr><td>Pointer</td><td>✅指向同一个值， 或者都是 nil</td><td>❌</td></tr><tr><td>Channel</td><td>✅由相同的 make 创建或者都是 nil</td><td>❌</td></tr><tr><td>Interface（非泛型）</td><td>✅</td><td>❌</td></tr><tr><td>接口的实现</td><td>✅ 非接口类型的 X 如果实现了 T，那么它实现了 T 的 t 是可比较的</td><td>❌</td></tr><tr><td>Struct</td><td>✅所有的字段都是可比较的，按照顺序比较</td><td>❌</td></tr><tr><td>Array</td><td>✅元素类型是可比较的</td><td>❌</td></tr><tr><td>Type parameters</td><td>✅当类型为 strictly comparable</td><td>❌</td></tr></tbody></table><h2 id="无内存分配的不可比较-Struct"><a href="#无内存分配的不可比较-Struct" class="headerlink" title="无内存分配的不可比较 Struct"></a>无内存分配的不可比较 Struct</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> nocmp [<span class="hljs-number">0</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>_ nocmp<br>A <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := Foo&#123;A: <span class="hljs-number">1</span>&#125;<br>b := Foo&#123;A: <span class="hljs-number">2</span>&#125;<br>fmt.Println(a==b)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译上面的代码会得到下面的错误信息</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">invalid operation: a == <span class="hljs-built_in">b</span> (<span class="hljs-keyword">struct</span> <span class="hljs-type">containing</span> nocmp cannot be compared)<br></code></pre></td></tr></table></figure><p>根据上结的规则， 结构体是否可以比较是根据字段是否可以比较的来判断的。在 Foo 中我们嵌入了一个匿名的 nocmp 类型的数据，nocmp 是一个长度为 0 的函数数组， 由于函数类型是无法比较的， 所以 nocmp 就无法比较，进一步使得 Foo 无法比较。</p><p>另外，这里使用了长度为 0 的函数数组，而不是直接定义一个函数类型的字段，如下面这段代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> nocmp [<span class="hljs-number">0</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>_ nocmp<br>A <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Bar <span class="hljs-keyword">struct</span> &#123;<br>  _ <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>  A <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := Foo&#123;A: <span class="hljs-number">1</span>&#125;<br>b := Bar&#123;A: <span class="hljs-number">1</span>&#125;<br>fmt.Println(unsafe.Sizeof(a))<br>fmt.Println(unsafe.Sizeof(b))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这段代码会得到结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>16<br></code></pre></td></tr></table></figure><p>可以看到，如果直接内嵌一个函数类型的值，在初始化结构体时，就会多分配一段内存用于保存函数类型的指针。</p><p>而使用 nocmp 则不会产生额外的内存分配。</p><p>因此，当我们需要定义一个不可比较的结构体时，可以通过内嵌一个 <code>[0]func()</code> 类型的匿名字段，在达到目的的同时避免的内存的浪费。</p><p>参考</p><ul><li><a href="https://go.dev/ref/spec#Comparison_operators">https://go.dev/ref/spec#Comparison_operators</a></li><li><a href="https://github.com/uber-go/atomic/blob/b1c4565f2175b379d44265ee0f0c442091d7939a/nocmp.go#L35">https://github.com/uber-go/atomic/blob/b1c4565f2175b379d44265ee0f0c442091d7939a/nocmp.go#L35</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goroutine-stop</title>
    <link href="/post/goroutine-stop.html"/>
    <url>/post/goroutine-stop.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 的开源项目中， 经常能够看到通过关闭一个 stopc 的通道来退出 goroutine 的写法， 如下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stopc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopc:<br>fmt.Println(<span class="hljs-string">&quot;a stop&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>fmt.Println(<span class="hljs-string">&quot;a default&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>selec t &#123;<br><span class="hljs-keyword">case</span> &lt;-stopc:<br>fmt.Println(<span class="hljs-string">&quot;b stop&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>fmt.Println(<span class="hljs-string">&quot;b default&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br><span class="hljs-built_in">close</span>(stopc)<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的程序会得到结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">a <span class="hljs-keyword">default</span><br>b <span class="hljs-keyword">default</span><br>b <span class="hljs-keyword">default</span><br>a <span class="hljs-keyword">default</span><br>b stop<br>a stop<br></code></pre></td></tr></table></figure><p>可以看到，在执行两次的打印任务后，goroutine 都完成了退出。</p><p>为什么使用 <code>close(stopc)</code> 可以完成对两个 goroutine 的退出控制，而不是往 stopc 中发送两次数据呢？</p><p>在 go 语言的官方规格文档对 <a href="https://go.dev/ref/spec#Close">close 函数的说明</a>中可以找到答案</p><blockquote><p>For an argument <code>ch</code> with a <a href="https://go.dev/ref/spec#Core_types">core type</a> that is a <a href="https://go.dev/ref/spec#Channel_types">channel</a>, the built-in function <code>close</code> records that no more values will be sent on the channel. It is an error if <code>ch</code> is a receive-only channel. Sending to or closing a closed channel causes a <a href="https://go.dev/ref/spec#Run_time_panics">run-time panic</a>. Closing the nil channel also causes a <a href="https://go.dev/ref/spec#Run_time_panics">run-time panic</a>. After calling <code>close</code>, and after any previously sent values have been received, receive operations will return the zero value for the channel’s type without blocking. The multi-valued <a href="https://go.dev/ref/spec#Receive_operator">receive operation</a> returns a received value along with an indication of whether the channel is closed.</p></blockquote><p>大意是当我们使用 close 关闭一个 channel 时，这标志着没有更多的数据发送到 channel 中了。当使用 close 关闭了一个 channel ，并且 channel 中的所有数据都被消费后，使用 <code>&lt;-</code> 操作符从 channel 中读取数据时，将会返回 channel 数据类型的零值，并且<strong>不会被阻塞</strong>。</p><p>根据官方当我们使用 close 关闭了 stopc 后，goroutine 中的 select 作用域中的 stopc 分支将不会阻塞，直接返回零值。即使有多个消费者在监听，都将会返回零值，从而实现退出。</p><p>因此当需要控制多个 goroutine 的推出时，可以采用相同的方法，传入一个 stopc 的 channel，在需要退出时 close(stopc) 即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build-xtrabackup-on-centos-aarch</title>
    <link href="/post/build-xtrabackup-on-centos-aarch.html"/>
    <url>/post/build-xtrabackup-on-centos-aarch.html</url>
    
    <content type="html"><![CDATA[<h1 id="Percona-xtrabackup-arm-版编译"><a href="#Percona-xtrabackup-arm-版编译" class="headerlink" title="Percona xtrabackup arm 版编译"></a>Percona xtrabackup arm 版编译</h1><p>xtrabackup 官方只提供了  x86 版本的安装包, 在 arm 环境上使用需要自己手动编译。这篇文档主要介绍在 CentOS arm 版上编译安装 xtrabackup。</p><p>X86 版本的安装方式可以参考这篇<a href="https://docs.percona.com/percona-xtrabackup/8.0/installation.html">官方文档</a>。</p><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><p>xtrabackup 编译需要使用 cmake3, 如果环境尚未安装 cmake3, 可以使用下面的命令来编译安装 cmake3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install wget<br>wget https://cmake.org/files/v3.12/cmake-3.12.3.tar.gz<br>tar zxvf cmake-3.*<br><span class="hljs-built_in">cd</span> cmake-3.*<br>./bootstrap --prefix=/usr/local<br>make -j$(<span class="hljs-built_in">nproc</span>)<br>make install<br></code></pre></td></tr></table></figure><p>命令执行完成后使用 <code>cmake --version</code> 检查安装是否成功. 输出下面的内容则代表完成了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cmake</span> version <span class="hljs-number">3</span>.<span class="hljs-number">12</span>.<span class="hljs-number">3</span><br><br><span class="hljs-attribute">CMake</span> suite maintained and supported by Kitware (kitware.com/cmake).<br></code></pre></td></tr></table></figure><p>如果返回命令无法找到, 那么检查一下是否安装了老版本的 cmake, 这种情况下需要先卸载已有的 cmake 再安装.</p><p>另外 xtrabackup 编译需要 devtoolset-10-gcc devtoolset-10-gcc-c++ devtoolset-10-binutils, 这三个包通过下面的方式安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install centos-release-scl <br>sudo yum install devtoolset-10-gcc devtoolset-10-gcc-c++ devtoolset-10-binutils<br></code></pre></td></tr></table></figure><h2 id="编译-xtrabackup"><a href="#编译-xtrabackup" class="headerlink" title="编译 xtrabackup"></a>编译 xtrabackup</h2><h3 id="1-从-git-源获取源代码"><a href="#1-从-git-源获取源代码" class="headerlink" title="1. 从 git 源获取源代码"></a>1. 从 git 源获取源代码</h3><p>如果系统没有安装 <code>git</code>, 需要首先安装 git 工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/percona/percona-xtrabackup.git<br>cd percona-xtrabackup<br>git checkout 8.0<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h3><p>下面的包和工具都是编译 xtrabackup 所必须的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install cmake openssl-devel libaio libaio-devel automake autoconf \<br>bison libtool ncurses-devel libgcrypt-devel libev-devel libcurl-devel zlib-devel \<br>zstd vim-common procps-ng-devel<br></code></pre></td></tr></table></figure><h3 id="3-生成构建-pipeline"><a href="#3-生成构建-pipeline" class="headerlink" title="3. 生成构建 pipeline"></a>3. 生成构建 pipeline</h3><p>在这一步, 我们将使用 cmake 执行 CMakeList.txt 去生成构建流水线, 意思是一个用于编译代码的原生编译环境.</p><ol><li><p>进入克隆的 Percona Xtrabackup 代码库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> percona-xtrabackup<br></code></pre></td></tr></table></figure></li><li><p>创建一个保存编译产物的文件夹, 然后进入其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure></li><li><p>运行 <code>cmake</code> 或者 <code>cmake3</code>. 同时你需要使用下面的这些参数你需要保持一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -DWITH_BOOST=PATH-TO-BOOST-LIBRARY -DDOWNLOAD_BOOST=ON \<br>-DBUILD_CONFIG=xtrabackup_release -DWITH_MAN_PAGES=OFF -B ..<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-编译安装"><a href="#4-编译安装" class="headerlink" title="4. 编译安装"></a>4. 编译安装</h3><p> 执行 make 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>如果需要使用所有 CPU 线程参与编译来加快编译速度, 使用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -j$(nproc --all)<br></code></pre></td></tr></table></figure><p>完成后, 安装 xtrabackup</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码的坏味道</title>
    <link href="/post/bad-smell-of-code.html"/>
    <url>/post/bad-smell-of-code.html</url>
    
    <content type="html"><![CDATA[<p>代码的坏味道列表：</p><ol><li><strong>神秘的命名</strong>：代码不是直观明了的，命名无法表明自己的功能和用法</li><li><strong>重复的代码</strong>：在一处以上的地方看到相同的代码结构</li><li><strong>过长的函数</strong>：积极的分解函数，当感觉需要以注释来说明点什么的时候，把需要说明的东西写进一个独立的函数中，并以其用途命名</li><li><strong>过长的参数列表</strong></li><li><strong>全局数据</strong></li><li><strong>可变数据</strong>：约束对数据的更新，降低风险</li><li><strong>发散式变化</strong>：杂糅了不同上下文的模块因为不同的原因在不同的方向上发生变化，对某个上下文进行修改时，需要操心对另一个上下文的影响。</li><li><strong>霰弹式修改</strong>：遇到某种变化，需要在不同的地方做出小的修改</li><li><strong>依恋情结</strong>：一个函数与另一个模块中的函数或数据交流格外频繁，远胜于自身所处模块内部的交流。</li><li><strong>数据泥团</strong>：不同地方出现的三四项相同的字段，例如两个类中相同的字段，许多函数签名中相同的参数，将它们提炼到独立的对象中。</li><li><strong>基本类型偏执</strong>：不愿意创建对自己问题域有用的基本类型，如钱、坐标、范围等。</li><li><strong>重复的 switch</strong>：在不同的地方反复使用同样的 switch 逻辑</li><li><strong>循环语句</strong>：使用 Map Reduce Filter来替代循环</li><li><strong>冗余元素</strong></li><li><strong>夸夸其谈通用性</strong>：总有一天需要做这事，企图以各种各样的钩子和特殊情况来处理一些非必要的事情</li><li><strong>临时字段</strong>：某些为了特定情况而设置的字段</li><li><strong>过长的消息链</strong></li><li><strong>中间人</strong>：过度运用委托</li><li><strong>内幕交易</strong>：模块间大量交换数据， 减少模块间的数据交换，并将交换放到明面上</li><li><strong>过大的类</strong>：单个类做太多的事情</li><li><strong>异曲同工的类</strong>：相似的类却无法替换</li><li><strong>纯数据类</strong></li><li><strong>被拒绝的遗赠</strong>：复用超类的实现，但又不愿意支持超类的接口</li><li><strong>注释</strong>：一段长长的注释，因为糟糕的代码而存在</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何时去重构</title>
    <link href="/post/principles-of-refactoring-p2.html"/>
    <url>/post/principles-of-refactoring-p2.html</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://blog.zhangliangliang.cc/post/principles-of-refactoring-p1.html">前一篇文章</a>中，记录了为什么要去重构，在这篇文章中，我们将会聚焦于何时去重构。</p><p>在阐述何时去重构时，先了解三次法则</p><blockquote><p>第一次做某事时只管去做；</p><p>第二次做类似的事时，会产生反感，但无论如何还是可以去做；</p><p>第三次做相同的事时，你就应该重构</p></blockquote><h2 id="预备性重构"><a href="#预备性重构" class="headerlink" title="预备性重构"></a>预备性重构</h2><p>最佳的重构时机是在添加新功能之前。</p><p>在添加新功能之前，先检查现有的代码库，通常可以发现其中已经有类似功能的方法。可以对这些方法进行微调，避免出现重复代码。</p><p>如果不进行重构，最简单的方式就是复制一份代码，并进行一些微调，例如调整参数或逻辑。这样会导致重复的代码，当需要修改方法时，就必须在两个地方进行修改。甚至在需要新方法时，又会复制一份代码并进行微调。这样反复之后，代码将变得臃肿不堪。</p><p>因此，当添加新功能时，如果已有代码库中已经有类似功能的方法，就可以通过函数参数化进行重构。这样一来，只需调用该方法并传入所需的参数即可。</p><p>合并重复的代码也会使修复 bug 更加容易。只需在一个地方进行调整，就可以修复相关的 bug，而不必在代码库的各个角落查找重复代码并逐一修复。</p><h2 id="帮助理解代码的功能"><a href="#帮助理解代码的功能" class="headerlink" title="帮助理解代码的功能"></a>帮助理解代码的功能</h2><p>在修改一段代码之前，我们首先需要弄懂这段代码在做什么。在思考代码是在做什么的过程中，询问自己能不能去重构这段代码，使得它更加容易理解，一目了然。</p><p>比如一个糟糕的函数命名，或者一段结构糟糕的逻辑判断都会提醒我们去重构它。</p><p>在阅读代码的过程中，我们会形成自己的理解，但这种理解往往不能长时间存于脑中。我们通过重构将自己的理解注入代码中，这样我们的理解就随着代码一起被保存下来了，这样后来的人就可以通过阅读代码获得其中的理解了。并且代码能否正常运行也会验证我们的理解是否正确。</p><p>在一次次小的重构之后，代码的逻辑就会逐渐清晰，我们对于代码的理解也会逐渐加深。这时我们就能从更高的角度去理解代码，从而发现隐藏在代码之后的设计问题。如果只是阅读，而没有亲手去重构代码，那就无法获得深入的理解，从而体会到代码背后的设计思路。</p><p>在厘清藤蔓和杂枝之后，我们才能看到树干生长的情况。</p><h2 id="捡垃圾式重构"><a href="#捡垃圾式重构" class="headerlink" title="捡垃圾式重构"></a>捡垃圾式重构</h2><p>在我们理解了代码是在做什么之后， 可能会发现它做的不够好。例如一段设计不合理的逻辑判断语句，两个函数的功能几乎相同，等等。</p><p>如果当前手上又着更重要的任务，无法分心太多，而重构有需要花费一定的精力，那么就用便利贴记录下需要重构的地方，在完成任务后重构。如果不需太多的精力，那么就随手将它重构掉。就像看到地上的废纸，随手捡起扔进垃圾桶一样。</p><h2 id="Code-review-时重构代码"><a href="#Code-review-时重构代码" class="headerlink" title="Code review 时重构代码"></a>Code review 时重构代码</h2><p>有些公司会代码合并前进行 code review。code review 可以改善开发情况，帮助知识在开发团队中传播，让更多的人了解到代码库中的更多部分。</p><p>在 code review 时， 如果采用 Pull Request 方式，由于代码作者不在身边，重构的效果可能并不好。作者可以提供更多的上下文，这对于重构有着积极的作用。在这种情况下，结对编程是最优的选择，在编码的过程中，不断的进行 code review。</p><h2 id="何时不要去重构"><a href="#何时不要去重构" class="headerlink" title="何时不要去重构"></a>何时不要去重构</h2><ol><li>如果代码不需要被修改，那么它就不需要被重构</li><li>如果丑陋的代码隐藏在 API 下，不需要直接接触，那么就不需要被重构</li><li>如果一段代码，重写的难度低于重构，那么就去重写，而不是重构</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅的处理错误</title>
    <link href="/post/handle-error-gracefully.html"/>
    <url>/post/handle-error-gracefully.html</url>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://dave.cheney.net/">Dave Cheney</a> 博客的翻译， 这里是<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">原文地址</a></p><h2 id="错误只是值"><a href="#错误只是值" class="headerlink" title="错误只是值"></a>错误只是值</h2><p>我花了很多时间思考在 Go 程序中处理错误的最佳方式。我真的希望有一种单一的方式来处理错误，这样我们就可以像教授数学或字母一样，教授所有的 Go 程序员。</p><p>然而，我得出结论，没有一种单一的方式来处理错误。相反，我认为 Go 的错误处理可以归类为三种核心策略。 </p><h2 id="哨兵错误"><a href="#哨兵错误" class="headerlink" title="哨兵错误"></a>哨兵错误</h2><p>第一种错误处理方式我称之为哨兵错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err == ErrSomething &#123; … &#125;<br></code></pre></td></tr></table></figure><p>这个名字源自计算机编程中使用特定值来表示不可能进行更多处理的惯例。因此，在 Go 中，我们使用特定的值来表示错误。</p><p>例如，值如 <code>io.EOF</code> 或类似 syscall 包中的常量的低级错误，如 <code>syscall.ENOENT</code>。</p><p>甚至有一些哨兵错误表示没有发生错误，比如 <code>go/build.NoGoError</code> 和 <code>path/filepath.Walk</code> 中的 <code>path/filepath.SkipDir</code>。</p><p>使用哨兵值是最不灵活的错误处理策略，因为调用者必须使用相等运算符将结果与预声明的值进行比较。当您想提供更多上下文时，这会造成问题，因为返回不同的错误会破坏等式检。</p><p>即使像使用 fmt.Errorf 给错误添加一些上下文这样善意的操作也会使调用者的相等性测试失败。相反，调用者将被迫查看错误的 Error 方法的输出，以查看它是否与特定的字符串匹配。</p><h3 id="永远不要检查-error-Error-的输出"><a href="#永远不要检查-error-Error-的输出" class="headerlink" title="永远不要检查 error.Error 的输出"></a>永远不要检查 error.Error 的输出</h3><p>顺便提一句，我认为您永远不应检查 <code>error.Error</code> 方法的输出。错误接口上的 Error 方法是为人类而存在的，而不是为代码而存在的。</p><p>该字符串的内容应放在日志文件中或显示在屏幕上。您不应尝试通过检查它来更改程序的行为。</p><p>我知道有时这是不可能的，正如有人在 Twitter 上指出的那样，这个建议不适用于编写测试。尽管如此，在我看来，比较错误的字符串形式是一种代码异味，您应该尽量避免这样做。</p><h3 id="哨兵错误会成为您的公共-API-的一部分。"><a href="#哨兵错误会成为您的公共-API-的一部分。" class="headerlink" title="哨兵错误会成为您的公共 API 的一部分。"></a>哨兵错误会成为您的公共 API 的一部分。</h3><p>如果您的公共函数或方法返回特定值的错误，那么该值必须是公共的，并且当然需要进行文档化。这会增加您的 API 表面积。</p><p>如果您的 API 定义了一个接口，该接口返回特定错误，则该接口的所有实现都将受到限制，只能返回该错误，即使它们可以提供更详细的错误信息。</p><p>我们可以看到这一点在 io.Reader 上。像 io.Copy 这样的函数需要一个 reader 实现返回确切的 io.EOF，以向调用者表示没有更多数据，但这并不是一个错误。</p><h3 id="哨兵错误会在两个包之间创建依赖关系。"><a href="#哨兵错误会在两个包之间创建依赖关系。" class="headerlink" title="哨兵错误会在两个包之间创建依赖关系。"></a>哨兵错误会在两个包之间创建依赖关系。</h3><p>迄今为止哨兵错误值的最大问题是它们在两个包之间创建了源代码依赖关系。例如，要检查错误是否等于 io.EOF，您的代码必须导入 io 包。</p><p>这个具体的例子听起来并不那么糟糕，因为这很常见，但想象一下当您的项目中的许多包导出错误值时，存在的耦合性，其他包必须导入它们来检查特定的错误条件。</p><p>我曾经在一个尝试使用这种模式的大型项目中工作过，我可以告诉您，不良设计（以导入循环的形式）的威胁一直存在于我们的思想中。</p><h3 id="避免使用哨兵错误值"><a href="#避免使用哨兵错误值" class="headerlink" title="避免使用哨兵错误值"></a>避免使用哨兵错误值</h3><p>因此，我的建议是在您编写的代码中避免使用哨兵错误值。虽然标准库中有一些情况使用了它们，但这不是您应该效仿的模式。</p><p>如果有人要求您从包中导出错误值，您应该礼貌地拒绝，并建议另一种替代方法，例如我将在接下来讨论的方法。</p><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>我想讨论的第二种错误处理模式是错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err, ok := err.(SomeType); ok &#123; … &#125;<br></code></pre></td></tr></table></figure><p>错误类型是一个由你创建的实现了 <code>Error</code> 接口的类型。在下面这个例子中，<code>MyError</code>追踪文件和行，以及解释发生了什么的消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>        Msg <span class="hljs-type">string</span><br>        File <span class="hljs-type">string</span><br>        Line <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123; <br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s:%d: %s”, e.File, e.Line, e.Msg)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">return &amp;MyError&#123;&quot;</span>Something happened<span class="hljs-string">&quot;, “server.go&quot;</span>, <span class="hljs-number">42</span>&#125;<br></code></pre></td></tr></table></figure><p>因为 MyError 错误是一个类型，调用者可以使用类型断言从错误中提取额外的上下文信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">err := something()<br><span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-comment">// call succeeded, nothing to do</span><br><span class="hljs-keyword">case</span> *MyError:<br>        fmt.Println(“<span class="hljs-type">error</span> occurred on line:”, err.Line)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// unknown error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于错误值， 错误类型的一个巨大提升是可以包装底层错误信息，从而提供更多的上下文。</p><p><code>os.PathError</code> 类型是一个很好的例子，它使用操作和文件来注释底层错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PathError records an error and the operation</span><br><span class="hljs-comment">// and file path that caused it.</span><br><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>        Op   <span class="hljs-type">string</span><br>        Path <span class="hljs-type">string</span><br>        Err  <span class="hljs-type">error</span> <span class="hljs-comment">// the cause</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><h3 id="错误类型的问题"><a href="#错误类型的问题" class="headerlink" title="错误类型的问题"></a>错误类型的问题</h3><p>由于调用者需要使用类型断言，因此错误类型也必须变为公共的。</p><p>如果您的代码实现了一个接口，该接口的契约要求特定的错误类型，那么该接口的所有实现者都需要依赖于定义该错误类型的包。</p><p>对一个包类型的这种熟悉程度会在调用者和接口实现者之间产生强耦合，从而使 API 易于受损。</p><h3 id="避免使用错误类型"><a href="#避免使用错误类型" class="headerlink" title="避免使用错误类型"></a>避免使用错误类型</h3><p>虽然错误类型比哨兵错误值更好，因为它们可以捕获更多关于出错原因的上下文信息，但错误类型与错误值共享许多问题。</p><p>因此，我的建议是避免使用错误类型，或者至少避免将它们作为您的公共 API 的一部分。</p><h2 id="不透明错误"><a href="#不透明错误" class="headerlink" title="不透明错误"></a>不透明错误</h2><p>现在我们来到了第三种错误处理方式。在我看来，这是最灵活的错误处理策略，因为它需要您的代码与调用者之间最少的耦合。</p><p>我称之为不透明的错误处理方式，因为虽然您知道发生了错误，但您无法查看错误的内部。作为调用者，您只知道操作的结果是成功还是失败。</p><p>这就是不透明的错误处理方式的全部内容——只返回错误，而不对其内容做任何假设。如果您采用这种立场，那么错误处理就可以成为一种重要的调试辅助工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> “github.com/quux/bar”<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        x, err := bar.Foo()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-comment">// use x</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如，Foo 的声明不保证在错误的情况下会返回什么内容。现在 Foo 的作者可以在传递错误时添加额外的上下文信息，而不会违反其与调用者的约定。 </p><h3 id="对行为进行错误断言，而不是类型"><a href="#对行为进行错误断言，而不是类型" class="headerlink" title="对行为进行错误断言，而不是类型"></a>对行为进行错误断言，而不是类型</h3><p>在少数情况下，这种二进制的错误处理方式是不够的。</p><p>例如，与您的进程外部世界的交互，如网络活动，要求调用者调查错误的性质，以决定是否有合理的重试操作。</p><p>在这种情况下，我们断言错误实现了某种特定的行为，而不是某种错误类型或者错误值。考虑下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>        Temporary() <span class="hljs-type">bool</span><br>&#125;<br> <br><span class="hljs-comment">// IsTemporary returns true if err is temporary.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        te, ok := err.(temporary)<br>        <span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以传入任何错误给 <code>IsTemporary</code>去判断该错误是否可以重试。</p><p>如果一个错误实现了 temporary 接口，或许调用者就可以在 IsTemporary 返回 true 时重试操作了。</p><p>关键在于，可以在不导入定义错误的包或实际上不知道 err 的底层类型的情况下实现此逻辑——我们只关心它的行为。</p><h2 id="不要只是检查错误，要优雅地处理它们"><a href="#不要只是检查错误，要优雅地处理它们" class="headerlink" title="不要只是检查错误，要优雅地处理它们"></a>不要只是检查错误，要优雅地处理它们</h2><p>这让我想起了第二个我想要谈论的 Go 谚语：“不要仅仅查找错误，要优雅地处理它们”。你能否提出以下代码片段中可能出现的问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        err := authenticate(r.User)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个明显的建议是把函数的处理逻辑替换为下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">return</span> authenticate(r.User)<br>&#125;<br></code></pre></td></tr></table></figure><p>但这是每个人都应该在代码审查中捕捉到的简单问题。更根本的问题是我无法确定原始错误来自哪里。</p><p>如果 authenticate 返回一个错误，那么 AuthenticateRequest 将把错误返回给调用者，调用者可能会执行相同的操作，以此类推。在程序的顶部，程序的主体将把错误打印到屏幕或日志文件上，而打印的只是：“No such file or directory”。</p><p>没有提供生成错误的文件和行的信息。没有呈现引导到错误的调用栈的堆栈跟踪。代码的作者将被迫花费很长时间，对他们的代码进行二分查找，以发现哪个代码路径触发了“找不到文件”错误。</p><p>Donovan和Kernighan的《Go程序设计语言》建议您使用fmt.Errorf为错误路径添加上下文信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        err := authenticate(r.User)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;authenticate failed: %w&quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法会将原本的错误包转，并增加更多的上下问信息返回给上层调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">for</span> _, err := <span class="hljs-keyword">range</span> x.Unwrap() &#123;<br>    te, ok := x.(temporary)<br>        <span class="hljs-keyword">if</span> ok &amp;&amp; te.Temporary() &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="只处理错误一次"><a href="#只处理错误一次" class="headerlink" title="只处理错误一次"></a>只处理错误一次</h2><p>最后，我想提醒一下，您应该只处理一次错误。处理错误意味着检查错误值并做出决策。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-type">byte</span>)</span></span> &#123;<br>        w.Write(buf)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您做出的决策少于一个，那么您正在忽略该错误。正如我们在这里看到的，来自w.Write的错误被丢弃了。</p><p>但是，对单个错误做出多个决策也是有问题的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>        _, err := w.Write(buf)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// annotated error goes to log file</span><br>                log.Println(<span class="hljs-string">&quot;unable to write:&quot;</span>, err)<br> <br>                <span class="hljs-comment">// unannotated error returned to caller</span><br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果在Write期间出现错误，将会写入一行日志文件，记录发生错误的文件和行，并将错误返回给调用者，调用者可能会将其记录并返回，一直返回到程序的顶部。</p><p>因此，您会在日志文件中获得一堆重复的行，但在程序的顶部，您会得到原始错误而没有任何上下文。Java呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Write, buf []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>        _, err := w.Write(buf)<br>  <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;write: %w&quot;</span>,err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，错误是您软件包的公共API的一部分，应像对待公共API的其他部分一样小心。</p><p>为了获得最大的灵活性，我建议您尝试将所有错误视为不透明的。在无法这样做的情况下，对行为而非类型或值进行错误断言。</p><p>在程序中尽量减少哨兵错误值的数量，并在它们发生时使用 fmt.Errorf() 将错误转换为不透明的错误。</p><p>最后，如果需要检查它，请使用 errors.Unwrap 恢复底层错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构的原则(上)</title>
    <link href="/post/principles-of-refactoring-p1.html"/>
    <url>/post/principles-of-refactoring-p1.html</url>
    
    <content type="html"><![CDATA[<p>最近在重温 Martin Fowler 的 《重构》一书，在博客中记录一下阅读过程的心得笔记。</p><h2 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h2><p>重构是软件开发过程中经常会用到重构一次，但在使用时比较随意，Martin 则是认为这个词的使用需要更为严谨一下，因此给出了两个定义</p><ol><li>重构作为一个名词时，是指对软件内部的一种调整，在不改变软件可观察行为的前提下，提供代码的可理解性，降低内部的修改难度。简单的理解便是，优化了程序内部的逻辑，降低第三者的理解难度，以及基于原有逻辑进行修改时，不会觉得难以下手。</li><li>重构作为一个动词时，是指使用一系列的重构手法，在不改变软件可观测行为的前提下，调整它的结构</li></ol><p>所以当我们谈论重构时，我们指的是在不改变代码外部行为的前提下，通过一系列微小且保持软件行为的的步骤对代码的结构和内部实现进行调整，使其更易于理解、维护、扩展和重用的过程</p><p>每一个重构要么很小， 要么是通过多个小步骤组合而成。在重构的过程中，代码一直是可运行，并且行为与重构前是相同的。放弃当前的重构，代码也是不会受到影响的。</p><blockquote><p>如果有人说他们的代码在重构过程中有一两天不可用，那么基本上就可以确定，他们在做的事不是重构</p></blockquote><p>重构保证的是可观测行为，这意味着重构后程序的行为不一定与重构前的行为完全一致，但是对于用户关心的行为来说是不应该有任何改变的。也就是说重构可能会调整内部的接口，对内部函数的性能造成一定的影响。</p><p>总而言之，重构是通过一系列微小且不影响观测行为的步骤，使软件更容易理解，更易于修改。</p><h2 id="两顶帽子"><a href="#两顶帽子" class="headerlink" title="两顶帽子"></a>两顶帽子</h2><p>在开发软件的工作中， 将自己的时间分配给两种的功能，就像是两顶帽子，同一时间我们只能选择其中的一顶。这两顶帽子分别是“修改帽子”和“重构帽子”。</p><h3 id="修改帽子"><a href="#修改帽子" class="headerlink" title="修改帽子"></a>修改帽子</h3><p>“修改帽子”是指我们进行代码修改时所带的“帽子”，通常是在实现新功能、修复问题或加入新特性时使用。在修改帽子下，我们通常关注的是完成任务并使代码能够正确运行，而不太关注代码的设计是否合理、可维护性如何等问题。因此，在修改帽子下，我们可能会编写一些不那么优秀的代码，可能会违反一些设计原则，甚至会引入一些技术债务。</p><h3 id="重构帽子"><a href="#重构帽子" class="headerlink" title="重构帽子"></a>重构帽子</h3><p>相比之下，“重构帽子”则强调了代码的设计和质量。在重构帽子下，我们关注的是如何将代码重构为更加优秀、可读性更高、可维护性更好、更易于扩展和更易于重用的形式。通过重构，我们可以去除代码中的重复和冗余，改进代码的可读性和可维护性，遵循设计原则，减少技术债务。</p><p>总的来说，“修改帽子”和“重构帽子”是两种不同的代码修改方式和目的。在开发过程中，我们应该时刻意识到这两种“帽子”的存在，当前戴的是哪一顶“帽子”，并且根据具体情况选择合适的“帽子”来进行代码修改，以实现高质量、高效率的软件开发。</p><h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><p>在解释了什么是重构之后，我们需要进一步去思考为什么需要重构。重构并不是解决所有问题的“银弹”，而是一种重要的技术手段，应该根据具体情况和需求进行选择和应用，如果需要完成以下的目的，那么就可以使用重构来改善代码。</p><h3 id="改进软件的设计"><a href="#改进软件的设计" class="headerlink" title="改进软件的设计"></a>改进软件的设计</h3><p>当缺乏重构时，代码的内部设计（架构）逐渐腐败变质，因为人们在修改代码时往往只关注短期目的而忽视整体的设计。这样的修改会导致代码失去原有的结构和清晰性，逐渐变得混乱、复杂和难以理解。</p><p>随着这种修改的不断累积，软件的设计逐渐失去了它原有的结构，开发者也无法通过阅读代码来理解原来的设计。这种“技术债务”不断积累，最终导致代码的内部设计变得混乱不堪，甚至变得无法维护和扩展。</p><p>设计欠佳的软件在修改时往往需要调整更多的代码，这是因为设计欠佳会导致代码结构混乱、逻辑复杂，同一个功能的代码可能分散在各处，或者有很多重复的代码。这样一来，每次修改时都需要花费更多的时间和精力来查找和调整相关的代码，同时也增加了引入新错误的风险。</p><p>改进设计的一个重要目标便是消除重复的代码。通过重构和改进设计，我们可以使代码更加简单、清晰和易于理解，减少代码中的重复和冗余，提高代码的可重用性和可扩展性。</p><p>消除重复的代码不仅可以提高代码质量和可维护性，还可以减少代码量，从而降低软件开发和维护的成本。通过重构和改进设计，我们可以使代码更加灵活、易于扩展和修改，从而满足不断变化的需求和技术环境。</p><h3 id="使软件更容易理解"><a href="#使软件更容易理解" class="headerlink" title="使软件更容易理解"></a>使软件更容易理解</h3><p>编程可以被视为与计算机的一种“谈话”，我们需要通过计算机来达成特定的目的。为了让计算机执行相应的任务，我们需要编写代码来表达我们想要实现的功能和逻辑。编程连接了“我想要做什么”和“我需要计算机怎么做”之间的纽带。</p><p>然而，我们的代码并不仅仅只有计算机可以阅读和理解。我们的代码还将被其他的开发者阅读和修改，包括我们自己在几个月或几年之后。如果我们的代码设计和实现难以理解，这将极大地阻碍后续开发者的工作。他们将花费大量的时间来阅读、理解、修改我们的代码，甚至可能需要重构整个系统，从而影响到整个项目的进度和效率。</p><p>良好设计的代码是易于理解和修改的，可以为后续开发者节省时间和精力。相反，难以理解和修改的代码会导致开发效率低下，增加开发成本，并可能产生一系列的错误和缺陷。</p><p>无论是为了我们自己，还是为了后续的开发者，我们都需要将代码写得更容易理解和维护，更清晰地表达我们的意图和设计思路。</p><h3 id="帮助寻找-bug"><a href="#帮助寻找-bug" class="headerlink" title="帮助寻找 bug"></a>帮助寻找 bug</h3><p>在重构的过程中，我们需要仔细审视代码，并深入理解其意图和设计。这意味着我们需要逐行、逐句地阅读代码，并确保我们完全理解代码中所发生的事情。</p><p>在理解代码的过程中，我们需要验证自己的假设和理解，这通常涉及到一些测试和试验。我们可能会对代码进行一些修改和调整，以验证我们对代码的理解是否正确。通过这个过程，我们可以发现一些隐藏在代码中的 bug，并解决它们。</p><h3 id="提升开发速度"><a href="#提升开发速度" class="headerlink" title="提升开发速度"></a>提升开发速度</h3><p>一个内部质量良好的程序，具有清晰的代码结构和良好的设计，可以让开发者更轻松地添加新功能或修改已有功能。通过良好的设计，开发者可以更好地理解代码的意图和结构，更容易地找到需要修改的地方，并知道如何进行修改。这可以减少修改过程中引入新错误和缺陷的风险，并且可以提高代码的可维护性和可扩展性。</p><p>另外，通过投入精力改善内部设计，程序的耐久度可以得到提高。内部设计良好的程序可以更好地适应需求的变化，更容易地进行维护和扩展。这可以保持软件长时间的高速开发，并且减少因为代码结构混乱而导致的不必要的开发和维护成本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 低内存大文件上传</title>
    <link href="/post/go-buffer-less-multipart-form.html"/>
    <url>/post/go-buffer-less-multipart-form.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当涉及到文件上传时，低内存占用的客户端是非常重要的。在本篇博客中，我们将介绍如何使用Go语言实现一个低内存占用的HTTP文件上传客户端。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先，让我们先讨论一下HTTP文件上传的基本原理。HTTP文件上传是通过POST请求向服务器发送数据的。请求的头部包含文件的元数据，请求的主体则包含文件的二进制数据。由于HTTP请求和响应在网络上传输的过程中可能会被分割成多个小块，因此上传大文件时会占用大量的内存。</p><p>为了解决这个问题，我们可以使用Go语言的 multipart 文件上传。multipart 文件上传是将文件分割成多个部分进行上传，每个部分的大小可以根据需求进行调整。这种方法可以使上传过程中所占用的内存量大大降低，从而可以处理更大的文件。</p><p>但是，即使是使用了 multipart 来进行文件上传，对于大文件的上传来说， 还是会占用大量的内存，因此我们还需要使用到别的手段来降低内存占用</p><h2 id="io-Pipe"><a href="#io-Pipe" class="headerlink" title="io.Pipe"></a>io.Pipe</h2><p><code>io.Pipe</code> 提供了一个管道，可以在两个不同的 goroutine 之间传递数据，这对于需要在流式数据中传递大量数据时非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;mime/multipart&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 打开要上传的文件</span><br>file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 创建一个管道</span><br>reader, writer := io.Pipe()<br><br><span class="hljs-comment">// 创建一个多部分表单写入器，将文件写入到管道中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> writer.Close()<br>multipartWriter := multipart.NewWriter(writer)<br>part, err := multipartWriter.CreateFormFile(<span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-string">&quot;example.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>io.Copy(part, file)<br>multipartWriter.Close()<br>&#125;()<br><br><span class="hljs-comment">// 创建一个HTTP请求</span><br>request, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080/upload&quot;</span>, reader)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>request.Header.Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;multipart/form-data&quot;</span>)<br><br><span class="hljs-comment">// 发送请求</span><br>client := &amp;http.Client&#123;&#125;<br>response, err := client.Do(request)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> response.Body.Close()<br><br><span class="hljs-comment">// 处理响应</span><br>responseBody, err := io.ReadAll(response.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(responseBody))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们创建了一个管道，将文件数据写入到管道中，并将管道中的数据作为HTTP请求的主体发送到服务器。由于管道中的数据是按需传输的，因此可以大大降低内存的占用。并且使用了<code>mime/multipart</code>包来处理多部分表单数据。创建HTTP请求时，我们将请求的主体设置为缓冲区的内容，并设置请求头部的Content-Type字段为<code>multipart/form-data</code>，以指示请求包含多部分表单数据。</p><p>在读取响应主体时，我们使用了 <code>io.ReadAll</code> 函数，这将响应主体的所有数据读入内存中，并返回一个字节数组，这可能会导致内存使用量较高。因此，在处理响应时，您可以根据需要对其进行修改以降低内存使用量。</p><p>总之，使用 <code>io.Pipe</code> 可以轻松实现低内存占用的HTTP文件上传客户端，这对于处理大型文件和数据流非常有用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 xtrabakup 搭建基于 GTID 的 mysql replication</title>
    <link href="/post/setting-up-mysql-replication.html"/>
    <url>/post/setting-up-mysql-replication.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.percona.com/software/mysql-database/percona-xtrabackup">xtrabackup</a> 是一个开源的高性能 MySQL 热备份工具，使用 xtrabackup 可以在备份的时候不用停止 MySQL 服务。</p><p>通过使用 xtrabackup 可以简单快速的搭建 MySQL 集群。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在使用 xtrabackup 搭建 MySQL 集群之前需要做好下面的准备：</p><ul><li><code>Master</code>：  一个已经启动了的 MySQL 8.0 服务，下文称之为 Master，这个 mysql 服务就是需要被拓展成 replicattion 的服务，Master 所在的系统需要满足下面的条件<ul><li>MySQL 服务可以通过标准的 TCP IP/Port 进行通信</li><li>SSH 服务已经安装完成，并且已经启动了</li><li>一个能够进行操作的系统账户</li><li>一个拥有数据备份权限的 MySQL 账户</li><li>MySQL 服务启用了 binlog 并且 server-id 设置为 2</li></ul></li><li><code>Slave</code>：一个安装了 MySQL 服务的系统，Slave 的数据除了 server-id 以外将会与 Master  保持一致，slave 的 server-id 将会是 2</li><li><code>xtrabackup</code>：备份数据所需要的工具</li></ul><p>注意：Master 与 Slave 的 MySQL 服务最好保持一致，否则可能会产生预期之外的结果</p><h2 id="第一步：备份-Master-数据"><a href="#第一步：备份-Master-数据" class="headerlink" title="第一步：备份 Master 数据"></a>第一步：备份 Master 数据</h2><p>xtrabackup 不支持备份远端的数据库，因为需要对数据目录进行操作。但是可以借助 ssh 以及 xbstream 将数据备份到 Slave 上。</p><p>在 Slave 上创建数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">Slave$ </span><span class="language-bash"><span class="hljs-built_in">cd</span></span><br><span class="hljs-meta prompt_">Slave$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /path/to/datadir</span><br></code></pre></td></tr></table></figure><p>开始备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">Slave$ </span><span class="language-bash">ssh masterUser@masterHost <span class="hljs-string">&quot;xtrabackup --backup --user=yourDBuser --password=MaGiCdB1 --target-dir=./ --stream=xbstream&quot;</span> | xbstream -x -C /path/to/datadir</span><br></code></pre></td></tr></table></figure><p>在完成备份之后，你会看到下面的提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xtrabackup: completed OK!<br></code></pre></td></tr></table></figure><p>上面的命令会将 Master 的数据拷贝到 Slave 的 /path/to/datadir 目录下。包括 MyISAM，Innodb数据表以及对应的索引。</p><h2 id="第二步：-创建备份账户"><a href="#第二步：-创建备份账户" class="headerlink" title="第二步： 创建备份账户"></a>第二步： 创建备份账户</h2><p>在 Master 的 MySQL shell 中执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Master|mysql&gt; GRANT REPLICATION SLAVE ON *.*  TO &#x27;repl&#x27;@&#x27;$slaveip&#x27;<br> IDENTIFIED BY &#x27;$slavepass&#x27;;<br></code></pre></td></tr></table></figure><h2 id="第三步：处理备份数据"><a href="#第三步：处理备份数据" class="headerlink" title="第三步：处理备份数据"></a>第三步：处理备份数据</h2><p>备份数据没有经过处理是无法直接使用的，所以需要处理一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">Slave$ </span><span class="language-bash">xtrabackup --prepare /path/to/datadir</span><br></code></pre></td></tr></table></figure><p>命令完成后，数据就已经准备就绪了</p><h2 id="第四步：配置启动-replication"><a href="#第四步：配置启动-replication" class="headerlink" title="第四步：配置启动 replication"></a>第四步：配置启动 replication</h2><p>修改 Slave 的 mysql 配置文件，将 server-id 设置为 2</p><p>查看 GTID 的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">Slave$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /path/to/datadir/xtrabackup_binlog_info</span><br>mysql-bin.000002    1232        c7997888a-b6df-11e2-a604-080027635ef5:1-15<br></code></pre></td></tr></table></figure><p>  MySQL 8.0.22 之前的版本使用下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> # 在 MySQL shell 中<br>Slave|mysql&gt; RESET MASTER;<br>Slave|mysql&gt; SET GLOBAL gtid_purged=&#x27;&lt;gtid_string_found_in_xtrabackup_binlog_info&gt;&#x27;; # c7997888a-b6df-11e2-a604-080027635ef5:1-15<br>Slave|mysql&gt; CHANGE MASTER TO<br>             MASTER_HOST=&quot;$masterip&quot;,<br>             MASTER_USER=&quot;repl&quot;,<br>             MASTER_PASSWORD=&quot;$slavepass&quot;,<br>             MASTER_AUTO_POSITION = 1;<br>Slave|mysql&gt; START SLAVE;<br></code></pre></td></tr></table></figure><p>MySQL 8.0.22 以及之后的版本使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Slave|mysql&gt; RESET MASTER;<br>Slave|mysql&gt; SET GLOBAL gtid_purged=&#x27;&lt;gtid_string_found_in_xtrabackup_binlog_info&gt;&#x27;;<br>Slave|mysql&gt; CHANGE REPLICATION SOURCE TO<br>             SOURCE_HOST=&quot;$masterip&quot;,<br>             SOURCE_USER=&quot;repl&quot;,<br>             SOURCE_PASSWORD=&quot;$slavepass&quot;,<br>             SOURCE_AUTO_POSITION = 1;<br>Slave|mysql&gt; START REPLICA;<br></code></pre></td></tr></table></figure><h2 id="第五步：检查-Slave-状态"><a href="#第五步：检查-Slave-状态" class="headerlink" title="第五步：检查 Slave 状态"></a>第五步：检查 Slave 状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Slave|mysql&gt; show slave status\G<br>[..]<br>Slave_IO_Running: Yes<br>Slave_SQL_Running: Yes<br>[...]<br>Retrieved_Gtid_Set: c7997888a-b6df-11e2-a604-080027635ef5:1-15<br>Executed_Gtid_Set: c7997888a-b6df-11e2-a604-080027635ef5:1-15<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>workqueue</title>
    <link href="/post/workqueue.html"/>
    <url>/post/workqueue.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Workqueue 是 <a href="k8s.io/client-go">client-go</a> 提供的一个工作队列，主要的作用是提供一个先进先出的队列，顺序执行队列中的任务。</p><p>workqueue 与普通队列的不同之处在于，它支持对队列中的元素进行标记和去重。</p><p>workqueue 的基本特性如下：</p><ul><li><p>有序：所有的元素按照添加的顺序进行处理</p></li><li><p>标记元素：标记元素是否被处理，在处理时重新排队</p></li><li><p>去重：相同的元素在同一时间不会被并发的处理，一个元素在被多次添加进队列的情况下，也只会被处理一次</p></li><li><p>并发性：支持多个生产者和消费者</p></li><li><p>通知：ShutDown 方法通过信号量通知队列不在接收新的元素，同时通知 metrics goroutine 退出</p></li></ul><p>其他额外的特性：</p><ul><li>延时队列：元素取出后延时一段时间再加入队列</li><li>限速队列：限制元素入队的速率，对元素加入队列的次数进行限制</li><li>监控：支持 promethus 监控</li></ul><p>workerqueue 支持下列三种队列，对外提供三种接口</p><ul><li><code>Interface</code>：FIFO 基础队列，支持去重</li><li><code>DelayingInterface</code>：延迟队列，基于 Interface ，提供额外的 <code>AddAfter(item interface&#123;&#125;, duration time.Duration)</code> 方法, 延迟一段时间后再将元素加入队列</li><li><code>RateLimitingInterface</code>: 限速队列，基于 DelayingInterface， 增加<code>AddRateLimited(item interface&#123;&#125;)</code>, <code>Forget(item interface&#123;&#125;)</code>, <code>NumRequeues(item interface&#123;&#125;) int</code> 方法，对元素进入队列的速率进行限制</li></ul><h2 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h2><p>FIFO 是最基本的 workqueue，支持基本的队列操作，接口定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>  <span class="hljs-comment">// Add 向队列中添加元素</span><br>Add(item <span class="hljs-keyword">interface</span>&#123;&#125;)<br>  <span class="hljs-comment">// 获取队列的长度</span><br>Len() <span class="hljs-type">int</span><br>  <span class="hljs-comment">// 获取队列头部的元素，当 shutdown 为 true 时，消费者应该关闭 goroutine</span><br>Get() (item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-type">bool</span>)<br>  <span class="hljs-comment">// 标记元素已被处理</span><br>Done(item <span class="hljs-keyword">interface</span>&#123;&#125;)<br>  <span class="hljs-comment">// 关闭队列</span><br>ShutDown()<br>  <span class="hljs-comment">// 停止元素入队，等待所有元素处理完成后，关闭队列</span><br>ShutDownWithDrain()<br>  <span class="hljs-comment">// 查询队列是否已关闭</span><br>ShuttingDown() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>FIFO 队列的结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// queue 按顺序存放了需要处理的元素，</span><br>  <span class="hljs-comment">// queue 中的每个元素都应该在 dirty 中，而不在 processing 中</span><br>queue []t<br><br><span class="hljs-comment">// dirty 存放了所有需要被处理的元素</span><br>dirty set<br><br>  <span class="hljs-comment">// processing 中的元素表示正在被处理，处理完成后，从其中移除元素</span><br>  <span class="hljs-comment">// 并检查 dirty 中是否有相同的元素，如果有，将元素加入到 queue 中</span><br>processing set<br><br>cond *sync.Cond<br><br>shuttingDown <span class="hljs-type">bool</span><br>drain        <span class="hljs-type">bool</span><br><br>  metrics queueMetrics<br><br>unfinishedWorkUpdatePeriod time.Duration<br>clock                      clock.WithTicker<br>&#125;<br></code></pre></td></tr></table></figure><p>元素入队的过程</p><p><img src="https://image-1304291812.cos.ap-shanghai.myqcloud.com/workqueue-add.png" alt="workqueue-add.png"></p><p>使用 <code>Get()</code> 获取元素执行时，如果 queue 为空，则直接返回空指针，以及 shutdown 为 true 的结果。如果队列中不为空，会先从 queue 中获取队头的元素，执行代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">item := queue[<span class="hljs-number">0</span>]<br>queue[<span class="hljs-number">0</span>] = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 底层的数组仍然持有对象，不会被垃圾回收，所以需要设置为 nil</span><br>queue = queue[<span class="hljs-number">1</span>:]<br><br>q.metrics.get(item)<br><br>q.processing.insert(item)<br>q.dirty.<span class="hljs-built_in">delete</span>(item)<br></code></pre></td></tr></table></figure><p>当对元素的处理完成后，调用 <code>Done()</code> 方法来标记元素已被处理，首先从 <code>processing</code> 中删除元素，然后查看 <code>dirty</code> 中是否有相同的元素，如果有就加入到 <code>queue</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">q.processing.<span class="hljs-built_in">delete</span>(item)<br><span class="hljs-keyword">if</span> q.dirty.has(item) &#123;<br>  q.queue = <span class="hljs-built_in">append</span>(q.queue, item)<br>  q.cond.Signal()<br>&#125; <br></code></pre></td></tr></table></figure><p>在并发执行的情况下，只有既不在 processing 也不再 dirty 中的元素会被直接加入到 queue 中被执行，其它情况下只有等待当前的元素执行完成才会被取出，保证了去重。</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>基于 FIFO 队列接口再次封装，增加了 <code>AddAfter</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DelayingInterface <span class="hljs-keyword">interface</span> &#123;<br>Interface<br><span class="hljs-comment">// AddAfter 在指定的 duration 之后将元素加入到队列中</span><br>  <span class="hljs-comment">// 当 duration &lt; 0 时，元素会被直接插入到其中</span><br>AddAfter(item <span class="hljs-keyword">interface</span>&#123;&#125;, duration time.Duration)<br>&#125;<br></code></pre></td></tr></table></figure><p>延迟队列的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> delayingType <span class="hljs-keyword">struct</span> &#123;<br>Interface<br><br><span class="hljs-comment">// clock tracks time for delayed firing</span><br>clock clock.Clock<br><br><span class="hljs-comment">// stopCh 发送信号来停止 waiting loop</span><br>stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-comment">// stopOnce 保证只发送一次停止信号</span><br>stopOnce sync.Once<br><br><span class="hljs-comment">// heartbeat ensures we wait no more than maxWait before firing</span><br>  <span class="hljs-comment">// heartbeat 用来保证没有超过最大等待时间</span><br>heartbeat clock.Ticker<br><br><span class="hljs-comment">// waitingForAddCh 是一个缓冲 channel 提供 waitingForAdd 的元素</span><br>waitingForAddCh <span class="hljs-keyword">chan</span> *waitFor<br><br><span class="hljs-comment">// metrics 计算重试的次数</span><br>metrics retryMetrics<br>&#125;<br></code></pre></td></tr></table></figure><p>waitingForAddCh 的默认初始大小为 1000， 当使用 AddAfter 加入元素后，会被加入到 waitingForAddCh 中。</p><p>waitingForChan 中的元素结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitFor <span class="hljs-keyword">struct</span> &#123;<br>data    t<br>readyAt time.Time<br><span class="hljs-comment">// 在 waitForProrityQueue 中的位置</span><br>index <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有 waitingForAddCh 中的元素都是通过 waitingLoop 函数进行执行的。当 delayingType 被初始化时，会启动新的 goroutine 来执行 waitingLoop 方法。</p><p>当元素的延迟时间不大于当前时间的时候，即延迟时间还未到，元素插入到 waitForPriorityQueue 中。否则就将元素插入到 FIFO 队列中。</p><p>waitForPriorityQueue 是一个根据延迟时间排序的堆，堆顶的元素是最先就绪的元素，底层结构是一个 waitFor 的 slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitForPriorityQueue []*waitFor<br></code></pre></td></tr></table></figure><p>在遍历的过程中，查看 waitForPriorityQueue 堆顶的元素是是否就绪，如果就绪则 Pop 出堆顶元素，插入的 FIFO 队列中，然后继续查看下一个元素。</p><h2 id="限速队列"><a href="#限速队列" class="headerlink" title="限速队列"></a>限速队列</h2><p>限速队列，基于延迟队列与 FIFO 队列接口封装。新增了  <code>AddRateLimited</code>, <code>Forget</code>, <code>NumRequeues</code> 方法。</p><p>限速队列达通过延迟某个元素的插入时间，达到特定时间段内插入指定数量元素的目标。</p><p>定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RateLimiter <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 获取元素应该等待的时间</span><br>When(item <span class="hljs-keyword">interface</span>&#123;&#125;) time.Duration<br><span class="hljs-comment">// 释放元素，清空元素的失败次数</span><br>Forget(item <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-comment">// 返回元素的失败次数</span><br>NumRequeues(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>限速周期：执行 AddRateLimited 方法到执行完 Forget 方法之间的时间。</p></blockquote><h3 id="限速算法"><a href="#限速算法" class="headerlink" title="限速算法"></a>限速算法</h3><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p><img src="https://image-1304291812.cos.ap-shanghai.myqcloud.com/token-bucket.png" alt="令牌桶算法"></p><p>workqueue 的令牌桶算法借助 <a href="https://pkg.go.dev/golang.org/x/time/rate">rate</a> 库实现。</p><p>令牌桶内部是一个存放 token 的 bucket，初始时 bucket 为空，token 以固定的速率往 bucket 中填入。当 bucket 满了的时候，token 会被直接丢弃。</p><p>只有获取到了 token 的元素才会被 accept，没有获取到 token 的元素只能排队等待。令牌桶通过发放 token 的方式达到限制速率。</p><p>workqueue 默认队列为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DefaultControllerRateLimiter</span><span class="hljs-params">()</span></span> RateLimiter &#123;<br><span class="hljs-keyword">return</span> NewMaxOfRateLimiter(<br>NewItemExponentialFailureRateLimiter(<span class="hljs-number">5</span>*time.Millisecond, <span class="hljs-number">1000</span>*time.Second),<br><span class="hljs-comment">// 每秒填入 10 个令牌，bucket 的容量为 100.</span><br>&amp;BucketRateLimiter&#123;Limiter: rate.NewLimiter(rate.Limit(<span class="hljs-number">10</span>), <span class="hljs-number">100</span>)&#125;,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在限速周期内插入的元素，通过 <code>r.LimiterReserve().Delay </code> 返回指定元素等待的时间，前 bucket 容量的元素会被立即返回，之后的元素的延迟时间为 100/100 ms， 101/200ms， 102/300ms。每 100ms 放入一个令牌，后续的令牌得在 100 ms 后才能获取到新令牌。</p><h4 id="排队指数算法"><a href="#排队指数算法" class="headerlink" title="排队指数算法"></a>排队指数算法</h4><p>将元素的排队数量作为指数，排队数增大，速率就以 2 的指数形式增长，但最大不超过 maxDelay。</p><p>基础的延迟速率为 baseDelay，如果有十个相同的元素在排队，那么第一个元素的延迟时间为 1* baseDelay， 第二个元素的延迟时间就是 2 * baseDelay，第三个元素的延迟时间就为 4 * baseDelay，第四个元素的延迟时间就为 8 * baseDelay，以此类推，直到超过 maxDelay 后，设置为 maxDelay。</p><h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>在一个计数周期内，最多只允许通过规定数量的元素。</p><p>比如，设定在 1 分钟内只能通过 100 个元素。开始的时候，计数器归零，每通过一个元素，计数器 +1，当达到上限 100 时不允许新的元素通过。当 1 分钟时间到了后，重新开始计时，计数器归零，重新开始计数。</p><p>基于计数器算法，拓展增加 slow 和 fast 功能，当元素排队的数量小于 maxFastAttempts 使用 fastDelay，超过之后使用 fastDelay。</p><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>混合多种算法，在一个队列中有多个算法同时生效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何时在 Go 中使用泛型</title>
    <link href="/post/when-to-use-generics.html"/>
    <url>/post/when-to-use-generics.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是 Go 官方博客的翻译，原文地址：<a href="https://go.dev/blog/when-generics">when generics</a></p><p>Go 1.18 增加了一个重要的语言特性：对泛型编程的支持。本文不会介绍什么是泛型，如何去使用泛型。而是聚焦于何时在Go代码中使用泛型，又该在何时不使用泛型。</p><p>先说明，本文只是提供一个通用的指引，而非硬性的规定。具体使用的时机取决于你的判断。但是如果你不确定是否该使用，那么你就可以遵循本文的说明。</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>首先是从 Go 编程的一般性准则：通过编写代码而非是定义类型来编写 Go 程序。如果在涉及到泛型时，首先想到定义类型参数约束来编写你的程序，那么你可能就走入了一个误区。首先编写函数，在明确了解类型参数的作用后，再添加类型参数约束就是一件很容易的事了。</p><h2 id="类型参数何时有用"><a href="#类型参数何时有用" class="headerlink" title="类型参数何时有用"></a>类型参数何时有用</h2><p>让我们来看看在什么情况下类型参数是有用的</p><h3 id="当使用程序内置的数据结构时"><a href="#当使用程序内置的数据结构时" class="headerlink" title="当使用程序内置的数据结构时"></a>当使用程序内置的数据结构时</h3><p>一种情况就是在使用程序内置的特殊容器进行操作的函数时: map，slice 和 channel。</p><p>如果有一个函数有这种类型的参数，并且函数内部的代码不会对元素的类型有任何的假设，那么使用类型参数就可能是有用的</p><p>举个例子，下面这个函数返回任何类型 map 的所有 key 的 slice：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MapKeys returns a slice of all the keys in m.</span><br><span class="hljs-comment">// The keys are not returned in any particular order.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapKeys</span>[<span class="hljs-title">Key</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">Val</span> <span class="hljs-title">any</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[Key]Val)</span></span> []Key &#123;<br>    s := <span class="hljs-built_in">make</span>([]Key, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(m))<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>        s = <span class="hljs-built_in">append</span>(s, k)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码不会对 map 的 key 的类型做出任何的假设，并且它也没有使用 value 的类型。它适用于任何类型的 map。这使得它成为使用泛型的一个好的选择。</p><p>对于这样的函数，除类型参数外的替代方案就是使用反射，但这是一个更为笨拙的方案。在编译时没有静态类型检查，而且在运行时的速度也会变慢。</p><h3 id="通用数据结构"><a href="#通用数据结构" class="headerlink" title="通用数据结构"></a>通用数据结构</h3><p>参数类型有用的另一种情况就是通用数据结构中。一个通用的数据结构就像 slice 或者 map 一样，但是却不是语言内置的，比如链表或者是二叉树。</p><p>目前，使用这种数据结构的程序往往会选择下面中的一种做法，一是用特定的元素类型来编写，或者是使用 interface{} 类型。使用类型参数来替换特定的类型可以使得数据结构更加的通用。使用类型参数来代替 interface{} 类型则可以更有效的存储数据，从而节省内存使用，同时也可以在代码中避免类型断言，在编译期就可以进行完全的类型检查。</p><p>举例来说，一个使用类型参数的二叉树的一部分可能像下面这段代码一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Tree is a binary tree.</span><br><span class="hljs-keyword">type</span> Tree[T any] <span class="hljs-keyword">struct</span> &#123;<br>    cmp  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(T, T)</span></span> <span class="hljs-type">int</span><br>    root *node[T]<br>&#125;<br><br><span class="hljs-comment">// A node in a Tree.</span><br><span class="hljs-keyword">type</span> node[T any] <span class="hljs-keyword">struct</span> &#123;<br>    left, right  *node[T]<br>    val          T<br>&#125;<br><br><span class="hljs-comment">// find returns a pointer to the node containing val,</span><br><span class="hljs-comment">// or, if val is not present, a pointer to where it</span><br><span class="hljs-comment">// would be placed if added.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bt *Tree[T])</span></span> find(val T) **node[T] &#123;<br>    pl := &amp;bt.root<br>    <span class="hljs-keyword">for</span> *pl != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">switch</span> cmp := bt.cmp(val, (*pl).val); &#123;<br>        <span class="hljs-keyword">case</span> cmp &lt; <span class="hljs-number">0</span>:<br>            pl = &amp;(*pl).left<br>        <span class="hljs-keyword">case</span> cmp &gt; <span class="hljs-number">0</span>:<br>            pl = &amp;(*pl).right<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> pl<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pl<br>&#125;<br><br><span class="hljs-comment">// Insert inserts val into bt if not already there,</span><br><span class="hljs-comment">// and reports whether it was inserted.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bt *Tree[T])</span></span> Insert(val T) <span class="hljs-type">bool</span> &#123;<br>    pl := bt.find(val)<br>    <span class="hljs-keyword">if</span> *pl != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    *pl = &amp;node[T]&#123;val: val&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>二叉树的每个节点都包含一个类型为类型参数 T 的值。当二叉树以特定类型参数实例化时，该类型的值将直接存储在节点中。而不是被存储为 interface{} 类型。</p><p>这就是类型参数的合理使用，因为二叉树的结构，包括方法中的代码，在很大程度上独立于元素类型T。</p><p>二叉树并不需要知道如何去比较每种类型 T 的值大小，它通过使用传入的比较函数来进行值的比较。你可以在<code>find</code>方法的第四行 <code>bt.cmp</code> 调用处看到这一点。除此之外，类型参数根本不重要。</p><h3 id="对于类型参数，更适用于函数而非方法"><a href="#对于类型参数，更适用于函数而非方法" class="headerlink" title="对于类型参数，更适用于函数而非方法"></a>对于类型参数，更适用于函数而非方法</h3><p>二叉树的例子表明了另一个准则：当需要实现像比较大小一样的功能时，使用函数要比方法好。</p><p>如果不使用函数，我们也可以定义一个节点的值需要有<code>Compare</code>和<code>Less</code>方法的二叉树。这可以通过对参数类型增加需要有这两种方法的约束来实现，这意味着用于实例化二叉树的类型都需要有这两种方法才行。</p><p>这样做的结果是，任何想将二叉树与<code>int</code>等简单数据类型一起使用的人都必须定义自己的整数类型并编写自己的比较方法。如果我们定义二叉树需要传入比较函数，如上图所示的代码，那么就很容易传递所需的函数。使用函数而非是带有方法的类型约束。</p><h3 id="实现通用方法"><a href="#实现通用方法" class="headerlink" title="实现通用方法"></a>实现通用方法</h3><p>还有一种类型参数十分有用的情况，那就是不同的类型都需要实现一些通用的方法，并且每个类型的实现方式都是相同时。</p><p>举个例子，标准库中的<code>sort.Interface</code>接口。它要求实现它的类型需要实现三个方法：<code>Len</code>,<code>Swap</code> 和 <code>Less</code></p><p>这里有一个为任何 slice 实现 sort.Interface 接口的泛型类型 SortFn</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SliceFn implements sort.Interface for a slice of T.</span><br><span class="hljs-keyword">type</span> SliceFn[T any] <span class="hljs-keyword">struct</span> &#123;<br>    s    []T<br>    less <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(T, T)</span></span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T])</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.s)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T])</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    s.s[i], s.s[j] = s.s[j], s.s[i]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T] Less(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> s.less(s.s[i], s.s[j])<br>&#125;<br></code></pre></td></tr></table></figure><p>对于任何一个 slice 来说，Len 和  Swap 方法都是相同的。Less 方法需要一个比较函数，也就是 SliceFn 的 Fn 部分。就像之前的二叉树的例子一样，我们在实例化 SliceFn 时传入比较函数</p><p>下面的代码就展示了，如何通过传入比价函数来使用 SortFn 为任何类型的 slice 进行排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SortFn sorts s in place using a comparison function.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortFn</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []T, less <span class="hljs-keyword">func</span>(T, T)</span></span> <span class="hljs-type">bool</span>) &#123;<br>    sort.Sort(SliceFn[T]&#123;s, cmp&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这类似于标准库函数 sort.Slice，但比较函数是使用值而不是切片索引编写的。</p><p>对这类代码使用类型参数是合适的，因为所有切片类型的方法看起来都完全相同。</p><p>（需要注意的是，Go 1.19-而不是1.18-很可能包括一个使用比较函数对切片进行排序的泛型函数，而该泛型函数很可能不使用sort.Interface。见<a href="https://go.dev/issue/47619">提案#47619</a>。）</p><h2 id="类型参数何时没用"><a href="#类型参数何时没用" class="headerlink" title="类型参数何时没用"></a>类型参数何时没用</h2><p>现在让我们来谈谈问题的另一面：类型参数何时是没用的</p><h3 id="不要用类型参数替换接口"><a href="#不要用类型参数替换接口" class="headerlink" title="不要用类型参数替换接口"></a>不要用类型参数替换接口</h3><p>我们都知道，Go 有着接口类型。 接口可以看作是一种泛型编程。</p><p>例如，广泛使用的 <code>io.Reader</code> 接口提供了一个通用机制，用于从任何包含信息（例如文件）或生成信息（例如随机数生成器）的值中读取数据。如果只是需要调用某个类型的值的方法时，使用接口，而不是类型参数。<code>io.Reader</code>易读，高效和有效的。没有必要去使用类型参数调用一个值的 Read 方法来读取数据。</p><p>举例来说，将这里仅使用接口类型的第一个函数签名更改为使用类型参数的第二版本可能会很诱人</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadSome</span><span class="hljs-params">(r io.Reader)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadSome</span>[<span class="hljs-title">T</span> <span class="hljs-title">io</span>.<span class="hljs-title">Reader</span>]<span class="hljs-params">(r T)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>不要做这种改变。省略类型参数使函数更容易写入，更容易读取，并且执行时间可能相同。</p><p>值得强调的是最后一点，虽然可以以几种不同的方式实现泛型，并且实现会随着时间的推移而变化和改进，但Go 1.18中使用的实现在许多情况下将处理类型为类型参数的值，就像对待类型为接口类型的值一样。这意味着使用类型参数通常不会比使用接口类型更快。因此，不要仅仅为了速度而从接口类型更改为类型参数，因为它可能不会运行得更快。</p><h3 id="如果方法的实现不同，不要使用泛型"><a href="#如果方法的实现不同，不要使用泛型" class="headerlink" title="如果方法的实现不同，不要使用泛型"></a>如果方法的实现不同，不要使用泛型</h3><p>在决定是使用类型参数还是接口类型时，请考虑方法的实现。在之前我们说过，当实现的方法对所有的类型都是相同的时候，使用类型参数。相反地，如果每种类型的方法实现都是不同的，那么就使用接口类型，编写不同的方法实现，而不是使用类型参数。</p><p>例如，<code>File</code> 类型的 <code>Read</code>方法实现与随机数生成器 <code>Read</code>方法的实现不同。这意味着我们应该编写里两个不同的 Read 方法，使用一个接口类型就像是 <code>io.Reader</code>。</p><h3 id="酌情使用反射"><a href="#酌情使用反射" class="headerlink" title="酌情使用反射"></a>酌情使用反射</h3><p>Go 拥有运行时反射。反射可以做到泛型编程，因为它允许你编写适用于任何类型的代码。</p><p>如果某些操作甚至必须支持没有方法的类型（因此接口类型没有帮助），并且如果每种类型的操作都不同（因此类型参数不合适），那么在这种情况下请使用反射。</p><p>这种情况的一个例子就是 <code>encoding/json</code> 包。我们不希望编写的每种类型都有一个MarshalJSON方法，因此我们不能使用接口类型。但对接口类型序列化与对结构类型进行序列化的方式又完全不一样，因此我们也不能使用类型参数。相反，该包使用了反射。实现的代码并不简单，但很有效。更多细节见<a href="https://go.dev/src/encoding/json/encode.go">源码</a></p><h2 id="一个简答的指南"><a href="#一个简答的指南" class="headerlink" title="一个简答的指南"></a>一个简答的指南</h2><p>最后，关于何时使用泛型的讨论可以简化为一个简单的指南。</p><p>如果你发现自己多次写完全相同的代码，其中唯一的区别是代码使用了不同的类型，考虑是否可以使用类型参数。</p><p>换句话说，你应该避免使用类型参数，直到你注意到你要多次编写完全相同的代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个 mongo replica set</title>
    <link href="/post/build-local-mongo-rs.html"/>
    <url>/post/build-local-mongo-rs.html</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在本地搭建一个 3 节点的mongo replica set。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>在官方的 <a href="https://www.mongodb.com/try">下载中心</a> 选择对应平台的安装包，解压并安装完成</li><li>将 mongod 以及配套的工具路径加入 $PATH</li><li>命令行终端</li></ul><p>打开命令行，输入如下的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongod --dbpath &lt;data_dir&gt; --port 27017<br></code></pre></td></tr></table></figure><p>上面的代码将会启动一个 mongod 的实例，监听 27017 端口。所有的数据都会存放在指定的 <em>data_dir</em> 下</p><h3 id="搭建-Replica-Set"><a href="#搭建-Replica-Set" class="headerlink" title="搭建 Replica Set"></a>搭建 Replica Set</h3><h4 id="1-创建存放数据的目录"><a href="#1-创建存放数据的目录" class="headerlink" title="1. 创建存放数据的目录"></a>1. 创建存放数据的目录</h4><p>MongoDB 需要一个数据目录来存放所有的数据文件, </p><p>打开命令行，并输入下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p data/db&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure><p>上面的代码将会在用户的家目录下创建 data 目录，并在 data 下创建 db1, db2, db3 三个文件夹，分别用于存储三个节点的数据文件</p><h4 id="2-准备配置文件"><a href="#2-准备配置文件" class="headerlink" title="2. 准备配置文件"></a>2. 准备配置文件</h4><p>正常情况下，三个节点的实例会运行在三个不同的服务器上，现在为了测试，需要在本地启动三个进程，因此需要三个不同的配置文件，并且满足下面的需求</p><ul><li>服务需要监听三个不同的端口，分别是 27017， 27018， 27019</li><li>三个不同的数据存放目录，在第一步中以及创建好了</li><li>三个不同位置的日志文件，分别是 ~/data/db1/mongod.log, ~/data/db2/mongod.log, ~/data/db3/mongod.log</li></ul><p>创建 db1 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db1/mongod.conf</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">systemLog:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  destination: file</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  path:  ~/data/db1/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  logAppend: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">storage:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  dbPath: ~/data/db1  # 数据目录</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">net:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  bindIp: 0.0.0.0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  port: 27017   # 端口</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">replication:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  replSetName: rs0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">processManagement:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  fork: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">EOF</span></span><br></code></pre></td></tr></table></figure><p>创建 db2 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db2/mongod.conf</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">systemLog:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  destination: file</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  path:  ~/data/db2/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  logAppend: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">storage:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  dbPath: ~/data/db2  # 数据目录</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">net:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  bindIp: 0.0.0.0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  port: 27018   # 端口</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">replication:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  replSetName: rs0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">processManagement:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  fork: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">EOF</span></span><br></code></pre></td></tr></table></figure><p>创建 db3 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db3/mongod.conf</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">systemLog:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  destination: file</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  path:  ~/data/db3/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  logAppend: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">storage:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  dbPath: ~/data/db3  # 数据目录</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">net:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  bindIp: 0.0.0.0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  port: 27019   # 端口</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">replication:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  replSetName: rs0</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">processManagement:</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">  fork: true</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">EOF</span></span><br></code></pre></td></tr></table></figure><h4 id="3-启动进程"><a href="#3-启动进程" class="headerlink" title="3. 启动进程"></a>3. 启动进程</h4><p>在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mongod -f ~/data/db1/mongod.conf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mongod -f ~/data/db2/mongod.conf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mongod -f ~/data/db3/mongod.conf</span><br></code></pre></td></tr></table></figure><p>粘贴下面的代码，查看服务是否正常启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -ef | grep mongo</span><br></code></pre></td></tr></table></figure><h4 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h4><p>在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mongo</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">rs.initiate(&#123;</span><br>    _id: &quot;rs0&quot;,<br>    members: [&#123;<br>        _id: 0,<br>        host: &quot;localhost:27017&quot;<br>    &#125;,&#123;<br>        _id: 1,<br>        host: &quot;localhost:27018&quot;<br>    &#125;,&#123;<br>        _id: 2,<br>        host: &quot;localhost:27019&quot;<br>    &#125;]<br>&#125;)<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">rs.status()</span><br></code></pre></td></tr></table></figure><p>上面的代码会连接 mongod 1，并打开 mongo shell，然后在 mongo shell 中初始化了 rs，完成后使用 <code>rs.status()</code>查看 rs 的信息。</p><p>至此，一个单机版的 replica set 就搭建完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/post/binary-search.html"/>
    <url>/post/binary-search.html</url>
    
    <content type="html"><![CDATA[<p>二分查找（又成折半查找），是一种在<strong>有序数组</strong>中查找特定元素的算法。</p><p>算法的时间复杂度是：O(logn)。</p><p>注意：该算法的前提是输入的数组必须是有序的，并且数组中的元素是可以比较的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这里以 Go 标准库的实现来演示，位置为 sort 包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// func GuessingGame() &#123;</span><br><span class="hljs-comment">//var s string</span><br><span class="hljs-comment">//fmt.Printf(&quot;Pick an integer from 0 to 100.\n&quot;)</span><br><span class="hljs-comment">//answer := sort.Search(100, func(i int) bool &#123;</span><br><span class="hljs-comment">//fmt.Printf(&quot;Is your number &lt;= %d? &quot;, i)</span><br><span class="hljs-comment">//fmt.Scanf(&quot;%s&quot;, &amp;s)</span><br><span class="hljs-comment">//return s != &quot;&quot; &amp;&amp; s[0] == &#x27;y&#x27;</span><br><span class="hljs-comment">//&#125;)</span><br><span class="hljs-comment">//fmt.Printf(&quot;Your number is %d.\n&quot;, answer)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span> &#123;<br>i, j := <span class="hljs-number">0</span>, n<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>h := <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> !f(h) &#123;<br>i = h + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>j = h<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li><p>数组的长度 n, 以及传入的回调函数 f， f 返回索引处的值是否与目标值相同。之所以传入一个回调函数 F 而不是特定数组，是因为 Go 目前的版本（1.17) 还不支持泛型，所以为了支持不同类型的数组查找，需要使用闭包函数来获取特定位置值，正如注释代码所示。并且， 定义 f(-1) == false and f(n) == true.</p></li><li><p>创建两个变量，指向当前查找范围的头尾，j = n 是为了处理目标元素刚好在切片尾部的情况</p></li><li><p>当查找范围的左边界面小于右边界时，进行下面的操作</p></li><li><p>选择当前范围中部的值，使用 <code>int(uint(i+j) &gt;&gt; 1)</code> 而非 <code>(i + j) / 2 </code>获取中间索引的原因是为了防止整数越界</p></li><li><p>将中间位置的值与目标值比较，如果小于目标值，说明目标值在右半部区域，移动左边界。反之则说明在左部区域中，需要移动右边界。循环处理，只到中间位置的值等于目标值，或者遍历完所有元素后退出循环</p></li><li><p>最后返回结果 i，由于 i == j, f(i-1) == false, and f(j) (= f(i)) == true  所以答案是 i 。如果目标元素不存在，i = n, 越界，所以需要判断最后的结果是否为合法索引值。</p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>在目标序列中查找特定值（需要预先排序）</li><li>将目标值插入有序列时，获取对应的索引</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 泛型预览</title>
    <link href="/post/go-generics.html"/>
    <url>/post/go-generics.html</url>
    
    <content type="html"><![CDATA[<p>即将发布的 Go 1.18 将会带来一个巨大的更新：泛型。</p><blockquote><p>官方教程：<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a></p></blockquote><p>这篇文章是对官方指引的翻译。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在正式尝试泛型之前，需要做如下的工作</p><ol><li>安装 go1.18beta1 或更新的版本。安装方式请看 beta版本的安装与使用</li><li>一个可以编辑代码的编辑器，任何你喜欢的编辑器都可以</li><li>命令行终端，在 Linux 和 mac 上可以使用自带的 terminal，在 Windows 上可以使用 powershell 或者 cmd</li></ol><h4 id="安装并使用测试版-Go-工具链"><a href="#安装并使用测试版-Go-工具链" class="headerlink" title="安装并使用测试版 Go 工具链"></a>安装并使用测试版 Go 工具链</h4><p>由于 Go1.18 还未正式发布，因此我们需要安装测试版工具链来尝鲜，按照如下的步骤来安装：</p><ol><li><p>运行下面的命令来安装测试版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go install golang.org/dl/go1.18beta2@latest</span><br></code></pre></td></tr></table></figure></li><li><p>运行下面的命令来下载更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go1.18beta2 download</span><br></code></pre></td></tr></table></figure></li><li><p>使用测试版本程序取代原有的 go 命令（如果安装了正式版的 go）</p><p>可以直接使用测试版的名字，或者将 <code>go</code>设置为测试版程序的别名</p><ul><li><p>直接使用测试版，你可以运行下面的命令来调用测试版程序来取代 <code>go</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go1.18beta2 version</span><br></code></pre></td></tr></table></figure></li><li><p>将 <code>go</code>设置为别名，可以让测试版的使用更加简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> go=go1.18beta2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go version</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>之后的命令将会默认你已经设置了别名</p><h3 id="创建一个代码文件夹"><a href="#创建一个代码文件夹" class="headerlink" title="创建一个代码文件夹"></a>创建一个代码文件夹</h3><p>首先需要一个文件夹来存放测试代码</p><ol><li><p>打开命令行，进入家目录</p><p>在 Linux 或者 Mac 上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span></span><br></code></pre></td></tr></table></figure><p>在 Windows 上</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\&gt; <span class="hljs-title">cd</span> %<span class="hljs-title">HOMEPATH</span>%</span><br></code></pre></td></tr></table></figure><p>教程的其余部分将显示$作为提示。您使用的命令也可以在Windows上使用。</p></li><li><p>在命令行行中创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> generics</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> generics</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个新的 Go module 来存放代码</p><p>运行<code>go mod init</code>命令，并给定模块的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go mod init example/generics</span><br>go: creating new go.mod: module example/generics<br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 对于生产代码, 你需要指定一个与你的需求更加契合的模块路径。更多信息可以参考 <a href="https://go.dev/doc/modules/managing-dependencies">Managing dependencies</a>.</p></li></ol><p>接下来，你将会写一些简单的代码来接触泛型</p><h3 id="新增一个非泛型函数"><a href="#新增一个非泛型函数" class="headerlink" title="新增一个非泛型函数"></a>新增一个非泛型函数</h3><p>在这一步，你将会增加两个函数，每个函数都会将 map 中的值相加，然后返回最终的和。</p><p>之所以会定义两个函数，是因为有两种不同类型的 map 需要被处理：一种的值类型为 int64，另一种的值类型则是 float64.</p><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>用你的编辑器在目录下创建一个 <code>main.go</code>文件，你将会在这个文件中创建代码</p></li><li><p>在 main.go 文件的最顶部，粘贴下面的包声明语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br></code></pre></td></tr></table></figure><p>一个独立的可执行程序（而不是库）入口总是在 main 包中。</p></li><li><p>在包声明语句下方粘贴下面的函数代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SumInts adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-type">int64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumFloats adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-type">float64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述的代码中，你做了如下的事：</p><ul><li>定义了两个函数，每个函数都会将 map 中的值相加，然后返回最终的和。<ul><li>SumInts 处理 string-int64 类型的 map</li><li>SumFloats 处理 string-float64 类型的 map</li></ul></li></ul></li><li><p>在 main.go 中，包声明语句的下方粘贴 main 方法的代码。在 main 方法中，会初始化两个 map，并且将它们作为参数传入在上一步中定义的方法内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Initialize a map for the integer values</span><br>    ints := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>:  <span class="hljs-number">34</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">12</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize a map for the float values</span><br>    floats := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>:  <span class="hljs-number">35.98</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">26.99</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,<br>        SumInts(ints),<br>        SumFloats(floats))<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，做了如下的事情：</p><ul><li>初始化了值类型为 float64 的 map 和值类型为 int64 的 map，每个 map 都有两个元素</li><li>调用上一步定义的函数来获取每个 map 中的值的和</li><li>将结果打印出来</li></ul></li><li><p>在 main.go 中，就在包定义语句的下方，导入刚刚书写的代码中所需要的包。</p><p>第一行代码应该如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">pacakge main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>保存 main.go</p></li></ol><h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run .</span><br>Non-Generic Sums: 46 and 62.97<br></code></pre></td></tr></table></figure><p>通过使用泛型，你可以使用一个函数来完成需求。在接下来的步骤中，将会添加一个函数来处理值类型为 int64 或 float64 的 map。</p><h3 id="新增一个泛型函数来处理多种类型"><a href="#新增一个泛型函数来处理多种类型" class="headerlink" title="新增一个泛型函数来处理多种类型"></a>新增一个泛型函数来处理多种类型</h3><p>在这一节，你将会添加一个泛型函数，它接受值类型为 float64 或 int64 的 map 作为参数，使用单个函数就可以高效的替换原有的两个函数。</p><p>为了支持任一类型的值，这个函数需要一种方法来声明它支持的类型。另一方面，函数的调用者需要一种方法来指定传入的 map 是float64 还是 int64 的。</p><p>为了支持这一点，你将编写一个函数，除了普通的函数参数外，还会声明<em>类型参数</em>。这些类型参数使函数具有通用性（泛型），使其能够处理不同类型的参数。你将使用类型参数和普通函数参数调用函数。</p><p>每个参数类型都有着一个<em>类型约束</em>（<em>type constraint</em> ），作为参数类型的元类型（meta-type）。每个类型约束都指定了，在调用函数时所允许传入的参数类型。</p><p>虽然类型约束通常代表了一组类型，但在编译时，类型参数代表了单个类型——函数调用者提供的参数类型的类型。如果类型参数的类型不符合类型约束，那么代码将无法编译。</p><p>请记住，类型参数必须支持泛型代码在该类型上执行的所有操作。例如，如果函数的代码试图对约束包含 int 类型参数执行 string 操作（如 strings.Index ），那么代码将无法通过编译。</p><p>在即将编写的代码中，你将会使用允许 int 以及 float 的类型约束。</p><h4 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>在上一节新增的代码下方，粘贴泛型函数的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SumIntsOrFloats sums the values of map m. It supports both int64 and float64</span><br><span class="hljs-comment">// as types for map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumIntsOrFloats</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">int64</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li>定义了 SumIntsOrFloats 函数，该函数包含了两个类型参数（在方括号中）K 和 V，以及一个类型为 map[K]V 的参数 m。函数的返回值类型为 V</li><li>指定 K 的类型约束为 comparable。 comparable 是 go 预设的一个类型约束。它允许任何满足约束的类型的值都可以用作比较运算符 == 和  !=。这是因为在 Go 中 map 的 key 的类型必须是可比较的。因此将 K 设为 comparable 就是非常必要的了，你可以使用 K 来作为 map 的key。同时保证了调用者只使用被允许的类型的 key。</li><li>指定 V 的类型约束为 int64 和 float64 两种类型的联合类型。使用操作符｜指定两种类型的联合类型，表示该约束允许其中的任意一种类型。编译器允许这两种类型作为参数的类型传入函数。</li><li>指定了 m 的类型为 map[K]V，K，V 的类型已经被类型参数所指定了。需要注意的是， map[K]V 是一个合法的 map 类型，因为K 已经被声明为 comparable 了。如果没有将 K 声明为 comparable，编译器将拒绝 map[K]V 的使用</li></ul></li><li><p>在 main.go 中，粘贴下面的代码到原有代码的下方</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums: %v and %v\n&quot;</span>,<br>    SumIntsOrFloats[<span class="hljs-type">string</span>, <span class="hljs-type">int64</span>](ints),<br>    SumIntsOrFloats[<span class="hljs-type">string</span>, <span class="hljs-type">float64</span>](floats))<br></code></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>调用了刚才定义的泛型函数，传入了创建的 map</p></li><li><p>指定了类型参数 –  包含在方括号中的类型的名称 - 表明在调用时需要被替换的类型参数的类型</p><p>正如下一节中看到的，通常可以在函数调用中省略类型参数。Go编译器通常可以从你的代码中推断它们。</p></li><li><p>打印函数的返回值</p></li></ul></li></ol><h4 id="运行代码-1"><a href="#运行代码-1" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br></code></pre></td></tr></table></figure><p>要运行代码，在每次调用中，编译器都会将类型参数替换为该调用中指定的具体类型。</p><p>在调用泛型函数时，通过指定类型参数，来告诉编译器使用哪些类型来代替函数的类型参数。</p><h3 id="在调用泛型函数时移除类型参数"><a href="#在调用泛型函数时移除类型参数" class="headerlink" title="在调用泛型函数时移除类型参数"></a>在调用泛型函数时移除类型参数</h3><p>在本节中，你将添加泛型函数调用的修改版本，进行小幅更改以简化调用代码。将会删除类型参数，在这种情况下，这些参数不需要。</p><p>当Go编译器可以推断要使用的类型时，可以在调用代码时省略类型参数。编译器从函数参数的类型中推断类型参数。</p><p>请注意，这并不总是可行的。例如，如果在需要调用没有参数的泛型函数时，需要在函数调用中包含类型参数。</p><h4 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h4><ul><li><p>在 main.go 中，粘贴下面的代码到原有代码的下方</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,<br>    SumIntsOrFloats(ints),<br>    SumIntsOrFloats(floats))<br></code></pre></td></tr></table></figure><p> 在这段代码中：</p><ul><li>调用了泛型函数，并省略了类型参数</li></ul></li></ul><h4 id="运行代码-2"><a href="#运行代码-2" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br>Generic Sums, type parameters inferred: 46 and 62.97<br></code></pre></td></tr></table></figure><p>接下来，你会定义一个可以重用的类型约束，该约束的类型为整数和浮点的联和类型，通过在代码中使用该约束来进一步简化代码。</p><h3 id="定义类型约束"><a href="#定义类型约束" class="headerlink" title="定义类型约束"></a>定义类型约束</h3><p>在最后这一节，你将会把之前定义的约束放进它自己的 interface 中，这样的话就可以在不同的地方重用它了。以这种方式声明约束有助于简化代码，例如当约束更复杂时。</p><p>你可以将类型约束定义为一个 interface。约束允许任何类型去实现接口。例如，声明了一个具有三种方法的类型约束接口，然后将其与泛型函数中的类型参数一起使用，则用于调用函数的类型参数必须具有所有的这些方法。</p><p>约束接口也可以引用特定类型，您将在本节中看到。</p><h4 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>就在 main 函数的上方，在导入语句之后，粘贴以下代码以声明类型约束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Number <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int64</span> | <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>声明要用作类型约束的Number接口类型。</p></li><li><p>在接口内部声明了 int64 | float64 的联合类型。</p><p>本质上，是将联合类型从函数声明移动到新的类型约束中。这样，当你想将类型参数限制为int64或float64时，就可以使用此Number 类型约束，而不是写出 int64 ｜float64。</p></li></ul></li><li><p>在原有函数的下方，粘贴下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SumNumbers sums the values of map m. It supports both integers</span><br><span class="hljs-comment">// and floats as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumNumbers</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">Number</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li>以与之前声明的泛型函数相同的逻辑声明泛型函数，但使用新的接口类型而不是联合作为类型约束。和之前前一样，使用参数和返回类型的类型参数</li></ul></li><li><p>在 main.go 中，原有代码的下方，粘贴下列代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,<br>    SumNumbers(ints),<br>    SumNumbers(floats))<br></code></pre></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>对每个 map 调用 SumNumbers，并打印每个结果。</p><p>与上一节一样，在对泛型函数的调用中省略了类型参数（方括号内的类型名称）。Go编译器可以从其他参数推断类型参数。</p></li></ul></li></ol><h4 id="运行代码-3"><a href="#运行代码-3" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br>Generic Sums, type parameters inferred: 46 and 62.97<br>Generic Sums with Constraint: 46 and 62.97<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Number <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int64</span> | <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Initialize a map for the integer values</span><br>    ints := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-number">34</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">12</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize a map for the float values</span><br>    floats := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-number">35.98</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">26.99</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,<br>        SumInts(ints),<br>        SumFloats(floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums: %v and %v\n&quot;</span>,<br>        SumIntsOrFloats[<span class="hljs-type">string</span>, <span class="hljs-type">int64</span>](ints),<br>        SumIntsOrFloats[<span class="hljs-type">string</span>, <span class="hljs-type">float64</span>](floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,<br>        SumIntsOrFloats(ints),<br>        SumIntsOrFloats(floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,<br>        SumNumbers(ints),<br>        SumNumbers(floats))<br>&#125;<br><br><span class="hljs-comment">// SumInts adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-type">int64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumFloats adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-type">float64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumIntsOrFloats sums the values of map m. It supports both floats and integers</span><br><span class="hljs-comment">// as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumIntsOrFloats</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">int64</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumNumbers sums the values of map m. Its supports both integers</span><br><span class="hljs-comment">// and floats as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumNumbers</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">Number</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Cloudflare worker搭建壁纸服务</title>
    <link href="/post/cloudflare-wallpaper-server.html"/>
    <url>/post/cloudflare-wallpaper-server.html</url>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因是记录一下自己为博客首页设置主题图的过程。</p><p>当前博客的主题使用的是 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>, 可以在主页设置主题图。一开始使用的是默认的图片，但是觉得不够个性化，于是就想设置一个专属的图片。</p><p>在思考选用何种图片的过程中，萌发了一个新的想法💡，就是让自己的主题图片定期去变化。但是并不想每次去手动修改图片的链接。于是便想搭建一个图片的服务，可以定期更新图片。</p><p>在思考如何搭建服务时，突然想到 <a href="https://www.bing.com/">bing</a> 的每日背景图片都会改变，刚好符合我的要求。借助 bing 的接口，我只需要搭建一个静态的链接服务，将图片请求重定向至 bing 的图片链接即可。</p><h3 id="获取-bing-的图片接口"><a href="#获取-bing-的图片接口" class="headerlink" title="获取 bing 的图片接口"></a>获取 bing 的图片接口</h3><p>根据 <a href="https://stackoverflow.com/a/18096210/16435968">stackoverflow 上的回答</a> 获取到了 bing 的每日接口请求，获取不同响应接口体的接口如下:</p><blockquote><p><strong>XML:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p><p><strong>JSON:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p><p><strong>RSS:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p></blockquote><p>使用 <a href="https://httpie.io/">httpie</a> 测试响应的接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">http <span class="hljs-string">&quot;http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US&quot;</span></span><br></code></pre></td></tr></table></figure><p>响应的 Body 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;images&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;bot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;copyright&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Flamenco dancers outside Palma de Majorca, Spain (© Torleif Svensson/Getty Images)&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;copyrightlink&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.bing.com/search?q=flamenco+dance&amp;form=hpcapt&amp;filters=HpDate%3a%2220220216_1830%22&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;drk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;enddate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;20220217&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;fullstartdate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;202202161830&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hsh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6c3f5fff2e9235dd83cbc3e5353c5263&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;quiz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20220216_FlamencoDance%22&amp;FORM=HPQUIZ&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;startdate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;20220216&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The art of flamenco&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;top&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/th?id=OHR.FlamencoDance_EN-IN6108897298_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;urlbase&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/th?id=OHR.FlamencoDance_EN-IN6108897298&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;wp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tooltips&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;loading&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Loading...&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;next&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Next image&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;previous&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Previous image&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;walle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;This image is not available to download as wallpaper.&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;walls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Download this image. Use of this image is restricted to wallpaper only.&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到 images 下的 url 便是我们需要的图片链接。拼接 url 并请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">http <span class="hljs-string">&quot;https://www.bing.com/th?id=OHR.FlamencoDance_EN-IN6108897298_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&quot;</span> &gt; wallpapre.jpg</span><br></code></pre></td></tr></table></figure><p>就可以得到当前 bing 的壁纸了。到这里我们就理顺了如何获取到图片的流程，接下来就是搭建图片服务了</p><h3 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h3><p>如果从零开始，购买服务器并搭建图片服务，对于我需求来说做的额外工作是在是太多了。</p><p>于是我使用<a href="https://workers.cloudflare.com/"> cloudflare woker</a>， 使用 woker 不仅可以快速的搭建一个免费的服务，并且还可以获得一个域名。</p><p>cloudflare 的免费账号的每日请求数也足够使用了，本着能省一点是一点的原则，我选择了它。</p><p>首先是注册一个 cloudflare 的账号，并完成响应的设置。</p><p>然后就是构建一个 woker 了，在 woker 的 <a href="https://dash.cloudflare.com/3ebe93d1a2f956916b44850bff6cf618/workers/overview">dashbord</a> 选择 <strong>创建服务</strong>，定好名称，我的名字是 wallpaper，选择默认的启动器即可，点击创建服务即可。</p><p>完成服务的创建之后，选中你的 woker，点击快速编辑，将触发器的代码填入，点击保存并部署。</p><p>触发器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    <span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">catch</span>(<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(err.<span class="hljs-property">stack</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">500</span> &#125;)<br>    )<br>  );<br>&#125;);<br><br><span class="hljs-keyword">const</span> base = <span class="hljs-string">&quot;http://www.bing.com&quot;</span><br><span class="hljs-keyword">const</span> statusCode = <span class="hljs-number">302</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US&quot;</span>)<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">json</span>()<br>  <span class="hljs-keyword">const</span> image = data[<span class="hljs-string">&quot;images&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;url&quot;</span>]<br>  <span class="hljs-keyword">const</span> destinationURL = base + image<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">redirect</span>(destinationURL, statusCode)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，服务就部署完成了，在浏览器输入服务的地址，就可以看到图片的展示效果了。</p><p>总共花费半天时间，0 ¥。</p>]]></content>
    
    
    
    <tags>
      
      <tag>serverless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Go 没有引用值</title>
    <link href="/post/go-has-no-refrence-value.html"/>
    <url>/post/go-has-no-refrence-value.html</url>
    
    <content type="html"><![CDATA[<p>在别的一些语言中，调用函数时，有传值以及传引用的区别，但是在 Go 中，没有传引用这样的说法。</p><p>Go 只有传值，Go 只有传值，Go 只有传值！！！</p><p>重要的事情说三遍。因此对于函数传参来说传入的值会被复制</p><ul><li>对于基本类型来说，会直接复制相应的值传入其中</li><li>对于自自定义的结构体，也会复制然后传入其中</li><li>对于指针，会复制一个新的指针，指向原指针的值，因此传入指针可以修改原有的值</li><li>对于 map/slice/chan 来说，他们是内置的特殊结构体，内部包含了指向底层数据的指针，因此传入 map/slice/chan 可以修改原有的值</li><li>对于 array 来说，会复制产生一个新的 array，因此如果需要在函数中修改原有数组中的值，需要传入一个 array 指针。因为 array 的特殊性, <a href="https://go.dev/doc/effective_go#arrays">相关博客</a></li></ul><p>归纳为一句话：在 Go 中所有值赋值，包括参数传递等，都是<strong>浅值复制</strong>（指针指向的值不会被复制）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 单例模式</title>
    <link href="/post/golang-singleton-parttern.html"/>
    <url>/post/golang-singleton-parttern.html</url>
    
    <content type="html"><![CDATA[<p>单例模式是一种最基本的设计模式，属于创造模式的一种。在应用了单例模式的时候，类的实例在全局中只会存在一个。实例也只会被创建一次。通常用于系统只需要拥有一个全局对象的时候。例如数据库连接对象。</p><p>单例模式分为懒汉和饿汉模式两种。</p><p>首先是饿汉模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *object = &amp;object&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span></span> *object &#123;<br><span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>在包初始化的过程中就完成了对象的初始化工作，然后调用函数直接返回实例对象即可。</p><p>但是由于是在导入包的过程中初始化对象，会造成加载时间过长。</p><p>然后就是懒汉模式，懒汉模式是在实际调用时才会去创建对象的实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *object<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span></span> *object &#123;<br>    <span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>        instance = &amp;object&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>在判断实例变量为<code>nil</code>时，才会去创建对象。但是直接这样写会带来并发上的问题。如果多个 goroutine 调用方法，会创建出多个实例来。因此为了保障并发安全，可以对其中的逻辑进行加锁的操作。</p><p>但是在 Go 中还有另外的一种方式，那就是借助 <code>once.Do</code> 来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> (<br>  instance *object<br>  once sync.Once<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span></span> *object &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      instance = &amp;object&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Once.Do，既保证了对象会被初始化一次，也保证了并发下只创建一个对象。</p><p>因此，如果需要在 Go 中应用单例模式，那么最好的选择就是使用 Once.Do 方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在云主机上安装 k3s</title>
    <link href="/post/install-k3s-on-cloud-instance.html"/>
    <url>/post/install-k3s-on-cloud-instance.html</url>
    
    <content type="html"><![CDATA[<p>K3s 是一个轻量化的 Kubernetes 集群软件，专门针对 IoT 和边缘计算(Edge computing)设备开发的，适合低配置硬件的设备上使用。</p><p>可以用于在低配置的云主机上进行部署。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 k3s 只需要一条命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=<span class="hljs-string">&quot;644&quot;</span> sh -s -</span><br></code></pre></td></tr></table></figure><p>K3S_KUBECONFIG_MODE 是为了避免在宿主机上使用 kubectl 命令时遇到权限问题。</p><p>但是如果是在云主机上安装，如果公网 IP 没有绑定到主机上，用 ifconfig 无法看到，那么就需要添加如下的命令，否则无法从公网通过config 文件访问到集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sLS https://get.k3s.io | K3S_KUBECONFIG_MODE=&quot;644&quot; INSTALL_K3S_EXEC=&#x27;server --tls-san x.x.x.x&#x27; sh -<br></code></pre></td></tr></table></figure><p><code>x.x.x.x</code>为云主机的公网IP。</p><p>完成后将配置文件拷贝到本机即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp x.x.x.x:/etc/rancher/k3s/k3s.yaml ~/.kube/</span><br></code></pre></td></tr></table></figure><p>修改 k3s.yaml </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <span class="hljs-string">https://x.x.x.x:6443</span><br></code></pre></td></tr></table></figure><p>完成后测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> KUBECONFIG=~/.kube/k3s.yaml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span><br></code></pre></td></tr></table></figure><h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p>如果服务器对于下载链接的访问有问题，可以通过离线安装的方式进行安装</p><p>首先下载需要的可执行文件，<a href="https://github.com/rancher/k3s/releases">下载地址</a></p><p>然后下载安装脚本：<a href="https://get.k3s.io](https://get.k3s.io/)">https://get.k3s.io](https://get.k3s.io/)</a> </p><p>将二进制文件放在每个节点的<code>/usr/local/bin</code>中，并确保拥有可执行权限。将安装脚本放在每个节点的任意位置，并将其命名为<code>install.sh</code></p><p>最后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">INSTALL_K3S_SKIP_DOWNLOAD=true ./install.sh<br></code></pre></td></tr></table></figure><h2 id="添加-woker-节点"><a href="#添加-woker-节点" class="headerlink" title="添加 woker 节点"></a>添加 woker 节点</h2><p>如果需要添加额外的 worker 节点到集群，只需要添加 <code>K3S_TOKEN</code> 即可。</p><p>在 master 节点上查看 token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span>  /var/lib/rancher/k3s/server/node-token</span><br></code></pre></td></tr></table></figure><p> 然后在需要添加的 woker 节点上输入如下的命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -</span><br></code></pre></td></tr></table></figure><p>添加完成后，查看所有节点状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span><br></code></pre></td></tr></table></figure><p>默认情况下新增的节点角色为 <code>none</code>, 可以通过 <code>kubectl</code>为节点添加角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label nodes &lt;nodes-name&gt; kubernetes.io/role=worke</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 的时间格式</title>
    <link href="/post/time-format-of-go.html"/>
    <url>/post/time-format-of-go.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 中如果你需要解析一个自定义的时间字符串，将其转化为 Go 的 <code>time.Time</code> 类型，或者格式化的输出时间，那么你需要定义一个 layout。</p><p>在这一步就会容易出现错误，不同于其他语言以形如 <code>yyyy-MM-dd HH:mm:ss</code> 的格式解析，Go 是以一个特定的时间来确定格式, 即 **<code>2006-01-02T15:04:05Z07:00</code>**。</p><p>因此，如果你需要使用 Go 来解析一个时间字符串， 那么你可能就需要写如下的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br>fmt.Println(t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>t, err := time.Parse(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="hljs-string">&quot;2019-01-01 12:00:00&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>&#125;<br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// 2021-12-14 16:46:19</span><br><span class="hljs-comment">// 2019-01-01 12:00:00</span><br></code></pre></td></tr></table></figure><p>在 Go 中，时间的格式都是 <code>20060102150405</code> 的格式变种。</p><p>那么看到这里，肯定会觉得奇怪，为什么 Go 会选用这样的一个时间来作为格式化的标准。</p><p>实际上，这个时间中的<code>0 1 2 3 4 5 6</code>对应了 Posix 下 date 命令的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Mon Jan 2 15:04:05 -0700 MST 2006<br>0   1   2  3  4  5              6<br></code></pre></td></tr></table></figure><p><code>7</code> 对应的就是中间的时区。</p><p>因此想要转化时间不出错，需要记住这个时间点，也就是星期，月，日，时，分，秒，年的，从 0 递增的一个序列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 配置 HTTP Basic Auth</title>
    <link href="/post/nginx-basic-auth.html"/>
    <url>/post/nginx-basic-auth.html</url>
    
    <content type="html"><![CDATA[<p>Nginx 是一个被广泛使用的 Web 服务器，代理服务器。本文主要介绍如何为 Nginx 配置 HTTP Basic Auth。(演示环境为 macOS)</p><p>Basic Auth 是一个非常简单的认证方式，在请求的 Header 中会包含<code>Authorization</code>字段，形式如下： <code>Authorization: Basic &lt;凭证&gt;</code>，该凭证是用户和密码的组和的 base64 编码。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>在开始之前需要准备好环境，如果在直接在本机安装，可能会与已有的服务冲突，为了方便起见，在 docker 中运行 nginx来进行实验。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull nginx:latest</span><br></code></pre></td></tr></table></figure><h3 id="配置-HTTP-Basic-Auth-证书"><a href="#配置-HTTP-Basic-Auth-证书" class="headerlink" title="配置 HTTP Basic Auth 证书"></a>配置 HTTP Basic Auth 证书</h3><p>在这一步我们将会为站点创建用户名密码。</p><p>存储用户名密码的文件会由我们指定好，直接在当前目录下创建 <code>test.htpasswd</code>文件，并且将用户名设置为 <code>nginx</code>。</p><p>运行下面的命令，来配置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">htpasswd -c test.htpasswd nginx</span><br></code></pre></td></tr></table></figure><p>完成后，可以查看文件的内容来确定配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> test.htpasswd</span><br>nginx:$apr1$9Pn6zJkQ$PcOGDRG/i.mpLn8jCEYui.<br></code></pre></td></tr></table></figure><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>完成用户名密码的配置后，需要对 nginx 的配置文件进行修改，在当前目录创建一个 default.conf 配置文件，并在之后挂载到容器内。</p><p>拷贝一份配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --<span class="hljs-built_in">rm</span> -d --name nginx nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/conf.d/default.conf  .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop nginx</span><br></code></pre></td></tr></table></figure><p>使用编辑器修改配置文件，添加 auth_basic</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs NGINX">...<br><span class="hljs-attribute">server_name</span> localhost;<br><br><span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br> <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-attribute">auth_basic</span> <span class="hljs-string">&quot;Private Property&quot;</span>;<br>        <span class="hljs-comment"># 指定配置文件</span><br>        <span class="hljs-attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>启动容器，并测试我们的配置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --<span class="hljs-built_in">rm</span> -d -p 8080:80 --name nginx -v <span class="hljs-variable">$PWD</span>/test.htpasswd:/etc/nginx/.htpasswd -v  <span class="hljs-variable">$PWD</span>/default.conf:/etc/nginx/conf.d/default.conf nginx</span><br></code></pre></td></tr></table></figure><p>打开浏览器，输入<a href="http://localhost:8080/">http://localhost:8080</a> 就可以看到，网页提示我们输入用户名密码了，输入正确的用户名密码后，才能看到欢迎页。</p><p>到此，为 nginx 配置 basic auth 就完成了。更多的配置可以参考 <a href="https://docs.nginx.com/">Nginx 官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 20.04 安装 Podman</title>
    <link href="/post/install-podman-on-unbunutu-20.04.html"/>
    <url>/post/install-podman-on-unbunutu-20.04.html</url>
    
    <content type="html"><![CDATA[<p>Podman 是一款用于开发运行测试容器和镜像的工具，不同于 Docker，他不需要 root 权限就可以运行。同时 Docker 需要 Docker Engine 以 Daemon 的形式运行，而 Podman 则不需要。</p><p>这篇文章介绍如何在 Ubuntu 20.04 上安装 Podman</p><p>在安装 Podman 之前需要安装依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install curl wget gnupg2 -y</span><br></code></pre></td></tr></table></figure><p>接下来就是添加 Podman 的仓库源, 添加 GPG 的 key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> /etc/os-release</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh -c <span class="hljs-string">&quot;echo &#x27;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="hljs-variable">$&#123;VERSION_ID&#125;</span>/ /&#x27; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_<span class="hljs-variable">$&#123;VERSION_ID&#125;</span>/Release.key -O- | sudo apt-key add -</span><br></code></pre></td></tr></table></figure><p>完成上述配置后就可以更新并安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y podman</span><br></code></pre></td></tr></table></figure><p>安装完成后就可以确定一下状态了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">podman --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">podman info</span><br></code></pre></td></tr></table></figure><p>这样就可以完成在 Ubuntu 20.04 上安装 podman 了。接下里就可以愉快的与 Podman 玩耍了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 nvim</title>
    <link href="/post/setup-nvim.html"/>
    <url>/post/setup-nvim.html</url>
    
    <content type="html"><![CDATA[<p>手贱修改了一次电脑的配置，导致之前的 vim 重装，并丢失了相关的配置，本文记录一下重现安装并且配置的过程，作为备忘，在下次遇到相关的问题时，可以更快的恢复。</p><p>首先是安装 neovim，这里不选择 vim 的原因是听网上的推荐， neovim 更为现代化一点，所以尝试使用 neovim 替代 vim。</p><p>直接通过 <code>brew</code> 安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install neovim</span><br></code></pre></td></tr></table></figure><p>键入 nvim 就可以使用了，不想每次都输入 nvim，于是在 <code>.zshrc</code> 下添加一个 alias</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">alias vim=&quot;nvim&quot;<br></code></pre></td></tr></table></figure><p>这样所有的 vim 都实际上使用的是 nvim 了。</p><p>接下来就是配置 nvim.</p><h2 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h2><p>nvim 的默认配置文件是 <code>~/.config/nvim/init.vim</code>, 如果目录不存在，需要新建目录,  并且创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p  ~/.config/nvim/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set nu&quot;</span> &gt; ~/.config/nvim/init.vim</span><br></code></pre></td></tr></table></figure><p>添加最基本的配置，显示行号。然后就是插件的安装了</p><h2 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2. 配置插件"></a>2. 配置插件</h2><p>依托于丰富的插件，vim 可以获得媲美 IDE 的体验，在安装插件之前，首先需要先安装好插件管理器来帮助我们管理 vim 的插件。</p><p>首先安装 <code>pynvim</code>, 来支持 python 书写的插件.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --user --upgrade pynvim<br></code></pre></td></tr></table></figure><p>插件管理器选用 <a href="https://github.com/junegunn/vim-plug.git">vim-plug</a>，路径是 <code>&quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \<br>       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;<br></code></pre></td></tr></table></figure><p>完成之后就可以开始安装所需要的插件了，编辑 <code>~/.config/nvim/init.vim</code> 文件，新增如下的内容</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-comment">&quot; 指定插件的安装位置</span><br><span class="hljs-keyword">call</span> plug#begin(<span class="hljs-string">&#x27;~/.vim/plugged&#x27;</span>)<br><br><br><span class="hljs-comment">&quot; 插件引入的形式为 Plug &#x27;plugin-url&#x27;</span><br><span class="hljs-comment">&quot; 使用单引号包裹路径，双引号会被视作注释</span><br><span class="hljs-comment">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br>Plug <span class="hljs-string">&#x27;junegunn/vim-easy-align&#x27;</span><br><br><span class="hljs-comment">&quot; Any valid git URL is allowed</span><br>Plug <span class="hljs-string">&#x27;https://github.com/junegunn/vim-github-dashboard.git&#x27;</span><br><br><span class="hljs-comment">&quot; Multiple Plug commands can be written in a single line using | separators</span><br>Plug <span class="hljs-string">&#x27;SirVer/ultisnips&#x27;</span> | Plug <span class="hljs-string">&#x27;honza/vim-snippets&#x27;</span><br><br><span class="hljs-comment">&quot; On-demand loading</span><br>Plug <span class="hljs-string">&#x27;scrooloose/nerdtree&#x27;</span>, &#123; <span class="hljs-string">&#x27;on&#x27;</span>:  <span class="hljs-string">&#x27;NERDTreeToggle&#x27;</span> &#125;<br>Plug <span class="hljs-string">&#x27;tpope/vim-fireplace&#x27;</span>, &#123; <span class="hljs-string">&#x27;for&#x27;</span>: <span class="hljs-string">&#x27;clojure&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Using a non-default branch</span><br>Plug <span class="hljs-string">&#x27;rdnetto/YCM-Generator&#x27;</span>, &#123; <span class="hljs-string">&#x27;branch&#x27;</span>: <span class="hljs-string">&#x27;stable&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br>Plug <span class="hljs-string">&#x27;fatih/vim-go&#x27;</span>, &#123; <span class="hljs-string">&#x27;tag&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Plugin options</span><br>Plug <span class="hljs-string">&#x27;nsf/gocode&#x27;</span>, &#123; <span class="hljs-string">&#x27;tag&#x27;</span>: <span class="hljs-string">&#x27;v.20150303&#x27;</span>, <span class="hljs-string">&#x27;rtp&#x27;</span>: <span class="hljs-string">&#x27;vim&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;~/.fzf&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>: <span class="hljs-string">&#x27;./install --all&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Unmanaged plugin (manually installed and updated)</span><br>Plug <span class="hljs-string">&#x27;~/my-prototype-plugin&#x27;</span><br><br>Plug <span class="hljs-string">&#x27;altercation/vim-colors-solarized&#x27;</span><br><br><span class="hljs-keyword">call</span> plug#end()<br></code></pre></td></tr></table></figure><p>然后输入 <code>PlugInstall</code> 命令，就会自动下载安装指定的插件了.</p><p> 删除插件只需要移除对应的插件声明，在运行 <code>PlugClean</code> 命令即可.</p><h2 id="3-优化配置"><a href="#3-优化配置" class="headerlink" title="3. 优化配置"></a>3. 优化配置</h2><p>设置主题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> background=dark<br><span class="hljs-keyword">colorscheme</span> solarized<br></code></pre></td></tr></table></figure><p>设置 NerdTree</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;F10&gt;</span> :NERDTreeToggle<span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">nmap</span> <span class="hljs-symbol">&lt;M-m&gt;</span> :NERDTreeFind<span class="hljs-symbol">&lt;CR&gt;</span><br><br><span class="hljs-keyword">let</span> NERDTreeShowLineNumbers=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> NERDTreeAutoCenter=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> NERDTreeShowHidden=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">let</span> NERDTreeIgnore=[<span class="hljs-string">&#x27;\.pyc&#x27;</span>,<span class="hljs-string">&#x27;\~$&#x27;</span>,<span class="hljs-string">&#x27;\.swp&#x27;</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:nerdtree_tabs_open_on_console_startup</span>=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:NERDTreeGitStatusIndicatorMapCustom</span> = &#123;<br>    \ <span class="hljs-string">&quot;Modified&quot;</span>  : <span class="hljs-string">&quot;✹&quot;</span>,<br>    \ <span class="hljs-string">&quot;Staged&quot;</span>    : <span class="hljs-string">&quot;✚&quot;</span>,<br>    \ <span class="hljs-string">&quot;Untracked&quot;</span> : <span class="hljs-string">&quot;✭&quot;</span>,<br>    \ <span class="hljs-string">&quot;Renamed&quot;</span>   : <span class="hljs-string">&quot;➜&quot;</span>,<br>    \ <span class="hljs-string">&quot;Unmerged&quot;</span>  : <span class="hljs-string">&quot;═&quot;</span>,<br>    \ <span class="hljs-string">&quot;Deleted&quot;</span>   : <span class="hljs-string">&quot;✖&quot;</span>,<br>    \ <span class="hljs-string">&quot;Dirty&quot;</span>     : <span class="hljs-string">&quot;✗&quot;</span>,<br>    \ <span class="hljs-string">&quot;Clean&quot;</span>     : <span class="hljs-string">&quot;✔︎&quot;</span>,<br>    \ <span class="hljs-string">&#x27;Ignored&#x27;</span>   : <span class="hljs-string">&#x27;☒&#x27;</span>,<br>    \ <span class="hljs-string">&quot;Unknown&quot;</span>   : <span class="hljs-string">&quot;?&quot;</span><br>    \ &#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:NERDTreeGitStatusShowIgnored</span>= <span class="hljs-number">1</span><br><span class="hljs-keyword">nmap</span> <span class="hljs-symbol">&lt;Leader&gt;</span><span class="hljs-keyword">pwd</span> :NERDTreeCWD<span class="hljs-symbol">&lt;CR&gt;</span><br></code></pre></td></tr></table></figure><p>到这里就完成了基本的配置了，如果之后需要进一步的配置，就需要自己安装或者写一下插件，并且配置了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为何需要 Helm</title>
    <link href="/post/why-need-helm.html"/>
    <url>/post/why-need-helm.html</url>
    
    <content type="html"><![CDATA[<p>Kubernetes 在容器编排领域已经成为事实上的标准，一款云原生应用在开发周期的最后阶段都是会被部署到 k8s 集群之上。</p><p>部署在 k8s 上的应用在免去了拓展，迁移，服务发现等一系列工作的同时，也带来了其他的问题。</p><p>由于 Kubernetes 的资源都是声明式的，这意味着如果想要部署一款新的应用，那么就需要围绕应用所需的资源，以及其的元信息编写对应的 yaml 文件，包括不限于 service，deployment，configmap，secret 的资源定义。</p><p>如果是一款简单的应用还好，但是一旦应用比较复杂，依赖的资源比较多，那么编写资源文件就是一个痛苦的过程了，而且往往不是开发人员独自能够完成的，还需要和运维人员进行配合。</p><p>除此之外，每次升级应用，都需要一系列的工作，并且如果需要回滚应用的版本，那么就更加会运维开发人员感到痛苦了。</p><p>因此，为了解决这些问题，我们就需要 helm 来帮我们完成一些重复性的工作，根据模版来生成我们所需要的资源文件。</p><h2 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h2><p>helm 是一个Kubernetes 应用打包，管理工具。每个 kubernetes 上的应用被称之为一个 helm chart。</p><p>使用 helm 可以帮助我们来定义，升级，发布以及回滚应用。而不需要每次都复制粘贴，然后再修改。</p><p>如果将 Kubernetes 看作为一个操作系统话，那么 helm 就是系统的软件管理器，也可以将其看作是一个 APP store。</p><p>通过修改 helm 生成的模版值，完成应用的打包，之后就可以将应用推送到不同的仓库。在需要安装应用的集群上只需要运行 helm upgrade 就可以完成安装了。免去了一堆的烦恼。</p><h2 id="helm-的一些概念"><a href="#helm-的一些概念" class="headerlink" title="helm 的一些概念"></a>helm 的一些概念</h2><h3 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a><em>Chart</em></h3><p>Chart 是 helm 的打包格式，它有一系列相关的 Kubernetes 资源文件组成。每个 chart 都相当于一个应用，不论是一个简单的单 pod 应用，还是一个包含多个服务，以及数据库，缓存等功能的复杂应用。</p><p>当完成资源文件的配置之后，就可以发布新版本的应用了。</p><p>chart 的文件结构</p><figure class="highlight graphql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs graphql">wordpress/<br>  Chart.yaml          <span class="hljs-comment"># A YAML file containing information about the chart</span><br>  LICENSE             <span class="hljs-comment"># OPTIONAL: A plain text file containing the license for the chart</span><br>  README.md           <span class="hljs-comment"># OPTIONAL: A human-readable README file</span><br>  values.yaml         <span class="hljs-comment"># The default configuration values for this chart</span><br>  values.<span class="hljs-keyword">schema</span>.json  <span class="hljs-comment"># OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file</span><br>  charts/             <span class="hljs-comment"># A directory containing any charts upon which this chart depends.</span><br>  crds/               <span class="hljs-comment"># Custom Resource Definitions</span><br>  templates/          <span class="hljs-comment"># A directory of templates that, when combined with values,</span><br>                      <span class="hljs-comment"># will generate valid Kubernetes manifest files.</span><br>  templates/NOTES.txt <span class="hljs-comment"># OPTIONAL: A plain text file containing short usage notes</span><br></code></pre></td></tr></table></figure><p>每个 chart 都需要有对应的版本号。例如：<code>nginx-1.2.3.tgz</code> 代表这是一个 1.2.3 版本的 nginx 应用。</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a><em>Repository</em></h3><p>Repository 是一个存放，分享 chart 的地方。在完成指定版本的 chart 后，可以将其推送到指定的 repository 中，其他需要使用的人就可以从对应的 repository 拉取到想要的 chart 并启动。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a><em>Release</em></h3><p>Release 是一个运行在 Kubernetes 上的 chart 的实例。chart 是可以在集群上多次安装的，每次安装一个 chart 都会产生一个 release。</p><p>同样的，如果需要两个实例同时运行，那么只需要安装 chart 两次即可，这样集群上就会有两个 release，并且每个 release 都有着自己的名字。</p><p>以面向对象的思想来看的话，chart 就是一个类，而 release 就是 chart 的实例对象。</p><p>以上就是关于为什么需要 helm 以及 helm 的基本概念，需要了解更多的信息可以阅读<a href="https://helm.sh/docs/">官方文档</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Mac 上安装数据库</title>
    <link href="/post/install-database-on-mac.html"/>
    <url>/post/install-database-on-mac.html</url>
    
    <content type="html"><![CDATA[<p>在日常的开发过程中，通常需要使用到数据库。</p><p>在本地安装开发用的数据库有两种做法，一是使用 docker 起一个 container，二是直接安装数据库服务。</p><p>对于容器来说，优点在于可以快速的启动服务，并且在使用后清理干净，但是在 Mac 上使用 docker 会有文件效率的影响，并且在 Apple silicon 的 docker 只能使用 arm 架构的镜像，因此可以选择直接安装对应的数据库服务。</p><p>借助于 <code>homebrew</code> 可以快速的安装原生的服务。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>安装 mysql 只需键入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install mysql</span><br></code></pre></td></tr></table></figure><p>然后等待安装完成。需要的时间可能会稍微长一点，因为 homebrew 会从源码编译。</p><p>安装完成后就可以启动 mysql 了，完成安全安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew services start mysql</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql_secure_installation</span> <br></code></pre></td></tr></table></figure><p>默认状态下，mysql 只绑定在 127.0.0.1，需要修改设置，配置文件在 <code>/opt/homebrew/etc/my.cnf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /opt/homebrew/etc/my.cnf</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Default Homebrew MySQL server config</span><br>[mysqld]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only allow connections from localhost</span><br>bind-address = 127.0.0.1<br>mysqlx-bind-address = 127.0.0.1<br></code></pre></td></tr></table></figure><p>将 <code>bind-address = 127.0.0.1</code> 改为 <code>bind-address = 0.0.0.0</code></p><p>允许 root 从任何 host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.user SET Host=&#x27;%&#x27; WHERE Host=&#x27;localhost&#x27; AND User=&#x27;username&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install redis</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew services start redis</span><br></code></pre></td></tr></table></figure><p>测试服务是否在运行, 返回 PONG 则说明服务正常运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli ping</span><br></code></pre></td></tr></table></figure><p>修改配置文件 <code>/opt/homebrew/etc/redis.conf</code></p><p>一些 redis 的快速命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有数据库里的所有 key</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli FLUSHALL</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除当前数据库的所有 key</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli FLUSHDB</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定数据库的所有 key</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -n &lt;database_number&gt; FLUSHDB</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前数据库所有 key</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli keys <span class="hljs-string">&quot;*&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取指定数据库的所有 key</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -n &lt;database_number&gt; keys <span class="hljs-string">&quot;*&quot;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化 Go 项目</title>
    <link href="/post/go-project-setup.html"/>
    <url>/post/go-project-setup.html</url>
    
    <content type="html"><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>初始化一个 Go web 项目的步骤。</p><p>首先是创建项目的的文件夹，并初始化 <code>go.mod</code>,  假设项目的远端地址为 <code>github.com/someone/someproject.git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> PROJECT_NAME<br>$ <span class="hljs-built_in">cd</span> PROJECT_NAME<br>$ go mod init github.com/someone/someproject<br></code></pre></td></tr></table></figure><p>项目的布局结构可以参考 <a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a></p><h2 id="配置-makefile"><a href="#配置-makefile" class="headerlink" title="配置 makefile"></a>配置 makefile</h2><p>这样就完成了项目的第一步，接下来就是配置一些项目构建的脚本，一般都是使用 <code>makefile</code> 来作为项目的管理方式。下面是一个常见的makefile 配置</p><p>首先是帮助信息，通过输入 make help 获取到当前 makefile 的 target 和用法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">## help: Show help message</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: help</span><br><span class="hljs-section">help: Makefile</span><br>@echo <span class="hljs-string">&quot;\nUsage: make &lt;TARGETS&gt;&quot;</span><br>@sed -n &#x27;s/^<span class="hljs-comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span><br></code></pre></td></tr></table></figure><p>然后是常用的编译，测试命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">## build: build the project</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: build</span><br><span class="hljs-section">build:</span><br>@go build cmd/main.go<br><br><span class="hljs-comment">## test: run tests</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: test</span><br><span class="hljs-section">test:</span><br>@go test -v  ./...<br></code></pre></td></tr></table></figure><p>如果项目需要用到第三方的 go 工具，可以项目中加上类似下面的脚本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">## go.install.swag: install swag</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: go.install.swag</span><br><span class="hljs-section">go.install.swag:</span><br>@go install github.com/swaggo/swag/cmd/swag@latest<br></code></pre></td></tr></table></figure><h2 id="配置-swagger"><a href="#配置-swagger" class="headerlink" title="配置 swagger"></a>配置 swagger</h2><p>通常来说，接口的文档管理可以通过 swagger 来做，如果使用 gin 框架来做 web，那么就可以使用 <a href="https://github.com/swaggo/gin-swagger">gin- swagger</a>.</p><p> 下载安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go get -u github.com/swaggo/gin-swagger</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go get -u github.com/swaggo/files</span><br></code></pre></td></tr></table></figure><p>然后在路由注册处，注册 gin-swagger 的路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerfiles.Handler))<br></code></pre></td></tr></table></figure><p>同时需要在主入口处引入文档所在目录，并且添加对应的注释，具体可参见官方文档。</p><p>完成上述的基本配置之后，一个项目的框架就算是初步搭建完成了，之后就可以进行业务代码的书写了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 文件系统层次标准</title>
    <link href="/post/linux-fs-hierarchy-standard.html"/>
    <url>/post/linux-fs-hierarchy-standard.html</url>
    
    <content type="html"><![CDATA[<p>根据<a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.html#varlibVariableStateInformation">Linux 标准</a>,  记录下 Linux 文件系统下各个目录的作用，起到备忘的作用。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>首先是关于文件属性的说明，一个文件可以具备如下的两个属性，是否为 <code>static</code> 以及是否为 <code>shareable</code>。两个属性都不相同的文件就不应该放在同一个目录下。</p><p><code>Shareable</code>的文件，即可分享的文件，具有这种属性的文件可以被其他的主机使用，例如家目录下的用户文件。</p><p><code>Unshareable</code>的文件，即不可被分享的文件，具有这种属性的文件是不可以被其他主机所使用的，例如具有设备锁的文件。</p><p><code>Static</code>的文件包括库文件，二进制文件，文档文件以及其他如果没有管理员介入就不会变动的文件。<code>Unstatic</code>的文件则与之相反。</p><p>根据上述的文件属性，可以将文件目录划分为如下的表格：</p><table><thead><tr><th></th><th><strong>shareable</strong></th><th><strong>unshareable</strong></th></tr></thead><tbody><tr><td>static</td><td>/usr</td><td>/etc</td></tr><tr><td></td><td>/opt</td><td>/boot</td></tr><tr><td>unstatic</td><td>/var/mail</td><td>/var/run</td></tr><tr><td></td><td>/var/spool/news</td><td>/var/lock</td></tr></tbody></table><h3 id="目录及描述"><a href="#目录及描述" class="headerlink" title="目录及描述"></a>目录及描述</h3><p>根目录 “/” 下的路径</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>bin</td><td>基础命令的二进制文件目录</td></tr><tr><td>boot</td><td>boot 时需要的静态文件</td></tr><tr><td>dev</td><td>设备目录</td></tr><tr><td>etc</td><td>特定主机的配置文件</td></tr><tr><td>lib</td><td>基础分享库以及内核模块</td></tr><tr><td>media</td><td>媒体设备的挂载点</td></tr><tr><td>mnt</td><td>文件系统挂载点</td></tr><tr><td>opt</td><td>附加的软件包</td></tr><tr><td>run</td><td>与运行时程序相关的数据</td></tr><tr><td>sbin</td><td>基础系统可执行文件</td></tr><tr><td>srv</td><td>系统提供的服务数据</td></tr><tr><td>tmp</td><td>临时文件目录</td></tr><tr><td>usr</td><td>二级目录</td></tr><tr><td>var</td><td>动态文件</td></tr></tbody></table><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>在 *nix 系统下可以通过 man 命令来查看当前主机的目录与说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man hier</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多生产者关闭 Goroutine</title>
    <link href="/post/close-goroutines.html"/>
    <url>/post/close-goroutines.html</url>
    
    <content type="html"><![CDATA[<p>在本篇文章中，将介绍如何在多个生产者完成生产后关闭 goroutine.</p><p>在编程中，我们会遇到多个生产者，单一消费者的场景。</p><p>在这种情况下，工作流会分为了两个 stage:</p><ul><li>Stage 1: 多个生产者并发地计算结果，并将结果传入 channel</li><li>Stage 2: 消费者从 channel 中读取结果，做下一步的计算</li></ul><p>在两个 stage 完成工作后程序自然退出，因此需要在所有生产者完成工作后，关闭 channel。消费者在 channel 关闭后，结束运行并退出。</p><p>为了保证所有生产者，使用 sync.WaitGroup.</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>workN := <span class="hljs-number">5</span> <span class="hljs-comment">// 生产者数</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(workN)<br><br><span class="hljs-comment">// stage1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; workN; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>n := i * i<br>ch &lt;- n<br>wg.Done()<br>&#125;(i)<br>&#125;<br><br><span class="hljs-comment">// close channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><br><span class="hljs-comment">// stage 2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是 stage1，启动多个 Goroutine，通过闭包将 wg 传入，并且在完成任务后调用 wg.Done()。</p><p>然后启动另一个 Goroutine 用来关闭 channel，这个 Goroutine 会阻塞，直到所有的任务完成，最后关闭 channel。</p><p>最后就是 stage2，不停地从 channel 中读取数据，直到 channel 关闭，然后结束程序。</p><p>这样就完成了一个多生产者场景下 channel 关闭的问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 JWT 生成私钥</title>
    <link href="/post/generate-private-key-for-jwt.html"/>
    <url>/post/generate-private-key-for-jwt.html</url>
    
    <content type="html"><![CDATA[<p>今天在写一个登录鉴权的接口，用到了 JWT，JWT 的签名与认证需要用到一对公私钥。所以需要在本地生成一对密钥。</p><p>方法很简单，只需要用到 ssh-keygen 和 openssl 即可，如果命令行下没有这两个工具，可以通过 homebrew 来安装。</p><p>生成的方法代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先生成私钥文件，在生成过程中不要输入密码</span><br>ssh-keygen -t rsa -b 4096 -m PEM -f private.key<br><span class="hljs-comment"># 然后根据私钥生成对应的公钥</span><br>openssl rsa -<span class="hljs-keyword">in</span> private.key -pubout -outform PEM -out public.key.pub<br></code></pre></td></tr></table></figure><p>完成之后就会在当前文件夹产生两个文件，分别是私钥以及公钥。然后就可以利用它们去签发以及验证 token 了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是如何写程序的</title>
    <link href="/post/how-do-I-write-program..html"/>
    <url>/post/how-do-I-write-program..html</url>
    
    <content type="html"><![CDATA[<p>做为一名软件工程师，日常的工作就是去编写程序，写一段程序很简单，就比如 “hello world“。但是如果想要写好一段程序，就不是那么容易的事了，这篇文章主要是记录一下自己在编程时的一般流程。</p><h3 id="1-明确并且理解需求"><a href="#1-明确并且理解需求" class="headerlink" title="1. 明确并且理解需求"></a>1. 明确并且理解需求</h3><p>最近在读一本关于微服务架构的书，其中对需求有这样一个定义：</p><blockquote><p>需求是一个必须要解决的问题，以及围绕这个问题的特定上下文环境</p></blockquote><p>将每个开发任务当成需要解决的一道数学题。那么在解题的第一步就是要“读懂”题目， 也就是说理解题目在描述什么，并且明确问题的答案应该是什么。</p><p>所以在开始变编码之前一定要明确并且理解自己需要做什么，自己的产出会是什么。</p><p>如果将程序看作是对数据的一个映射，是一个函数，那么在确定好需要后，我们就可以得到如下的一个表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Output = F(Input)<br></code></pre></td></tr></table></figure><p>我们的任务就是完成函数 F, 在给定输入后，得到所需要的输出。</p><h3 id="2-分解编码步骤"><a href="#2-分解编码步骤" class="headerlink" title="2. 分解编码步骤"></a>2. 分解编码步骤</h3><blockquote><p>程序等于算法加上数据结构。</p></blockquote><p>在有了明确的问题之后，就需要思考如何去解决这个问题了。</p><p>在确认好需求之后，我就会在纸上列出已有的条件，然后思考如何完成 F。</p><p>首先， 我会定好输入输出的数据结构。</p><p>然后，我会开始画时序图或者是流程图，确认处理步骤，理清逻辑，划分模块。</p><p>最后，我把需要做的事拆分成一个个小的 task，写在便签上，产出 todo list。</p><h3 id="3-编写测试用例以及具体的程序"><a href="#3-编写测试用例以及具体的程序" class="headerlink" title="3. 编写测试用例以及具体的程序"></a>3. 编写测试用例以及具体的程序</h3><p>一个良好的程序是离不开单元测试的，单元测试保证了程序的正确性，也可以在之后的重构过程中起到至关重要的作用。</p><p>因此在划分好模块后，我会将需要的处理函数定义好。然后就是为这些函数编写各自的单元测试，通常我会编写三个测试，分别处理正常的数据，处于边界的数据，以及超出边界的程序。</p><p>在写完单元测试后就会跑一遍测试，这时不出意料所有的测试都应该是失败的，不过没关系，我的目标是让所有的测试通过。</p><p>接下来就是要去编写具体的程序，根据 task 将程序一步步的写完，每完成一个模块就跑一次测试，然后 commit。保证当前的程序是正常工作的。然后就是重复，code-test-commit 的步骤。</p><p>在完成所有的编码以及通过所有的测试之后，就将每个小 commit 合并成一个大的 commit。到目前为止基本的功能就完成了，但是这不代表我们的程序就没有问题的。这时候需要重新读一遍自己的程序，看看其中是否包含了 《重构》 中所说的坏味道的代码，如果有，那就进行重构，然后测试，提交。</p><p>在做完上面的所有工作时候，就可以提交自己的代码了。</p><p>以上就是我通常的编码过程了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go append 的小技巧</title>
    <link href="/post/go-append-tip.html"/>
    <url>/post/go-append-tip.html</url>
    
    <content type="html"><![CDATA[<p>在开发的过程中，遇到了一个需要将 T 类型切片映射为 F 类型切片的操作，由于 Go 的标准库中并没有内置 Map 函数，于是就写了一个简单的辅助函数。</p><p>第一版是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ts = []<span class="hljs-keyword">struct</span> &#123;<br>Foo <span class="hljs-type">int</span><br>&#125; &#123;<br>&#123;<br>Foo: <span class="hljs-number">1</span>,<br>&#125;,<br>&#123;<br>Foo: <span class="hljs-number">2</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;)</span></span> <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result[i] = f(v)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>先使用 make 初始化了一个长度和容量为 len(ts) 的切片，然后通过 rang ts 获取每个元素对应的索引以及值，然后将它赋予给对应索引的 result。</p><p>到目前为止，这个函数以及满足我的目标了，但是我觉得也可以通过 append 函数来实现。</p><p>在 Go 中，append 做为一个内置函数，作用是向切片的尾部追加元素，并返回新的切片。同时在追加的过程中如果发现切片的容量不够时，就会对切片的底层数组进行扩容。</p><p>于是我修改了一下代码，得到一个新的版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;)</span></span> <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result = <span class="hljs-built_in">append</span>(result, f(v))<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后，当我再跑一次测试时发现结果并不是我想要的，此时的 result 变成了 [0 0 1 2] , 而不是我想要的 [1 2]。</p><p>仔细审视了一下代码，发现问题出在初始化 result 时 make 的调用上。在使用 make 初始化 result 时，我只传入了一个 IntegerType 的参数，即 len(ts)。在这种情况下，make 会返回一个<strong>长度与容量相同</strong>的切片。</p><p>注意，问题就出在长度与容量相同，此时 make 返回给我的是一个具有长度的切片，并且其中的元素都被赋予了零值。因此当我调用 append 往 result 上追加数据时，就会因为容量不足，首先扩容一次，然后再追加新的元素。于是结果就变成了 [0 0 1 2]。</p><p>因此，我需要先初始化一个长度为 0 的切片，然后从一个空切片开始追加元素，这样就可以达到我的目标了。代码就变成如下了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-type">int</span> &#125;)</span></span> <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result = <span class="hljs-built_in">append</span>(result, f(v))<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，在使用 make 初始化一个切片时，需要考虑是否指定切片的长度，并且长度是否会对接下来的操作造成影响。除此之外， append 的操作操作位置就是切片的长度所对应的位置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go  函数式选项</title>
    <link href="/post/Golang-functional-option.html"/>
    <url>/post/Golang-functional-option.html</url>
    
    <content type="html"><![CDATA[<p>在实例化一个含有多个字段的结构体时，往往会封装一个工厂函数，类似于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用于示例，实际情况可能有更多的字端</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  A <span class="hljs-type">string</span><br>  B <span class="hljs-type">int</span><br>  C <span class="hljs-type">int</span><br>  D <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">int</span>, c <span class="hljs-type">int</span>, d <span class="hljs-type">bool</span>)</span></span> *T &#123;<br>  <span class="hljs-keyword">return</span> &amp;T&#123;<br>    A: a,<br>    B: c,<br>    D: d,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但有些时候，我们只想对特定的字端进行赋值，而其他的字端则保持默认值。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTWithA</span><span class="hljs-params">(a <span class="hljs-type">string</span>)</span></span> *T &#123;<br><span class="hljs-keyword">return</span> &amp;T&#123;A: a&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTWithAB</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">int</span>)</span></span> *T &#123;<br>  <span class="hljs-keyword">return</span> &amp;T&#123;<br>    A:a,<br>    B:b,<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Go 不支持函数重载，对于多个不同字端组合赋值初始时，往往需要多个工厂函数。这样太过于麻烦，因此需要一些辅助的手段来辅助处理。</p><p>对于这种情况，<strong>Rob Pike</strong> 提出了一种优雅的解决方式，函数式选项。区别于使用对象式选项传入一个 Option 对象的方式，函数式选项传入一个配置函数序列，其中的每个函数都会对所需要的对象进行一定的配置，最终构建出所需要的对象。</p><h2 id="使用函数式选项"><a href="#使用函数式选项" class="headerlink" title="使用函数式选项"></a>使用函数式选项</h2><p>首先定义选项 Option , 然后在使用闭包封装配置方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Option <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> <br><br><span class="hljs-comment">// Ta 将 T 的 A 设置为 a</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Ta</span><span class="hljs-params">(a <span class="hljs-type">string</span>)</span></span> Option &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.A = a<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tb</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> Option &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.B = b<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tc</span><span class="hljs-params">(c <span class="hljs-type">int</span>)</span></span> Option &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.C = c<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Td</span><span class="hljs-params">(d <span class="hljs-type">bool</span>)</span></span> Option &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.D = d<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 同时设置 A，D 在某些情况下 A，D 存在相关性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tad</span><span class="hljs-params">(a <span class="hljs-type">string</span>, d <span class="hljs-type">bool</span>)</span></span> Option &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.A = a<br>    t.D = d<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改一下NewT，使用 Option 来配置 T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(ops ...Option)</span></span> *T &#123;<br>t := &amp;T&#123;&#125;<br><span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> ops &#123;<br>opt(t)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>最后来看一下使用的效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 只设置 A</span><br>  t := NewT(Ta(<span class="hljs-string">&quot;Ta&quot;</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t)  <span class="hljs-comment">// t is &amp;&#123;3 0 0 false&#125;</span><br>  <br>  <span class="hljs-comment">// 设置 B，C，D</span><br>  t2 := NewT(Tb(<span class="hljs-number">2</span>), Tc(<span class="hljs-number">3</span>), Td(<span class="hljs-literal">true</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t2) <span class="hljs-comment">// t is &amp;&#123; 2 3 true&#125;</span><br>  <br>  t3 := NewT(Tad(<span class="hljs-string">&quot;a and d&quot;</span>, <span class="hljs-literal">true</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t3) <span class="hljs-comment">// t is &amp;&#123;a and d 0 0 true&#125;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以自由的配置需要的对象参数，并且省去了定义一堆长名字工厂函数的麻烦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goland 远程开发</title>
    <link href="/post/goland-remote-deployment.html"/>
    <url>/post/goland-remote-deployment.html</url>
    
    <content type="html"><![CDATA[<p>最近准备写一个简单的容器管理工具，需要运行在 Linux 上。然而开发的机子是 MacBook，于是就想折腾一下自己的 goland，配置一下远程开发。</p><p>目标就是在本地编写的代码，一件部署到远程的服务器上并运行。</p><h3 id="配置远程的服务器"><a href="#配置远程的服务器" class="headerlink" title="配置远程的服务器"></a>配置远程的服务器</h3><p>在进行开发之前，首先需要把远程的服务器给配置好。远程服务器的版本为 Ubuntu 20.04 ，准备使用的协议是 SFTP，所以需要在 ubuntu 20.04 上配置一个服务器。配置过程如下：</p><ul><li><p>安装 ssh </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>配置 ssh, 编辑 /etc/ssh/sshd_config，在最后加入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">AllowGroups ssh-users sftp-users<br>Match Group sftp-users<br>ChrootDirectory /home<br>AllowTcpForwarding no<br>X11Forwarding no<br>ForceCommand internal-sftp<br></code></pre></td></tr></table></figure></li><li><p>重启 sshd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service sshd restart<br></code></pre></td></tr></table></figure></li><li><p>创建 sftp 用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo addgroup sftp<br></code></pre></td></tr></table></figure></li><li><p>创建一个新的用户，加入到 sftp 组中, 设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo useradd -m sftpuser -g sftp<br>sudo passwd sftpuser<br></code></pre></td></tr></table></figure></li><li><p>最后赋予用户目录权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 700 /home/sftpuser/<br></code></pre></td></tr></table></figure></li><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sftp sftpuser@127.0.0.1<br></code></pre></td></tr></table></figure></li></ul><p>配置完成没问题后，开始设置 Goland。</p><h3 id="配置-Goland"><a href="#配置-Goland" class="headerlink" title="配置 Goland"></a>配置 Goland</h3><p>Google 一下 Goland remote, 第一个结果就是 Jetbrains 家的文档。稳👍。<a href="https://www.jetbrains.com/help/go/creating-a-remote-server-configuration.html">地址在这🔗</a>。既然有官方文档，那就根据官方文档一步步的来。</p><ul><li><p>第一步，打开设置菜单：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">windows &amp;&amp; linux<br>File &gt; Settings &gt; <span class="hljs-keyword">Build, </span>Execution, Deployment &gt; Deployment <br><br>macOS<br>GoLand &gt; <span class="hljs-keyword">Preferences </span>&gt; <span class="hljs-keyword">Build, </span>Execution, Deployment &gt; Deployment<br></code></pre></td></tr></table></figure></li><li><p>接下来，点击 ‘Add’, 添加一个新的远程服务器，选择一个协议，因为远程服务器部署的是 SFTP，所以选择SFTP 然后输入名字，完成添加。</p></li><li><p> 新建一个 SSH configuration，输入地址、端口、用户名、密码，点击 Test connect. 确认没问题后，点击 OK</p></li><li><p>选择刚配置好的 ssh 并设置后目录以及 Web Server URL。</p></li><li><p>切换到 mapping， 将工作目录与远端的目录映射。</p></li></ul><p>至此就完成了远端部署的配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 连接远程主机</title>
    <link href="/post/docker-remote-host.html"/>
    <url>/post/docker-remote-host.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在某些情况下，需要工作的电脑上 docker CLI 连接到另一台主机上的 docker 服务器。记下具体的配置过程。</p><h2 id="配置远程主机"><a href="#配置远程主机" class="headerlink" title="配置远程主机"></a>配置远程主机</h2><p>首先需要在远程主机上开启监听本地的端口， 修改 docker 的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>修改，或增减 hosts 字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;hosts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;unix:///var/run/docker.scok&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;0.0.0.0:2376&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>修改完成后，重启 docker 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>如果启动失败，可能是因为默认启动参数指定了 hosts，与新建的配置冲突了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /usr/lib/systemd/system/docker.servic<br></code></pre></td></tr></table></figure><p>将</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ExecStart</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>后的 -H 参数去掉，再次重启。</p><p>确认 docker 在监听 2376 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ntlp | grep 2376<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcp6</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">2376</span>                 :::*                    LISTEN      -<br></code></pre></td></tr></table></figure><h2 id="本地启动连接"><a href="#本地启动连接" class="headerlink" title="本地启动连接"></a>本地启动连接</h2><p>本地启动只需设置 <strong>DOCKER_HOST</strong> 变量即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DOCKET_HOST=tcp://host:2376<br>docekr ps<br></code></pre></td></tr></table></figure><p>即可看到远程主机上的 docker 容器了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/post/DNS.html"/>
    <url>/post/DNS.html</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System(DNS)</a> 是一个用于计算机，服务以及其他资源连接到 Iternet 的分布式分层系统。DNS 是一个数据库，它保存了域名以及 IP 地址的映射。可以将域名转化成对应的 IP。</p><p>用户与互联网上的某台机器进行交互时，需要知道对方机器的 IP 地址，不论是 32 位还是点十分制的 IP 地址都不容易记忆，因此需要有一个容易记住的主机名称（域名），并且有一个对映的翻译系统（DNS），将主机名称翻译成对映的 IP 地址。</p><p>DNS 是一个联机分布式数据库，采用 C/S 架构。大多数的 DNS 解析都在本地进行，只有当本地没有相关记录时才会通过互联网进行通信，解析。</p><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p>一次域名解析的过程可以概括为以下几个步骤：</p><ol><li>程序 A 需要解析 example.com, A 调用解析程序 Resolver</li><li>解析程序将域名放入 DNS 请求报文中，以 UDP 数据报方式发给本地域名服务器</li><li>本地域名服务器中有相关记录，将 IP 放在回答报文中返回，如果没有，进行 4</li><li>本地域名服务器向其他域名服务器发起请求，获取到 IP 地址，然后返回</li></ol><p>域名的解析方法有两种，</p><p>一是递归查询（recursive query），这种查询发生在本地域名服务器没有相关的域名记录时，他会成为域名查询的一个客户，向其他根域名服务器发起请求，而不是让主机进行下一次请求。所以，递归查询的结果要么是查询到对应的 IP，要么返回一个错误值，即指定的域名不存在。</p><p>二是迭代查询（iterative query），对根域名来说，当根域名服务器收到查询请求时，要么给出对应的 IP，要么返回本地域名服务器进行下一步查询的服务器的地址，之后本地域名服务器再进行后续的查询，通常返回的是一个顶级域名服务器。对于顶级域名服务器来说，要么返回 IP，要么返回进行下一步查询的权限域名服务器。</p><p>通过 dig 工具可以查看到具体的解析过程。</p><h2 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h2><p>域名的数据结构是一棵树，根节点没有名字，根域名的子节点为顶级域名，如 com，org，net等。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">   root<br> /   |   \<br><span class="hljs-function"><span class="hljs-title">com</span></span>  org net ... <br></code></pre></td></tr></table></figure><p>域名由 label 序列组成，每个 label 之间使用“ <strong>.</strong> ”隔开，如 <a href="http://www.example.com,级别最低的域名写在最左边,级别最高的域名写在最右边./">www.example.com，级别最低的域名写在最左边，级别最高的域名写在最右边。</a></p><p>域名由字母数字以及连字符组成，不区分大小写，EXAMPLE 与 example 是等效的。</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ol><li><p>根域名服务器</p><p>最高层次的域名服务器，记录了所有顶级域名服务器的域名和IP地址，当本地域名服务器无法解析时，首先向根域名服务器发起查询请求。</p><p>根域名服务器只使用 13 个不同 IP 地址的域名，分别是 a.rootservers.net，b.rootservers.net … m.rootservers.net。</p></li><li><p>顶级域名服务器</p><p>负责管理在该顶级域名服务器注册的所有二级域名</p></li><li><p>权限域名服务器</p><p>负责一个区的域名服务器。</p></li><li><p>本地域名服务器</p><p>又称默认域名服务器，离用户近，一般不超过几个路由的距离。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cgo 内存释放</title>
    <link href="/post/cgo-memory-free.html"/>
    <url>/post/cgo-memory-free.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用 cgo，Go 可以与 C 语言代码进行交互，但是在使用过程中，如果使用的姿势不对，那么就有可能带来内存泄漏问题。</p><p>Go 自带 GC，一般情况下不会发生内存泄漏事件，自带的 GC 会收集不再使用的对象，并将其释放。但是在使用 cgo 时，某些函数会将 C 语言对象分配到 C 的堆上，在 Go 中初始化的 C 对象，是需要显示的调用 C.free() 去释放。官方文档也写明了这一点。在 cgo 的使用文档中，有关于 CString 函数的一段描述：</p><blockquote><p>The C string is allocated in the C heap using malloc.  It is the caller’s responsibility to arrange for it to be freed, such as by calling C.free (be sure to include stdlib.h  if C.free is needed).</p></blockquote><p>在将 Go 类型转化为 C 类型的函数中都有着相关的说明。</p><p>因此，<strong>分配在 C 堆上的内存需要调用 C.free() 去释放</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以下的代码来自 cgo 官方博客，演示了如何使用 cgo 调用 c 语言代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// static void myprint(char* s) &#123;</span><br><span class="hljs-comment">//   printf(&quot;%s\n&quot;, s);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cs := C.CString(<span class="hljs-string">&quot;Hello from stdio&quot;</span>)<br>C.myprint(cs)<br>C.free(unsafe.Pointer(cs))<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码的最后一行，通过调用 C.free() 手动释放了内存。</p><p>为了保证内存的正确释放，可以通过 defer 语句来释放内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// static void myprint(char* s) &#123;</span><br><span class="hljs-comment">//   printf(&quot;myprint: %s\n&quot;, s);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  cs := C.CString(<span class="hljs-string">&quot;Hello from stdio&quot;</span>)<br>  <span class="hljs-keyword">defer</span> C.free(unsafe.Pointer(cs))<br>C.myprint(cs)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python map, filter, reduce  函数的注意事项</title>
    <link href="/post/undefined.html"/>
    <url>/post/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>注意：本文所说的 python 都是指 python3，python2 已不再被支持 :)</p></blockquote><p>map(), filter() 以及 reduce() 是 Python 中与函数式编程相关的三个函数，可以对可迭代序列做映射，过滤以及累积。熟练使用这三个函数可以提升编码速度，并且感受到函数式编程的一些思想。但是在使用过程中需要注意一些事项</p><p>TL;DR</p><ol><li>from functools import reduce.</li><li>返回对象，map, filter 返回可迭代对象，对象操作是惰性的</li></ol><span id="more"></span><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>map 与 filter 做为内置函数，可以直接使用，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">1</span>, a))<br>c = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x : x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, a))<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># [2, 3, 4]</span><br><span class="hljs-comment"># [2]</span><br></code></pre></td></tr></table></figure><p>而 reduce() 函数的使用则需要从 <strong>functools</strong> 包中导入, 如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>reduce(<span class="hljs-keyword">lambda</span> x, y : x+y, a)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><p>同时，reduce() 中传入的函数的参数数量为两个。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>reduce 返回累积后的值，而 map 与 filter 返回的是可迭代的对象，分别为 map object 和 filter object。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span>, a)<br><span class="hljs-built_in">print</span>(b)<br><br>c = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>, a)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># &lt;map object at 0xXXXXX&gt;</span><br><span class="hljs-comment"># &lt;filter object at 0xXXXXXXX&gt;</span><br></code></pre></td></tr></table></figure><p>map, filter 传入的函数，只有在返回的可迭代对象被消费时才会实际调用，即<strong>惰性求值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;evaluation&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span><br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(test, a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not evaluation&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(b)) <span class="hljs-comment"># evaluation here because of list()</span><br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># not evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># [2, 3, 4]</span><br><br><br></code></pre></td></tr></table></figure><p>由于返回的是一个可迭代对象，因此所有的值只能迭代一次，再次尝试迭代，将会返回一个空集，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a)<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;First iteration&quot;</span>) <br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Second iteration&quot;</span>)<br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># First iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># Second iteration</span><br></code></pre></td></tr></table></figure><p>因此，在如果需要多次使用返回的迭代对象，可以通过调用 list() 方法将其转化为一个 list 对象，之后使用生成的 list 对象即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;First iteration&quot;</span>) <br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Second iteration&quot;</span>)<br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># First iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># Second iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell Tips 💡</title>
    <link href="/post/shell-tips.html"/>
    <url>/post/shell-tips.html</url>
    
    <content type="html"><![CDATA[<p>一些关于 shell 的笔记</p><h2 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h2><p>在执行脚本时，确定当前的权限是否为 root</p><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$EUID</span>&quot;</span> -ne 0 ]<br>  <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not root&quot;</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>EUID, 用于系统决定用户对系统资源的访问权限，等于 0 时表示权限为 root。</p><h2 id="路径判断"><a href="#路径判断" class="headerlink" title="路径判断"></a>路径判断</h2><p>判断一个文件夹是否存在</p><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$DIRECTORY</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># Control will enter here if $DIRECTORY exists.</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h2><p>字符串转为大写或小写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=ABCDF123<br>a= $(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> | awk <span class="hljs-string">&#x27;&#123;print tolower($0)&#125;&#x27;</span>) <span class="hljs-comment"># abcdf123</span><br>a= $(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> | awk <span class="hljs-string">&#x27;&#123;print toupper($0)&#125;&#x27;</span>) <span class="hljs-comment"># ABCDF123</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析</title>
    <link href="/post/lexical-analysis.html"/>
    <url>/post/lexical-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在之前的文章中，了解了什么是语言处理器，具体见<a href="https://blog.zhangliangliang.cc/post/compiler-intro.html">这里</a>。接下来就是详细了解一下编译器的结构。</p><p>整体来看，一个编译器分为前端以及后端两个部分。</p><p>前端也就是分析部分，在这个阶段，编译器会将源程序分解成多个组成要素，然后在这些要素上加上语法结构，之后就会利用这个语法结构去创建程序的中间表示。</p><p>分析会对程序的语法，语义进行分析，如果存在不一致的情况，编译器就会返回相应的信息。与此同时，分析部分会搜集程序的一些信息，并且保存在<em>符号表</em>中。</p><p>在符号表中，源程序的标志符和它的声明或者使用信息绑定在一起，比如数据类型，作用域以及内存地址。</p><p>后端，也被称之为综合部分，后端接受到前端生成的中间形式以及符号表后，会根据这两者来构造目标程序。</p><p>首先来看，编译器的第一个步骤，词法分析。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析是编译器处理过程中的第一步。词法分析器会读取并扫描源程序的字符流，然后将他们组织成有意义的词序的序列。对于每个词素，词法分析器会产生一个 token<em>（词法单元）</em>，形式如下：</p><p>​    &lt;token-name, attribute-value&gt;</p><p>token-name: 语法分析阶段所需要的抽象符号</p><p>attribute-name：指向符号表中保存这个 token 的记录的索引</p><p>假设有这样的一条语句</p><p>​    sum = a + f  * 6.0</p><p>词法分析器会从左到右进行扫描，并得到下列 token</p><p>​    &lt;id, 1&gt; &lt;=&gt; &lt;id, 2&gt; &lt;+&gt; &lt;id,3&gt; &lt;float, 3&gt;</p><ul><li>“sum” 会被映射为 &lt;id, 1&gt;，id 是 identifier <em>（标志符）</em> 的抽象表示， 1 表示 sum 在 符号表的中的条目。</li><li>“=” ：&lt;=&gt;, 等号不需要属性，因此省略第二个分量</li><li>其他的 token 映射规则和👆两个一样</li></ul><p>经过处理获得的 token 流会传给下一个步骤进行处理，即语法分析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 的一种并发模式：管道</title>
    <link href="/post/go-concurrency-pipeline.html"/>
    <url>/post/go-concurrency-pipeline.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go-管道模式"><a href="#Go-管道模式" class="headerlink" title="Go 管道模式"></a>Go 管道模式</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>这片文章是看完 Golang 官方博客后写下，记录下。原文在<a href="https://blog.golang.org/pipelines">这里</a></p><p>首先是 What is pipeline？官方博客上将管道看作是并发的程序的一种。一系列的 <em>stage</em> 通过 channel 串联起来。其中，每个 stage 都是一组执行相同任务的 goroutine。在每个 Stage 中，每个 goroutine 都会做三件事情：</p><ul><li>通过一个 channel 接收到要处理的上游数据。</li><li>对接收的数据做处理，通常是产生一个新的值</li><li>将产生的新数据传入另一个 channel 中，传递到下游。</li></ul><p>除了第一个和最后一个 Stage 以外，中间的 Stage 都会有几个传入和传出的数据通道，第一个只有传出，而最后一个只有传入。数据由第一个 stage 流入到最后一个 stage。</p><p>也就是说，在 Go 中的管道（pipeline）就像是一条生产线，一个零件从被生产到被消费，会经过几个不同的车间处理。第一个车间会生产最初的数据，而最后一个车间去消费这个数据。</p><span id="more"></span><p>为了更好的帮助理解，官方博客给出了例子。首先是最简单的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// gen 根据传入的数字列表产生 channel， 并且将数字传入其中。</span><br><span class="hljs-comment">// 在完成传输后，gen 会关闭相应的 channel.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">(nums ...<span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>            out &lt;- n<br>        &#125;<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// sq 从 上游的 channel 中接收数据，做平方后传入新的 channel 中。</span><br><span class="hljs-comment">// 与 gen 相同，sq 也会在完成任务后，将他产生的 channel 关闭。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sq</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> in &#123;<br>            out &lt;- n * n<br>        &#125;<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// main 函数负责设置 channel，并且消费 channel 中产生的数据。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> sq(sq(gen(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))) &#123;<br>        fmt.Println(n) <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 16</span><br><span class="hljs-comment">// 81</span><br></code></pre></td></tr></table></figure><h3 id="Fan-out-和-Fan-in"><a href="#Fan-out-和-Fan-in" class="headerlink" title="Fan-out 和 Fan-in"></a>Fan-out 和 Fan-in</h3><p>fan-out: 多个程序从一个 channel 中读取数据，直到 channel 关闭。就像是一个管理人，分发工作给多个工人的情况。</p><p>fan-in: 与 fan-out 相反，一个程序从多个 channel 中读取数据，直到所有的 channel 都关闭了。于此同时，会将处理后的数据送入一个新的 channel 中，并在完成工作后关闭它。 </p><p>例如，现在有一个 merge 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>, cs ... &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// Start an output goroutine for each input channel in cs.  output</span><br>    <span class="hljs-comment">// copies values from c to out until c is closed or it receives a value</span><br>    <span class="hljs-comment">// from done, then output calls wg.Done.</span><br>    output := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> out &lt;- n:<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>            &#125;<br>        &#125;<br>        wg.Done()<br>    &#125;<br><br>wg.Add(<span class="hljs-built_in">len</span>(cs))<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cs &#123;<br>        <span class="hljs-keyword">go</span> output(c)<br>    &#125;<br><br>    <span class="hljs-comment">// Start a goroutine to close out once all the output goroutines are</span><br>    <span class="hljs-comment">// done.  This must start after the wg.Add call.</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        wg.Wait()<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p>原有的 gen 方法会被改造成下面的样子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sq</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> in &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> out &lt;- n * n:<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p>main 函数则变成:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Set up a done channel that&#x27;s shared by the whole pipeline,</span><br>    <span class="hljs-comment">// and close that channel when this pipeline exits, as a signal</span><br>    <span class="hljs-comment">// for all the goroutines we started to exit.</span><br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><br>    in := gen(done, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment">// Distribute the sq work across two goroutines that both read from in.</span><br>    c1 := sq(done, in)<br>    c2 := sq(done, in)<br><br>    <span class="hljs-comment">// Consume the first value from output.</span><br>    out := merge(done, c1, c2)<br>    fmt.Println(&lt;-out) <span class="hljs-comment">// 4 or 9</span><br><br>    <span class="hljs-comment">// done will be closed by the deferred call.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置一个名为 done 的 channel, 下游的程序可以给上游的程序发送信号，通知他们停止生产数据，作为了一个反馈途径。</p><p>因此，如果想要构建一个 pipeline 系统, 有以下的要点：</p><pre><code class="hljs">- 当所有的操作完成后，stage 关闭通向外界的 channel。- stage 不断从流入 channel 中接收数据，直到这些 channel 关闭了或者是发送者解除阻塞状态。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习</title>
    <link href="/post/compiler-intro.html"/>
    <url>/post/compiler-intro.html</url>
    
    <content type="html"><![CDATA[<h2 id="语言处理器"><a href="#语言处理器" class="headerlink" title="语言处理器"></a>语言处理器</h2><p>语言处理器就像是一个加工车间，某种程序设计语言编写的程序经过它的加工处理后，变成计算机可以执行的形式。语言处理器通常分为两种常见的形式，一是编译器，二是解释器。</p><p>编译器（Compiler）就像是一个翻译员，他将自己阅读到的程序，翻译成一个等价的，用另一种语言编写的程序。在这个过程中，他所阅读到的程序称之为 <em>源语言</em>，翻译成的语言称为 <em>目标语言</em>。整个过程如下：</p><blockquote><p>源程序 -&gt; [编译器] -&gt; 目标程序</p></blockquote><p>如果目标程序是一个可以执行的程序，那么它就可以被调用，来处理输入，产生输出。</p><blockquote><p> 输入 -&gt; [目标程序] -&gt; 输出</p></blockquote><p>除了翻译的职责外，编译器还承担着发现源程序中的错误的责任。</p><p>其次就是解释器（Interpreter），跟编译器的翻译相比，解释器就像是一个同声传译员，他在接受到源程序之后，就会立即翻译成目标语言，同时开始执行。</p><blockquote><p>输入 &amp; 源程序 -&gt; [解释器] -&gt; 输出</p></blockquote><p>编译器与解释器相比，由编译器产生的程序执行起来速度要比解释器快，以为在运行时不需要在依赖编译器或者额外的程序。但于此同时，由于解释器是逐行处理的，因此在错误诊断上的效果更加好。</p><h2 id="完整的处理过程"><a href="#完整的处理过程" class="headerlink" title="完整的处理过程"></a>完整的处理过程</h2><p>创建一个可执行的目标程序，不仅需要编译这一道处理，往往还需要其他的一些程序。</p><p>一个程序，根据设计，往往会被分成好几个模块，源代码散落在多个文件中，这时就需要一个程序来收集源代码文件，将他们聚合在一起。预处理器就是承担这个责任的。预处理器就像是一个装订工人，将各地的纸张收集起来，装订成册，有时候还需要根据指导手册修改纸上的内容（根据宏生成源程序的代码）。</p><p>在完成装订之后，这些“册子”就会作为输入，交给编译器去做翻译。在完成翻译后，通常会产生一本“汇编语言”的书籍。</p><p>然后，“书”会被交给汇编器（assembler）去做处理，在这之后的成品，就是可以重新定位的机器代码。</p><p>由于一个大程序经常会被分成多个部分编译，因此，可重新定位的机器代码有必要和其他的机器代码连接到一起。一个文件中，可能有着另一个文件中的地址。在这时，链接器（linker）就会站出来，根据各个文件的索引要求，把他们相互链接到一起。</p><p>最后，加载器（loader）就像运输工一样，负责把所有的执行目标文件送到到内存中，然后执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 使用过程中遇到的问题📝</title>
    <link href="/post/some-problems.html"/>
    <url>/post/some-problems.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在日常的开发过程中，主要使用的语言就是 Go。记录下使用过程中遇到的一些问题以及踩到的的坑。</p><h2 id="Json-序列化，Tag"><a href="#Json-序列化，Tag" class="headerlink" title="Json 序列化，Tag"></a>Json 序列化，Tag</h2><p>在 Go 中如果需要进行 Json 的序列化，常用到的方法有 <em>json.Marshal</em>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>对需要序列化的结构体进行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Body <span class="hljs-type">string</span><br>    Time <span class="hljs-type">int64</span><br>&#125;<br><br>m := Message&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1294706395881547000</span>&#125;<br>b, err := json.Marshal(m) <span class="hljs-comment">// 一切正常，err == nil。</span><br>b == []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;Name&quot;:&quot;Alice&quot;,&quot;Body&quot;:&quot;Hello&quot;,&quot;Time&quot;:1294706395881547000&#125;`</span>) <br></code></pre></td></tr></table></figure><p>如果需要对生成 json 的字段进行指定，那么需要使用 tag，同时需要注意tag使用时的规范。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span> <span class="hljs-comment">// 正确使用 tag</span><br>Body <span class="hljs-type">string</span> <span class="hljs-string">`json:body`</span>   <span class="hljs-comment">// 没有加双引号</span><br>Time <span class="hljs-type">int64</span>                <span class="hljs-comment">// 不使用 tag</span><br>&#125;<br><br>m := Message&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1294706395881547000</span>&#125;<br>b, err := json.Marshal(m) <span class="hljs-comment">// 一切正常，err == nil。</span><br><br><span class="hljs-comment">// 只有 name 字段的字段名发生了改变</span><br>b == []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;Body&quot;:&quot;Hello&quot;,&quot;Time&quot;:1294706395881547000&#125;`</span>) <br></code></pre></td></tr></table></figure><p>因此在使用过程中发现生成的字段名称不符合预期时，可以检查对应的 tag。</p><h2 id="Json-反序列化"><a href="#Json-反序列化" class="headerlink" title="Json 反序列化"></a>Json 反序列化</h2><p>与序列化时相同，在对需要反序列化的 byte slice 调用 <em>json.Unmarshal</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>使用时需要先声明一个变量用于存放反序列化后生成的对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m Message<br></code></pre></td></tr></table></figure><p>然后需要调用 json.Unmarshal，传入json 数据的 byte slice, 以及<strong>指向 m 的指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err := json.Unmarshal(b, &amp;m)<br></code></pre></td></tr></table></figure><p>⚠️特别注意的是：如果在调用时没有传入指针，而是直接传入了 m， 那么将序列化失败，m 中将不包含任何信息。</p><p>在对某个 json 反序列化之后发现没有获取到任何的数据，debug 时可以注意，是否在编码时出现typo，没有使用指针，而是直接传入了 m。</p><p>同时在反序列化的过程中，会按照以下的以下的顺序查找对应的字段：</p><ul><li>是否是标签中声明的字段名</li><li>是否是结构体定义的字段名</li><li>是否是结构体定义的字段名的大小写变化后的名字，如”Foo”对应的”FOO”, “FoO”.</li></ul><p>如果都没有符合条件的选项，那么 Unmarshal 方法将会忽略这个字段，不对他进行处理。</p><h3 id="使用GOPROXY"><a href="#使用GOPROXY" class="headerlink" title="使用GOPROXY"></a>使用GOPROXY</h3><p>在国内使用 go get 命令获取依赖包时，由于🧱🧱的原因，导致无法安装某些依赖。比如 golang.org/x/net  包。为了解决这个问题，可以通过下载 github 上的源码，并将其放在 $GOPATH/src/golang.org/x 目录下，手动编译来解决。</p><p>除了手动下载编译外，还可以通过使用代理来进行下载。推荐使用 <a href="https://github.com/goproxy/goproxy.cn">goproxy</a>， goproxy 是七牛云搭建的代理服务，可以快速下载所需要的第三方依赖。</p><p>使用方法：</p><ul><li><p>Go 1.3 及以上版本（推荐）</p><p>执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p>其他版本可以通过设置环境变量 GOPROXY 来实现：</p></li><li><p> linux 以及 macOS </p></li></ul><p>  在 terminal 下执行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> GOPROXY=https://goproxy.cn<br></code></pre></td></tr></table></figure><p>  或者是</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export GOPROXY=https://goproxy.cn&quot;</span> &gt;&gt; ~/.profile &amp;&amp; <span class="hljs-built_in">source</span> ~/.profile<br></code></pre></td></tr></table></figure><ul><li><p>Windows </p><p>打开 powershell， 执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\&gt; <span class="hljs-variable">$env:GOPROXY</span> = <span class="hljs-string">&quot;https://goproxy.cn&quot;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社会工程概要</title>
    <link href="/post/what-is-social-engineering.html"/>
    <url>/post/what-is-social-engineering.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>社会工程学不是一个神秘的工具，是一门科学，通过一些技巧来操纵他人采取特定行动。虽然这些行动不一定符合”目标人物”的最佳利益。使用社会工程的结果包括获取信息，取得访问权限或者让目标采取特定的行动。</p><p>在日常的生活中有两种最为常见的社会工程实例。一是骗子，骗子往往会采用社会工程的某些因素说服受害人，让其做出会给自身带来损失的行动。二是心理医生，心理医生会使用一系列精心设计的问题，帮助病人走出困境。</p><p>骗子和心理医生是社会工程的最真实形式，因为出发点的不同，使得他们在不同的目标身上产生了完全不同的结果。</p><p>社会工程就像烹饪，一种美食不会仅有一种成分，而是精心组合，调配以及添加多种配料而成。而社会工程人员使用社会工程框架中提到的各种技巧，组合搭配，使用少量的诱因，稍加操纵即可实现目的。</p><p>社会工程可以用于生活中的多个方面，存在着不同的形式，既可以是恶意的，也可以是善意的，既可以产生激励作用，也可以具有毁灭性。</p><h2 id="使用社会工程的人员"><a href="#使用社会工程的人员" class="headerlink" title="使用社会工程的人员"></a>使用社会工程的人员</h2><ul><li>黑客：由于软件攻击和网络入侵的难度提升，通过使用社会工程来进行攻击</li><li>渗透测试者：与黑客不同，使用社会工程手段来确保客户的安全</li><li>间谍：社会工程专家，使用社会工程来获取信任，窃取情报</li><li>身份盗用者：在当事人不知情的情况下，盗用身份信息</li><li>骗子：利用贪婪，恐惧心理，使用社会工程的技巧进行诈骗</li><li>高端猎头：既考虑求职者的需求也审视雇主的想法</li><li>销售人员：利用技巧发现人们的需求</li><li>政府：利用社会认同，权威性和稀缺资源来确保目标的受控性</li><li>医生，心理医生和律师：使用谈话技巧，社会工程的心理原则，操纵客户采取期望的行动</li></ul><p>学习社会工程不仅能增强自身技能，而且可以提高警觉，避免被操控。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 结构体</title>
    <link href="/post/go-struct.html"/>
    <url>/post/go-struct.html</url>
    
    <content type="html"><![CDATA[<h2 id="结构体介绍"><a href="#结构体介绍" class="headerlink" title="结构体介绍"></a>结构体介绍</h2><p><strong>结构体</strong>是一种数据结构，通过实现复杂的结构来表示现实世界中的实体。<strong>结构体</strong>同时也是一些元素的集合，这些元素称为<strong>结构体</strong>的成员（又称字段），且这些成员可以为不同的类型，成员一般用名字访问。</p><p>结构体的声明一般是以 <strong>type</strong> 开始，并依次包含类型名称、关键字 <strong>struct</strong> 以及由花括号包裹的成员列表。</p><p>声明语句如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Student 是一个表示学生的结构体</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>  Id   <span class="hljs-type">int</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，每个字段的声明都需要<strong>独占一行</strong>，且名字要<strong>唯一</strong>。如果字段在代码中从来也不会被用到，那么可以命名它为”_”。</p><span id="more"></span><h2 id="带有标签的结构体"><a href="#带有标签的结构体" class="headerlink" title="带有标签的结构体"></a>带有标签的结构体</h2><p>除了成员除了名称以及类型之外，还可以选择一个标签。标签是一个附属于字段的字符串，只有 <strong>reflect</strong> 可以操作它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>  Id   <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;Id&quot;`</span><br>  Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;Name&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <strong>reflect</strong> 来获取其中的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;Id&quot;`</span> <span class="hljs-comment">// 表明 Json 序列化时的名称。</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;Name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>std := Student&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>&#125;<br><br>t := reflect.TypeOf(std)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>ixField := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, ixField.Tag)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// json:&quot;Id&quot;</span><br>  <span class="hljs-comment">// json:&quot;Name</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h2><ol><li>使用 new 方法实例化一个结构体, 将会对该变量赋于一块内存，并返回指向内存的指针。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>(Student)<br>fmt.Println(s)<br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// &amp;&#123;0 &#125;</span><br></code></pre></td></tr></table></figure><p>使用 new(Type) 等价于 **&amp;Type{}**，因为后者在底层调用了 new 方法。</p><p>除此之外，使用 var t T 也会给 t 分配内存，并零值化内存，但此时 t 的类型是 <strong>T</strong>，而不是指向它的一个指针。</p><ol start="2"><li>使用工厂方法。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStudent</span><span class="hljs-params">(id <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>)</span></span> *Student &#123;<br><span class="hljs-keyword">return</span> &amp;Student&#123;<br>Id:   id,<br>Name: name,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := NewStudent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Apple&quot;</span>)<br>size := unsafe.Sizeof(s) <span class="hljs-comment">// 了解 s 所占用的内存</span><br>fmt.Println(s)<br>fmt.Println(size)<br>&#125;<br><br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// &amp;&#123;1 Apple&#125;</span><br><span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>如果想要强制使用工厂方法，可以将<strong>类型设置为私有的</strong>，那么在其他包调用时只能使用工厂方法，而不能通过 new 方法来实例化。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>与数组类型相同，结构体类型是<strong>值类型</strong>。结构体类型的零值并不是 nil。如之前的 Student 的零值就是 Student{0  }。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>郝林. Go 并发编程实践（第二版）. 人民邮电出版社<sub>（中文）</sub>.</li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.1.md">the-way-to-go_ZH_CN</a>. “结构体的定义”.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 接口类型</title>
    <link href="/post/go-interface.html"/>
    <url>/post/go-interface.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>Go 语言中的接口用于定义一组行为。其中，每个行为都是一个由一个方法进行声明的。</p><p>在声明一个接口时，只需要声明方法的名称，方法的参数列表以及结果列表即可。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>  Listen(<span class="hljs-type">string</span>)<br>  Say() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Person 接口就是定义了一组与 “Person” 相关的行为。</p><p>接口类型是无法实例化的，这意味着无法使用 new 或 make 函数来创建接口类型的值。同样的，也不可以使用一个字面量来表示某个接口的值。</p><span id="more"></span><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>如果一个数据类型 <strong>T</strong> 的方法集合中包含了接口 <strong>I</strong> 声明的所有方法，那么它就是 <strong>I</strong> 的实现类型。即  “Duck Typing”。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Listen(word <span class="hljs-type">string</span>) &#123;<br>  <span class="hljs-comment">// .....</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Say() <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;T&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>T 的所有指针方法都包含了 Person 所声明的方法，因此 *T 类型就是 Person 的实现类型。⚠️注意的是，T 类型并不是， *T 类型才是。</p><p>在 Go 中，数据类型之间并<strong>不存在继承关系</strong>，只有组合关系。这意味着，可以在一个接口类型的声明中嵌入任意数量的其他接口类型。让一组行为包含其他的行为组。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TPerson <span class="hljs-keyword">interface</span> &#123;<br>  Person<br>  Eat(<span class="hljs-type">string</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态类型与静态类型"><a href="#动态类型与静态类型" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>有如下两个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">var</span> p Person = &amp;t<br></code></pre></td></tr></table></figure><p>被赋予接口类型变量的值称为<strong>动态值</strong>， &amp;t 就是 p 的动态值；</p><p>动态值的类型就是<strong>动态类型</strong>，p 的动态类型是 *T；</p><p>接口变量本身的类型就是 <strong>静态类型</strong>，p 的静态类型就是 Person，并且一直都是。</p><p>此外，如果有另外一个类型 *T2 也实现了 Person 接口，并且 *T2 类型的值被赋予了 p， 那么 p 的动态类型就变为了 *T2.</p><p>在接口类型的变量被赋值之前，它的动态类型并不存在。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 优化表空间</title>
    <link href="/post/mysql-optimize-table.html"/>
    <url>/post/mysql-optimize-table.html</url>
    
    <content type="html"><![CDATA[<p>在使用 MySQL 的过程中，可能会出现如下的情况：</p><p>使用 delete 语句删除大部分数据之后，表文件的大小却并没有发生变化。导致这种情况出现的原因有多种。</p><h2 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h2><p>首先是 <strong>innodb_file_per_table</strong> 这个参数的设置。这个参数的作用是控制表文件的存放位置。</p><ul><li><strong>OFF</strong>：表数据放在系统表共享空间之中，即数据字典的存放处</li><li><strong>ON</strong>：每张表的数据单独存放在 <strong>.ibd</strong> 的文件中</li></ul><p>在设置为开启之后，使用 drop table 命令就会删除掉表的数据文件，从而回收空间。</p><span id="more"></span><h2 id="MySQL-数据中的空洞"><a href="#MySQL-数据中的空洞" class="headerlink" title="MySQL 数据中的空洞"></a>MySQL 数据中的空洞</h2><p>其次是表记录删除过程所导致的”<strong>空洞</strong>“。在对表的记录进行删除时，delete 命令会将记录的位置或者数据页的状态标记为<strong>可复用</strong>，而磁盘文件的大小并不会产生变动。</p><p>标记为可复用的位置如果没有新的数据填入，那么空洞就会一直存在，这将导致即使是数据被删除了，但是整体文件的大小却没有变化。</p><p>除此之外，由于插入数据的随机，导致数据页分裂也会导致空洞的产生。</p><p>为了消除文件中的空洞，优化整体的空间，需要使用到重建命令对表重建。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALERT TABLE t_name ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><h2 id="表的重建过程"><a href="#表的重建过程" class="headerlink" title="表的重建过程"></a>表的重建过程</h2><p>MySQL 对表的重建是 online 的， 过程如下：</p><ol><li>首先建立一个临时文件， tmp；</li><li>将表 T 中的所有数据存储到 tmp 中；</li><li>记录替换过程中表 T 的所有操作，写入 raw  log 中；</li><li>根据 raw log 中的记录，操作 tmp；</li><li>使用 tmp 替换 T；</li></ol><p>在重建表之后才能收缩表空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语法概览 Part 2</title>
    <link href="/post/Go-grammar-overview-2.html"/>
    <url>/post/Go-grammar-overview-2.html</url>
    
    <content type="html"><![CDATA[<p>这是 Go 学习笔记的第二篇，继续对 Go 的语法进行一个概览，你可以在<a href="https://blog.zhangliangliang.cc/post/Go-grammar-overview-1.html">这里</a>看到第一篇。</p><p>本篇将聚焦于 Go 语言的数组，切片，字典以及函数。</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><p>Array（数组）是一个由数个相同类型的元素构成的序列。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stds [<span class="hljs-number">4</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">4</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>数组的长度是数组类型的一部分。拥有相同元素类型的数组，如果长度不同，那么就不是相同的数组。数组的长度一经声明，就不可以再改变了。</p><p>声明语句的右半部分也可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125; <span class="hljs-comment">// Go 编译器将计算元素的数量，并获得长度</span><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2 切片"></a>2 切片</h2><p>slice（切片）对数组的一种包装形式，被它包装的数组被叫做切片的底层数组。它表述了底层数组中的一个连续片段。</p><p>声明形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stds = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>切片的类型不包含长度信息，因此拥有相同元素类型的切片，他们的类型就是相同的。</p><p>切片的<strong>长度可变</strong>，零值为 nil，当处于零值时，长度和容量都是0。其中，切片的容量是指在没有更换底层数组时长度的最大值。</p><p>切片的初始化可以通过内建函数  <strong>make</strong> 进行，通过使用 make 能以很短的代码初始化一个长度很大的切片。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">stds := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3 字典"></a>3 字典</h2><p>map（字典）是 hash table 的一个实现。map 是 key-value 形式元素对的一个无序集合。map 中的每个索引都是独一无二的。</p><p>map 的声明如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mStds = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>map 的零值为 nil，零值的长度是 0。map 的长度表明了其中所含有的 key-value 对的数量。</p><p>map 数据的<strong>添加与修改</strong> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mStds[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p><strong>删除</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(mStds, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// 无论是否存在 “a“, 都将会执行完毕。</span><br></code></pre></td></tr></table></figure><p><strong>查询</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, has := mStds[<span class="hljs-string">&quot;a&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><p>函数在 Go 中是作为一等公民形式存在的，可以将函数作为一个值来传递和使用。</p><p>一个函数的声明通常包括关键字 func， 函数名，由圆括号包围的参数列表和结果列表，以及花括号包围的函数体。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">A</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span>(res <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了辨别不同的函数，需要使用<strong>函数签名</strong>，函数签名是函数参数列表以及结果列表的统称。函数签名不包括参数和结果的名称。</p><p>如果两个函数参数列表和结果列表的顺序以及类型相同，那么，这两个函数实现了同一个函数类型。</p><p>函数也可以用来实现<strong>闭包</strong>。所谓闭包，就是将某个函数类型作为闭包函数的一个参数，在调用时根据需求传动态传入函数，产生不同的行为。闭包函数在定义时并不会知道某个函数类型的具体实现，只有在调用时才会知道。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> operate <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> calculateFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genCalculater</span><span class="hljs-params">(op operate)</span></span> calculateFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> op == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;invalid operation&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> op(x, y), <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x, y := <span class="hljs-number">5</span>, <span class="hljs-number">7</span><br>op := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x * y<br>&#125;<br>mult := genCalculater(op) <span class="hljs-comment">// 生成乘法运算函数</span><br>result, err := mult(x, y)<br>fmt.Printf(<span class="hljs-string">&quot;result: %d (error: %v)\n&quot;</span>, result, err)<br><br>op2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br>add := genCalculater(op2) <span class="hljs-comment">// 生成加法运算函数</span><br>result, err = add(x, y)<br>fmt.Printf(<span class="hljs-string">&quot;result: %d (error: %v)\n&quot;</span>, result, err)<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语法概览 Part 1</title>
    <link href="/post/Go-grammar-overview-1.html"/>
    <url>/post/Go-grammar-overview-1.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章是对 Go 语言的基本语法做的一个笔记。计划用三篇文章来记录，这篇主要记录 Go 的词法元素。</p><h2 id="词法元素"><a href="#词法元素" class="headerlink" title="词法元素"></a>词法元素</h2><p>Go 语言的词法元素，也叫做语言符号，分为 5 类，如下所示：</p><ol><li>identifier：标识符</li><li>keyword：关键字</li><li>literal：字面量</li><li>delimiter：分隔符</li><li>operator：操作符</li></ol><span id="more"></span><h3 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h3><p>Go 语言中的标识符可以大致分为两类，一类用以表示<strong>程序实体</strong>，作为后者的名称而存在。其可以是 Unicode 字符集中任意能表示自然语言文字的字符、数字以及下划线（_）。</p><p>Go 中的变量、常量、函数和类型声明统称为程序实体。</p><p>在 Go 中标识符的首字母的大小写控制着对应程序实体的访问权限。</p><ul><li>首字母大写：对应的程序实体就可以被本代码包之外的代码访问到，既公开的。</li><li>首字母小写：对应的程序实体只能被本代码包的代码访问，既包级私有。</li></ul><p>空标识符 “_“，用于变量声明或代码包的导入语句中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化某个代码包，但不在当前文件中使用它的任何程序实体。</span><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 如果 x 声明后没有使用，编译器会报错。</span><br><span class="hljs-comment">// 使用空标识符可以绕过编译器检查。</span><br><span class="hljs-comment">// 在初始化后操作的对象就会被弃之不用。</span><br>_ = x<br></code></pre></td></tr></table></figure><p>另一类是<strong>预定义标识符</strong>，在 Go 语言的源码中被声明。分为以下几种：</p><ul><li>所有基本类型的名字</li><li>接口类型 error</li><li>常量 true，false 以及 itoa</li><li>所有内建函数的名字，append、cap、close、complete、copy、delete、imag、len、make、new、panic、print、prinln、real、recover。</li></ul><h3 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h3><p>Go 的关键字可以分为三类：</p><ul><li>程序声明：import 和 package</li><li>程序实体声明：chan、const、func、interface、map、struct、type、var</li><li>程序流程控制：go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</li></ul><p>使用 type 关键字可以声明一个自定义类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> customString <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>声明的自定义类型是被声明类型的一个别名类型。例如 rune 与 int32。两者之间的转换不会产生新值。</p><h3 id="oprator"><a href="#oprator" class="headerlink" title="oprator"></a>oprator</h3><p>Go 语言的操作符优先级，从高到低排列：</p><ul><li>*<strong><strong>、</strong>/<strong>、</strong>%<strong>、</strong>&lt;&lt; 、&gt;&gt;、 &amp;、 &amp;^</strong></li><li><strong>+ 、- 、|、 ^</strong></li><li><strong>==、！=、&lt;、&lt;=、&gt;、&gt;=</strong></li><li>&amp;&amp;</li><li>||</li></ul><h3 id="literal"><a href="#literal" class="headerlink" title="literal"></a>literal</h3><p>字面量：值的一种标记法。有三类：</p><ul><li><p>表示基础数据类型值的字面量。如，表示浮点数类型值的 <strong>12E-3</strong></p></li><li><p>构造自定义复合数据的类型字面量。如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>表示复合数据类型的值的字面量。如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Person&#123;Name: <span class="hljs-string">&quot;name&quot;</span>, Age: <span class="hljs-number">12</span>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给字符串来个索引</title>
    <link href="/post/index-on-string.html"/>
    <url>/post/index-on-string.html</url>
    
    <content type="html"><![CDATA[<p>在了解到索引的重要性，以及如何建立一个高效的索引后，就可以面对一些实际的需求进行操作，如何对常见的邮箱字段建立索引。</p><p>邮箱常作为登录时的字段，在用户登录的时候，往往需要对邮箱所在的表进行检索。如果没有针对邮箱字段建立索引的话，那么就只能进行全表扫描了，这种情况下，效率是十分的低的。</p><p>同时，邮箱作为一个字符串，可以利用 MySQL 的前缀原则，可以将邮箱的一部分定义为索引。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> n 是指定的字符串长度，如果不写，则默认为全部长度。<br><span class="hljs-operator">&gt;</span> alert <span class="hljs-keyword">table</span> t_name <span class="hljs-keyword">add</span> index index_name(email(n));<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="使用字符串前缀索引的优劣"><a href="#使用字符串前缀索引的优劣" class="headerlink" title="使用字符串前缀索引的优劣"></a>使用字符串前缀索引的优劣</h2><p>使用了前缀索引之后，可以<strong>节省空间</strong>，但是如果长度选取不够合理的时候，会<strong>增加读取数据的次数</strong>。</p><p>在前缀的长度选取不合理的情况下，M 个记录的前 N 个字段是完全相同的，这时，数据库需要在索引树上进行 M 次判断后才能选取到正确的结果集。</p><p>因此在对字符串建立前缀索引时，选取的前 N 个字符需要<strong>具有区分度</strong>。这样的话才能既节省空间，也不会让查询成本上升。</p><h2 id="前缀索引的其他使用方式"><a href="#前缀索引的其他使用方式" class="headerlink" title="前缀索引的其他使用方式"></a>前缀索引的其他使用方式</h2><p>如果字符串具有区分度的前 N 个字符的 N 值太大，可以利用别的方法建立索引。</p><p>一是<strong>倒序存储</strong>，将需要建立索引的字符串进行倒序后存储，从倒序的字符串中选取具有区分度的前 N 个字符建立索引，然后在查询的时候使用 <strong>reverse</strong> 函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> field_name <span class="hljs-keyword">from</span> t_name <span class="hljs-keyword">where</span> index_str <span class="hljs-operator">=</span> reverse(<span class="hljs-string">&#x27;input_string&#x27;</span>);<br></code></pre></td></tr></table></figure><p>二是利用 <strong>hash</strong> ，在表中新建一个字段，存储字符串的校验码。在存储时调用 hash 函数生成校验码存入数据库中。这种方法会增加额外的存储消耗。</p><p>这两个方法生成的索引都<strong>无法支持范围查询</strong>。</p><p>最后，使用了前缀索引后会影响到覆盖索引，无法再获得覆盖索引所带来的优化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好，思维导图</title>
    <link href="/post/hello-mind-map.html"/>
    <url>/post/hello-mind-map.html</url>
    
    <content type="html"><![CDATA[<p>今天在浏览推荐 Mac 使用的软件清单时，又看到了一个熟悉的身影——<a href="https://www.xmind.cn/">Xmind</a>，一款用于制作<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E5%9B%BE">思维导图</a>的工具。多次的交汇，最终激起了我使用他的欲望，同时也想看看使用思维导图能否帮助自己思考。</p><p>在 Google 上搜索思维导图，出现了一大批相关的结果，从介绍思维导图，到教你使用思维导图，再到推荐各种思维导图工具，比如我准备尝试的这款：Xmind。</p><p>面对着众多赞扬，我也按耐不住自己的好奇心，想去看看思维导图究竟是有着怎样的魅力。看看它是不是真的如它的推崇者所说的那样具有神奇的魔力，让自己的效率获得提升。</p><p>因此，我选中了推荐人数领先的 Xmind，从今天开始，我会使用它来绘制思维导图，帮助自己去梳理思绪，记录自己的一些笔记。</p><p>最后，思维导图，请多多关照🙇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>思维导图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记-索引篇-第二话</title>
    <link href="/post/MySQL-note-index-part2.html"/>
    <url>/post/MySQL-note-index-part2.html</url>
    
    <content type="html"><![CDATA[<p>这是 MySQL 笔记索引部分的第二篇，聚焦于如何更好的使用索引。<a href="/post/MySQL-note-index-part1">第一篇</a>聚焦于介绍什么是索引，索引的一些数据模型，以及 MySQL 中与索引相关的操作语句。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>MySQL 在利用索引进行查询时，可能会发生<strong>回表</strong>行为，不可避免的会影响到查询的效率。为了进一步的提高查询效率，可以利用一些手段避免回表。</p><span id="more"></span><p>之所以会发生回表，是因为二级索引树上没有存储需要查询的字段，只能查询到该记录所在行的主键，必须回到主索引树去查询相应的字段。</p><p>如果在二级索引上可以直接获得相应的值，那么就不会产生回表了，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*ID 是主键，k 是索引*/</span><br><span class="hljs-keyword">SELECT</span> ID <span class="hljs-keyword">FROM</span> table_test <span class="hljs-keyword">WHERE</span> k<span class="hljs-operator">=</span><span class="hljs-string">&#x27;key&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这被称为 <strong>覆盖索引</strong>，因为索引 k “覆盖” 了查询需求，利用 k 可以直接获得想要的结果。</p><p>可以看到，使用覆盖索引之后，整个查询过程中对树的搜索次数被明显减少了，由此可以带来显著的性能提升。</p><h3 id="通过联合索引完成覆盖索引"><a href="#通过联合索引完成覆盖索引" class="headerlink" title="通过联合索引完成覆盖索引"></a>通过联合索引完成覆盖索引</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当存在一个高频的需求，需要根据某个索引查找另一个字段数据，在这种情况下，就可以建立<strong>联合索引</strong>，在这个请求上应用到覆盖索引，减少了语句的运行时间。</p><p>例如，在如下的一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `cid` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `name_cid_INX` (`name`,`cid`),<br>)<br></code></pre></td></tr></table></figure><p>根据 name 查询 cid 的时候，就不需要经历回表了，可以直接通过所在的索引树获取到结果。</p><p>建立这样的索引在提升查询效率的同时，也会因为冗余问题而付出代价，在具体应用时需要权衡一番。</p><h4 id="使用最左前缀原则"><a href="#使用最左前缀原则" class="headerlink" title="使用最左前缀原则"></a>使用最左前缀原则</h4><p>在 B+ 树中，索引项会根据索引的最左前缀来进行排序，可以是联合索引的定义中出现最左 M 个字段，也可以是字符串索引的最左 N 的字符。</p><p>只要符合索引的最左前缀，就可以利用该索引来进行搜索了。</p><p>例如，上一段中的 (‘name’, ‘id’) 索引，其索引项的排序就会如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">|（‘Appl<span class="hljs-string">e&#x27;,&#x27;</span><span class="hljs-number">12</span><span class="hljs-string">&#x27;）| (&#x27;</span>Banana<span class="hljs-string">&#x27;, 13)  | (&#x27;</span>Banana<span class="hljs-string">&#x27;, 13)  | (&#x27;</span>Banana<span class="hljs-string">&#x27;, 14)|</span><br><span class="hljs-string">----------------------------------------------------------------------</span><br><span class="hljs-string">|    ID_1       |       ID_2      |    ID_3         |    ID_5        |</span><br><span class="hljs-string"></span><br><span class="hljs-string">-----&gt;</span><br></code></pre></td></tr></table></figure><p>查找 ‘Banana’ 时，就会定位到 ID_2, 然后向后查找；同样当查找 ‘Ba%’ 时，也可以利用该索引定位到 ID_2， 然后向后查找。</p><p>因此，当需要建立联合索引时，如果可以通过索引的位置顺序调整，来减少一个索引，那么就可以采用这种顺序来建立联合索引。</p><p>但是，当存在 name, cid 的联合查询，以及分别基于 name 和 cid 的单独查询时，需要维护两个索引，分别是 （’name’, ‘cid’) 以及 （’cid’)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当建立索引时，需要考虑到会出现的高频需求，各个需求之间能否合并建立联合索引来减少索引项。综合考虑到各种情况后，建立最合适的索引。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记——索引篇第一话</title>
    <link href="/post/MySQL-note-index-part1.html"/>
    <url>/post/MySQL-note-index-part1.html</url>
    
    <content type="html"><![CDATA[<p>最近在学习 MySQL 的内容，重头梳理了一下相关的知识点，在这里记录一下。</p><p>这里主要讲一下 MySQL 索引方面的知识。</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一张表，它保存了主键与索引字段，指向了实体表的记录。</p><span id="more"></span><p>如果说记载了各项记录的实体表是一本书的话，那么索引就是这本书的目录，利用它可以对记录进行快速的查找，提高查询效率。</p><p>索引分为两种，一种是<strong>单列索引</strong>，另一种是<strong>组合索引</strong>。</p><p>单列索引，顾名思义，就是每个索引只包含了一列，一张表可以有多个单列索引，而组合索引则是一个索引包含多个列。</p><h2 id="索引的实现"><a href="#索引的实现" class="headerlink" title="索引的实现"></a>索引的实现</h2><p>了解了什么是索引之后，就会想着怎么去利用数据结构去实现索引。</p><p>首先，索引与实体表记录之间存在着一一对应的映射关系，最容易想到的能够反映映射关系的数据结构就是<strong>哈希表</strong>。</p><p>哈希表是 key-value 类型存储数据的数据结构，只需要输入待查找的 key，就可以获得对应的 value 值。</p><p>哈希表的优点在于哈希表查找的时间复杂度是 O(1)，查找效率非常的高。但是哈希表也存在着缺点，那就是哈希表的存储的数据是无序的，如果需要进行区间查询，效率会非常的低。</p><p>其次，可以做为存储结构的是有序数组，有序数组的优点是查找效率高，同时它也支持区间查找，但是有序数组的插入十分低效，每一次插入都需要移动插入位置后的所有数据。适用于存储不会再修改的的数据，即静态存储引擎。</p><p>最后则是 N 叉树，利用 N 叉树既能保证搜索的效率，以及区间查找，又能保证插入修改的效率。因此在 InnoDB 引擎中就是使用 <strong>B+ 树</strong>来存储数据的。</p><p>根据 B+ 树叶子节点的不同，将索引分为两种：</p><ul><li>主键索引（聚簇索引 clustered index）：存储的是整行数据。</li><li>二级索引（secondary index）：存储的是主键的值。</li></ul><p>使用主键索引查找时，直接查找主键索引所在的 B+ 树；而利用二级索引进行查找时，会先在二级索引所在的 B+ 树上查找到对应的主键值，然后再去根据获取到的主键值去主键索引所在的 B+ 树上进行查找，这个过程被称之为回表。</p><p>基于二级索引的查询，会多遍历一次 B+ 树，因此尽量多使用主键查询。</p><h2 id="索引的操作语句"><a href="#索引的操作语句" class="headerlink" title="索引的操作语句"></a>索引的操作语句</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>创建最基本的索引，没有任何的限制条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX indexName <span class="hljs-keyword">ON</span> tableName(columnName(length));<br></code></pre></td></tr></table></figure><p><em>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length.</em></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX indexName <span class="hljs-keyword">ON</span> tableName(columnName(length));<br></code></pre></td></tr></table></figure><h3 id="2-修改表结构方式添加"><a href="#2-修改表结构方式添加" class="headerlink" title="2. 修改表结构方式添加"></a>2. 修改表结构方式添加</h3><h4 id="普通索引-1"><a href="#普通索引-1" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">ADD</span> INDEX indexName(columnName)<br></code></pre></td></tr></table></figure><h4 id="唯一索引-1"><a href="#唯一索引-1" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">ADD</span> INDEX indexName(columnName)<br></code></pre></td></tr></table></figure><h3 id="3-创建表的时候指定"><a href="#3-创建表的时候指定" class="headerlink" title="3. 创建表的时候指定"></a>3. 创建表的时候指定</h3><h4 id="普通索引-2"><a href="#普通索引-2" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tableName(  <br> <br>ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <br> <br>username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br> <br>INDEX [indexName] (username(length))  <br>); <br></code></pre></td></tr></table></figure><h4 id="唯一索引-2"><a href="#唯一索引-2" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable(  <br> <br>ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <br> <br>username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br> <br><span class="hljs-keyword">UNIQUE</span> [indexName] (username(length))  <br> <br>); <br></code></pre></td></tr></table></figure><h3 id="4-删除索引"><a href="#4-删除索引" class="headerlink" title="4. 删除索引"></a>4. 删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX [indexName] <span class="hljs-keyword">on</span> tableName;<br></code></pre></td></tr></table></figure><p>或者使用 alert 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tableName <span class="hljs-keyword">DROP</span> INDEX (indexName)；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
